{"version":3,"sources":["webpack://Tone/webpack/universalModuleDefinition","webpack://Tone/webpack/bootstrap","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/globals.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/constants.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-option.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/invalid-state-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/get-audio-node-connections.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/not-supported-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/intercept-connections.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/guards/native-audio-node-faker.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/module.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/test-promise-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/index-size-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/insert-element-in-set.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-active.js","webpack://Tone/./node_modules/automation-events/build/es5/bundle.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/is-part-of-a-cycle.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/get-event-listeners-of-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/guards/audio-node-output-connection.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/is-active-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/guards/audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/guards/native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/get-audio-param-connections.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-event-listener.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-get-channel-data-method.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/connect-native-audio-node-to-native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/disconnect-native-audio-node-from-native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/copy-from-channel.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/create-nested-arrays.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/invalid-access-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/overwrite-accessors.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/is-valid-latency-hint.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/read-only-map.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/copy-to-channel.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/filter-buffer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/compute-buffer-size.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/unknown-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/is-dc-curve.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/interfaces/index.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/types/index.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/abort-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/add-audio-node-connections.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/add-audio-param-connections.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/add-silent-connection.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/add-unrendered-audio-worklet-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/analyser-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/analyser-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/audio-listener-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/audio-param-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/audio-param-renderer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/base-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/cache-test-result.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/connect-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/connect-multiple-outputs.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/connected-native-audio-buffer-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/convert-number-to-unsigned-long.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/convolver-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/convolver-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/create-native-offline-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/data-clone-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/decrement-cycle-counter.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/delay-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/delay-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/delete-unrendered-audio-worklet-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/disconnect-multiple-outputs.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/encoding-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/evaluate-source.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/event-target-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/expose-current-frame-and-current-time.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/fetch-source.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/gain-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/gain-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-renderer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/get-audio-param-renderer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/get-backup-native-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/get-native-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/get-unrendered-audio-worklet-nodes.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/increment-cycle-counter-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/is-any-offline-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/is-native-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/is-native-offline-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/is-secure-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/is-supported-promise.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/media-element-audio-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-destination-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/media-stream-track-audio-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/minimal-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/minimal-base-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/minimal-offline-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/monitor-connections.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-audio-destination-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-audio-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-biquad-filter-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-channel-merger-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-convolver-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-convolver-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-delay-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-dynamics-compressor-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-gain-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-media-element-audio-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-destination-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-track-audio-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-offline-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-oscillator-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-periodic-wave-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-script-processor-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/offline-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/panner-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/panner-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/periodic-wave-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/render-automation.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/render-native-offline-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/start-rendering.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-constructor-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-copy-channel-methods-subarray-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-source-node-start-method-consecutive-calls-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-source-node-start-method-duration-parameter-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-source-node-start-method-offset-clamping-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-source-node-stop-method-nullified-buffer-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-close-method-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-decode-audio-data-method-type-error-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-options-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-node-connect-method-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-scheduled-source-node-start-method-negative-parameters-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-worklet-processor-no-outputs-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-channel-merger-node-channel-count-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-constant-source-node-accurate-scheduling-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-convolver-node-buffer-reassignability-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-is-secure-context-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-offline-audio-context-current-time-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/test-stereo-panner-node-default-value-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/window.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/wrap-channel-merger-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/test-transferables-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/guards/audio-worklet-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/delete-event-listeners-of-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/is-passive-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/pick-element-from-set.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive-when-necessary.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/test-audio-node-disconnect-method-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/visit-each-audio-node-once.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-node-disconnect-method.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/audio-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/clone-audio-worklet-node-options.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor-promise.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/is-constructible.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/split-import-statements.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/add-audio-worklet-module.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/test-analyser-node-get-float-time-domain-data-method-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-analyser-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-analyser-node-get-float-time-domain-data-method.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-duration-parameter.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/get-audio-worklet-processor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/decode-audio-data.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/detach-array-buffer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/guards/delay-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/detect-cycles.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-iir-filter-node-get-frequency-response-method.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/test-clonability-of-audio-worklet-node-options.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-channel-splitter-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2019/factories/native-channel-splitter-node-factory.js","webpack://Tone/./node_modules/@babel/runtime/helpers/slicedToArray.js","webpack://Tone/./node_modules/@babel/runtime/helpers/arrayWithHoles.js","webpack://Tone/./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","webpack://Tone/./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","webpack://Tone/./node_modules/@babel/runtime/helpers/arrayLikeToArray.js","webpack://Tone/./node_modules/@babel/runtime/helpers/nonIterableRest.js","webpack://Tone/./node_modules/@babel/runtime/helpers/classCallCheck.js","webpack://Tone/./node_modules/@babel/runtime/helpers/createClass.js","webpack://Tone/./Tone/version.ts","webpack://Tone/./Tone/core/util/Debug.ts","webpack://Tone/./Tone/core/util/TypeCheck.ts","webpack://Tone/./Tone/core/context/AudioContext.ts","webpack://Tone/./node_modules/tslib/tslib.es6.js","webpack://Tone/./Tone/core/clock/Ticker.ts","webpack://Tone/./Tone/core/util/AdvancedTypeCheck.ts","webpack://Tone/./Tone/core/util/Defaults.ts","webpack://Tone/./Tone/core/Tone.ts","webpack://Tone/./Tone/core/util/Math.ts","webpack://Tone/./Tone/core/util/Timeline.ts","webpack://Tone/./Tone/core/context/ContextInitialization.ts","webpack://Tone/./Tone/core/util/Emitter.ts","webpack://Tone/./Tone/core/context/BaseContext.ts","webpack://Tone/./Tone/core/context/Context.ts","webpack://Tone/./Tone/core/util/Interface.ts","webpack://Tone/./Tone/core/context/ToneAudioBuffer.ts","webpack://Tone/./Tone/core/context/OfflineContext.ts","webpack://Tone/./Tone/core/Global.ts","webpack://Tone/./Tone/core/context/DummyContext.ts","webpack://Tone/./Tone/core/type/Conversions.ts","webpack://Tone/./Tone/core/type/TimeBase.ts","webpack://Tone/./Tone/core/type/Time.ts","webpack://Tone/./Tone/core/type/Frequency.ts","webpack://Tone/./Tone/core/type/TransportTime.ts","webpack://Tone/./Tone/core/context/ToneWithContext.ts","webpack://Tone/./Tone/core/util/StateTimeline.ts","webpack://Tone/./Tone/core/context/Param.ts","webpack://Tone/./Tone/core/context/ToneAudioNode.ts","webpack://Tone/./Tone/core/context/Gain.ts","webpack://Tone/./Tone/source/OneShotSource.ts","webpack://Tone/./Tone/signal/ToneConstantSource.ts","webpack://Tone/./Tone/signal/Signal.ts","webpack://Tone/./Tone/core/clock/TickParam.ts","webpack://Tone/./Tone/core/clock/TickSignal.ts","webpack://Tone/./Tone/core/clock/TickSource.ts","webpack://Tone/./Tone/core/clock/Clock.ts","webpack://Tone/./Tone/core/util/TimelineValue.ts","webpack://Tone/./Tone/core/type/Ticks.ts","webpack://Tone/./Tone/core/util/IntervalTimeline.ts","webpack://Tone/./Tone/core/clock/TransportEvent.ts","webpack://Tone/./Tone/core/clock/TransportRepeatEvent.ts","webpack://Tone/./Tone/core/clock/Transport.ts","webpack://Tone/./Tone/core/context/Delay.ts","webpack://Tone/./Tone/component/channel/Volume.ts","webpack://Tone/./Tone/core/context/Destination.ts","webpack://Tone/./Tone/core/context/Offline.ts","webpack://Tone/./Tone/core/context/ToneAudioBuffers.ts","webpack://Tone/./Tone/core/type/Midi.ts","webpack://Tone/./Tone/core/util/Draw.ts","webpack://Tone/./Tone/source/Source.ts","webpack://Tone/./Tone/source/buffer/ToneBufferSource.ts","webpack://Tone/./Tone/source/Noise.ts","webpack://Tone/./Tone/source/UserMedia.ts","webpack://Tone/./Tone/source/oscillator/OscillatorInterface.ts","webpack://Tone/./Tone/source/oscillator/ToneOscillatorNode.ts","webpack://Tone/./Tone/source/oscillator/Oscillator.ts","webpack://Tone/./Tone/signal/SignalOperator.ts","webpack://Tone/./Tone/signal/WaveShaper.ts","webpack://Tone/./Tone/signal/AudioToGain.ts","webpack://Tone/./Tone/signal/Multiply.ts","webpack://Tone/./Tone/source/oscillator/AMOscillator.ts","webpack://Tone/./Tone/source/oscillator/FMOscillator.ts","webpack://Tone/./Tone/source/oscillator/PulseOscillator.ts","webpack://Tone/./Tone/source/oscillator/FatOscillator.ts","webpack://Tone/./Tone/source/oscillator/PWMOscillator.ts","webpack://Tone/./Tone/source/oscillator/OmniOscillator.ts","webpack://Tone/./Tone/signal/Add.ts","webpack://Tone/./Tone/signal/Scale.ts","webpack://Tone/./Tone/signal/Zero.ts","webpack://Tone/./Tone/source/oscillator/LFO.ts","webpack://Tone/./Tone/core/util/Decorator.ts","webpack://Tone/./Tone/source/buffer/Player.ts","webpack://Tone/./Tone/source/buffer/Players.ts","webpack://Tone/./Tone/source/buffer/GrainPlayer.ts","webpack://Tone/./Tone/signal/Abs.ts","webpack://Tone/./Tone/signal/GainToAudio.ts","webpack://Tone/./Tone/signal/Negate.ts","webpack://Tone/./Tone/signal/Subtract.ts","webpack://Tone/./Tone/signal/GreaterThanZero.ts","webpack://Tone/./Tone/signal/GreaterThan.ts","webpack://Tone/./Tone/signal/Pow.ts","webpack://Tone/./Tone/signal/ScaleExp.ts","webpack://Tone/./Tone/signal/SyncedSignal.ts","webpack://Tone/./Tone/component/envelope/Envelope.ts","webpack://Tone/./Tone/instrument/Instrument.ts","webpack://Tone/./Tone/instrument/Monophonic.ts","webpack://Tone/./Tone/component/envelope/AmplitudeEnvelope.ts","webpack://Tone/./Tone/instrument/Synth.ts","webpack://Tone/./Tone/instrument/ModulationSynth.ts","webpack://Tone/./Tone/instrument/AMSynth.ts","webpack://Tone/./Tone/component/filter/BiquadFilter.ts","webpack://Tone/./Tone/component/filter/Filter.ts","webpack://Tone/./Tone/component/envelope/FrequencyEnvelope.ts","webpack://Tone/./Tone/instrument/MonoSynth.ts","webpack://Tone/./Tone/instrument/DuoSynth.ts","webpack://Tone/./Tone/instrument/FMSynth.ts","webpack://Tone/./Tone/instrument/MetalSynth.ts","webpack://Tone/./Tone/instrument/MembraneSynth.ts","webpack://Tone/./Tone/instrument/NoiseSynth.ts","webpack://Tone/./Tone/core/worklet/WorkletGlobalScope.ts","webpack://Tone/./Tone/core/worklet/ToneAudioWorklet.ts","webpack://Tone/./Tone/core/worklet/ToneAudioWorkletProcessor.worklet.ts","webpack://Tone/./Tone/core/worklet/SingleIOProcessor.worklet.ts","webpack://Tone/./Tone/core/worklet/DelayLine.worklet.ts","webpack://Tone/./Tone/component/filter/FeedbackCombFilter.worklet.ts","webpack://Tone/./Tone/component/filter/FeedbackCombFilter.ts","webpack://Tone/./Tone/component/filter/OnePoleFilter.ts","webpack://Tone/./Tone/component/filter/LowpassCombFilter.ts","webpack://Tone/./Tone/instrument/PluckSynth.ts","webpack://Tone/./Tone/instrument/PolySynth.ts","webpack://Tone/./Tone/instrument/Sampler.ts","webpack://Tone/./Tone/event/ToneEvent.ts","webpack://Tone/./Tone/event/Loop.ts","webpack://Tone/./Tone/event/Part.ts","webpack://Tone/./Tone/event/PatternGenerator.ts","webpack://Tone/./Tone/event/Pattern.ts","webpack://Tone/./Tone/event/Sequence.ts","webpack://Tone/./Tone/component/channel/CrossFade.ts","webpack://Tone/./Tone/effect/Effect.ts","webpack://Tone/./Tone/effect/LFOEffect.ts","webpack://Tone/./Tone/effect/AutoFilter.ts","webpack://Tone/./Tone/component/channel/Panner.ts","webpack://Tone/./Tone/effect/AutoPanner.ts","webpack://Tone/./Tone/component/analysis/Follower.ts","webpack://Tone/./Tone/effect/AutoWah.ts","webpack://Tone/./Tone/effect/BitCrusher.worklet.ts","webpack://Tone/./Tone/effect/BitCrusher.ts","webpack://Tone/./Tone/effect/Chebyshev.ts","webpack://Tone/./Tone/component/channel/Split.ts","webpack://Tone/./Tone/component/channel/Merge.ts","webpack://Tone/./Tone/effect/StereoEffect.ts","webpack://Tone/./Tone/effect/StereoFeedbackEffect.ts","webpack://Tone/./Tone/effect/Chorus.ts","webpack://Tone/./Tone/effect/Distortion.ts","webpack://Tone/./Tone/effect/FeedbackEffect.ts","webpack://Tone/./Tone/effect/FeedbackDelay.ts","webpack://Tone/./Tone/component/filter/PhaseShiftAllpass.ts","webpack://Tone/./Tone/effect/FrequencyShifter.ts","webpack://Tone/./Tone/effect/Freeverb.ts","webpack://Tone/./Tone/effect/JCReverb.ts","webpack://Tone/./Tone/effect/StereoXFeedbackEffect.ts","webpack://Tone/./Tone/effect/PingPongDelay.ts","webpack://Tone/./Tone/effect/PitchShift.ts","webpack://Tone/./Tone/effect/Phaser.ts","webpack://Tone/./Tone/effect/Reverb.ts","webpack://Tone/./Tone/component/channel/MidSideSplit.ts","webpack://Tone/./Tone/component/channel/MidSideMerge.ts","webpack://Tone/./Tone/effect/MidSideEffect.ts","webpack://Tone/./Tone/effect/StereoWidener.ts","webpack://Tone/./Tone/effect/Tremolo.ts","webpack://Tone/./Tone/effect/Vibrato.ts","webpack://Tone/./Tone/component/analysis/Analyser.ts","webpack://Tone/./Tone/component/analysis/MeterBase.ts","webpack://Tone/./Tone/component/analysis/Meter.ts","webpack://Tone/./Tone/component/analysis/FFT.ts","webpack://Tone/./Tone/component/analysis/DCMeter.ts","webpack://Tone/./Tone/component/analysis/Waveform.ts","webpack://Tone/./Tone/component/channel/Solo.ts","webpack://Tone/./Tone/component/channel/PanVol.ts","webpack://Tone/./Tone/component/channel/Channel.ts","webpack://Tone/./Tone/component/channel/MultibandSplit.ts","webpack://Tone/./Tone/core/context/Listener.ts","webpack://Tone/./Tone/component/channel/Panner3D.ts","webpack://Tone/./Tone/component/channel/Recorder.ts","webpack://Tone/./Tone/component/dynamics/Compressor.ts","webpack://Tone/./Tone/component/dynamics/Gate.ts","webpack://Tone/./Tone/component/dynamics/Limiter.ts","webpack://Tone/./Tone/component/dynamics/MidSideCompressor.ts","webpack://Tone/./Tone/component/dynamics/MultibandCompressor.ts","webpack://Tone/./Tone/component/filter/EQ3.ts","webpack://Tone/./Tone/component/filter/Convolver.ts","webpack://Tone/./Tone/index.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ACTIVE_AUDIO_NODE_STORE","WeakSet","AUDIO_NODE_CONNECTIONS_STORE","WeakMap","AUDIO_NODE_STORE","AUDIO_PARAM_CONNECTIONS_STORE","AUDIO_PARAM_STORE","BACKUP_NATIVE_CONTEXT_STORE","CONTEXT_STORE","EVENT_LISTENERS","CYCLE_COUNTERS","NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS","NODE_TO_PROCESSOR_MAPS","assignNativeAudioNodeOptions","nativeAudioNode","options","MOST_NEGATIVE_SINGLE_FLOAT","MOST_POSITIVE_SINGLE_FLOAT","isOwnedByContext","nativeContext","context","assignNativeAudioNodeOption","option","undefined","assignNativeAudioNodeAudioParamValue","audioParam","getNativeAudioNode","audioNode","createInvalidStateError","DOMException","err","code","getAudioNodeConnections","getValueForKey","map","Error","createNotSupportedError","interceptConnections","original","interceptor","connect","disconnect","isNativeAudioNodeFaker","nativeAudioNodeOrNativeAudioNodeFaker","cacheTestResult","Map","window","nativeOfflineAudioContextConstructor","isNativeOfflineAudioContext","nativeAudioContextConstructor","getBackupNativeContext","createNativeAudioNode","createNativeAnalyserNode","getAudioNodeRenderer","renderInputsOfAudioNode","createAnalyserNodeRenderer","auxiliaryGainNodeStore","getNativeContext","audioParamAudioNodeStore","eventTargetConstructor","isNativeAudioContext","isNativeAudioNode","isNativeAudioParam","audioNodeConstructor","analyserNodeConstructor","audioBufferStore","nativeAudioBufferConstructor","convertNumberToUnsignedLong","Uint32Array","wrapAudioBufferCopyChannelMethods","wrapAudioBufferCopyChannelMethodsOutOfBounds","audioBufferConstructor","createNativeGainNode","addSilentConnection","testAudioScheduledSourceNodeStartMethodNegativeParametersSupport","testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","testAudioScheduledSourceNodeStopMethodNegativeParametersSupport","wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","renderInputsOfAudioParam","connectAudioParam","createNativeAudioBufferSourceNode","renderAutomation","createAudioBufferSourceNodeRenderer","createAudioParam","audioBufferSourceNodeConstructor","audioDestinationNodeConstructor","createNativeBiquadFilterNode","createBiquadFilterNodeRenderer","biquadFilterNodeConstructor","monitorConnections","wrapChannelMergerNode","createNativeChannelMergerNode","createChannelMergerNodeRenderer","channelMergerNodeConstructor","createNativeChannelSplitterNode","createChannelSplitterNodeRenderer","channelSplitterNodeConstructor","createNativeConstantSourceNodeFaker","createNativeConstantSourceNode","createConstantSourceNodeRenderer","constantSourceNodeConstructor","createNativeConvolverNodeFaker","createNativeConvolverNode","createConvolverNodeRenderer","convolverNodeConstructor","createNativeDelayNode","createDelayNodeRenderer","delayNodeConstructor","createNativeDynamicsCompressorNode","createDynamicsCompressorNodeRenderer","dynamicsCompressorNodeConstructor","createGainNodeRenderer","gainNodeConstructor","createNativeScriptProcessorNode","createNativeIIRFilterNodeFaker","renderNativeOfflineAudioContext","createIIRFilterNodeRenderer","createNativeIIRFilterNode","iIRFilterNodeConstructor","createAudioListener","unrenderedAudioWorkletNodeStore","minimalBaseAudioContextConstructor","createNativeOscillatorNode","createOscillatorNodeRenderer","oscillatorNodeConstructor","createConnectedNativeAudioBufferSourceNode","createNativeWaveShaperNodeFaker","createNativeWaveShaperNode","createNativePannerNodeFaker","createNativePannerNode","createPannerNodeRenderer","pannerNodeConstructor","createNativePeriodicWave","periodicWaveConstructor","nativeStereoPannerNodeFakerFactory","createNativeStereoPannerNode","createStereoPannerNodeRenderer","stereoPannerNodeConstructor","createWaveShaperNodeRenderer","waveShaperNodeConstructor","isSecureContext","exposeCurrentFrameAndCurrentTime","addAudioWorkletModule","isNativeContext","decodeAudioData","baseAudioContextConstructor","createNativeMediaElementAudioSourceNode","mediaElementAudioSourceNodeConstructor","createNativeMediaStreamAudioDestinationNode","mediaStreamAudioDestinationNodeConstructor","createNativeMediaStreamAudioSourceNode","mediaStreamAudioSourceNodeConstructor","createNativeMediaStreamTrackAudioSourceNode","mediaStreamTrackAudioSourceNodeConstructor","audioContextConstructor","getUnrenderedAudioWorkletNodes","addUnrenderedAudioWorkletNode","connectMultipleOutputs","deleteUnrenderedAudioWorkletNode","disconnectMultipleOutputs","createNativeAudioWorkletNodeFaker","createNativeAudioWorkletNode","nativeAudioWorkletNodeConstructor","createAudioWorkletNodeRenderer","audioWorkletNodeConstructor","createNativeOfflineAudioContext","startRendering","offlineAudioContextConstructor","isAnyAudioContext","isAnyAudioNode","isAnyAudioParam","isAnyOfflineAudioContext","isSupported","testPromiseSupport","uint32Array","promise","buffer","catch","createIndexSizeError","insertElementInSet","set","element","predicate","ignoreDuplicates","lmnt","add","setInternalStateToActive","has","forEach","eventListener","_slicedToArray","_classCallCheck","_createClass","createExtendedExponentialRampToValueAutomationEvent","endTime","insertTime","type","createExtendedLinearRampToValueAutomationEvent","createSetValueAutomationEvent","startTime","createSetValueCurveAutomationEvent","values","duration","getTargetValueAtTime","time","valueAtStartTime","_ref","target","timeConstant","Math","exp","isExponentialRampToValueAutomationEvent","automationEvent","isLinearRampToValueAutomationEvent","isAnyRampToValueAutomationEvent","isSetValueAutomationEvent","isSetValueCurveAutomationEvent","getValueOfAutomationEventAtIndexAtTime","automationEvents","index","defaultValue","length","getEndTimeAndValueOfPreviousAutomationEvent","currentAutomationEvent","nextAutomationEvent","isCancelAndHoldAutomationEvent","isCancelScheduledValuesAutomationEvent","getEventTime","cancelTime","getExponentialRampValueAtTime","pow","getLinearRampValueAtTime","getValueCurveValueAtTime","theoreticIndex","lowerIndex","floor","upperIndex","ceil","interpolateValue","isSetTargetAutomationEvent","AutomationEventList","_automationEvents","_currenTime","_defaultValue","iterator","eventTime","findIndex","removedAutomationEvent","slice","lastAutomationEvent","startValue","truncatedAutomationEvent","push","getValue","Float32Array","_index","previousAutomationEvent","persistentAutomationEvent","splice","remainingAutomationEvents","firstRemainingAutomationEvent","unshift","_getEndTimeAndValueOf","_getEndTimeAndValueOf2","_getEndTimeAndValueOf3","_getEndTimeAndValueOf4","_startTime","_value","createCancelAndHoldAutomationEvent","createCancelScheduledValuesAutomationEvent","createExponentialRampToValueAutomationEvent","createLinearRampToValueAutomationEvent","createSetTargetAutomationEvent","isPartOfACycle","getEventListenersOfAudioNode","setInternalStateToPassive","delete","isAudioNodeOutputConnection","outputConnection","isActiveAudioNode","isAudioNode","audioNodeOrAudioParam","nativeAudioNodeOrAudioParam","getAudioParamConnections","getNativeAudioParam","wrapEventListener","event","descriptor","defineProperties","currentTarget","handleEvent","wrapAudioBufferGetChannelDataMethod","audioBuffer","getChannelData","channel","wrapAudioScheduledSourceNodeStartMethodNegativeParameters","nativeAudioScheduledSourceNode","start","when","offset","RangeError","wrapAudioScheduledSourceNodeStopMethodNegativeParameters","stop","testAudioBufferCopyChannelMethodsOutOfBoundsSupport","nativeAudioBuffer","copyToChannel","connectNativeAudioNodeToNativeAudioNode","nativeSourceAudioNode","nativeDestinationAudioNode","output","input","fakeNativeDestinationAudioNode","inputs","disconnectNativeAudioNodeFromNativeAudioNode","copyFromChannel","parent","channelNumber","bufferOffset","byteLength","channelData","slicedInput","BYTES_PER_ELEMENT","createNestedArrays","x","y","arrays","array","j","createInvalidAccessError","overwriteAccessors","createGetter","createSetter","getPrototypeOf","getOwnPropertyDescriptor","isValidLatencyHint","latencyHint","ReadOnlyMap","parameters","_map","size","entries","callback","thisArg","keys","filterBuffer","feedback","feedbackLength","feedforward","feedforwardLength","minLength","xBuffer","yBuffer","bufferIndex","bufferLength","inputLength","k","computeBufferSize","baseLatency","sampleRate","max","min","round","log2","createUnknownError","isDCCurve","curve","createAbortError","createAddAudioNodeConnections","audioNodeConnectionsStore","audioNodeRenderer","activeInputs","numberOfInputs","Set","outputs","passiveInputs","renderer","createAddAudioParamConnections","audioParamConnectionsStore","audioParamRenderer","createAddSilentConnection","nativeGainNode","channelCount","channelCountMode","channelInterpretation","gain","destination","removeEventListener","addEventListener","createAddUnrenderedAudioWorkletNode","audioWorkletNode","DEFAULT_OPTIONS","fftSize","maxDecibels","minDecibels","smoothingTimeConstant","createAnalyserNodeConstructor","audionNodeConstructor","mergedOptions","nativeAnalyserNode","super","_nativeAnalyserNode","frequencyBinCount","getByteFrequencyData","getByteTimeDomainData","getFloatFrequencyData","getFloatTimeDomainData","createAnalyserNodeRendererFactory","renderedNativeAnalyserNodes","proxy","nativeOfflineAudioContext","trace","renderedNativeAnalyserNode","Promise","resolve","async","createAnalyserNode","numberOfChannels","createAudioBufferConstructor","testNativeAudioBufferConstructorSupport","AudioBuffer","createBuffer","hasInstance","instance","loop","loopEnd","loopStart","playbackRate","createAudioBufferSourceNodeConstructor","nativeAudioBufferSourceNode","isOffline","audioBufferSourceNodeRenderer","_audioBufferSourceNodeRenderer","_isBufferNullified","_isBufferSet","_nativeAudioBufferSourceNode","_onended","_playbackRate","fill","wrappedListener","onended","nativeOnEnded","resetInternalStateToPassive","setTimeout","createAudioBufferSourceNodeRendererFactory","renderedNativeAudioBufferSourceNodes","renderedNativeAudioBufferSourceNode","nativeAudioBufferSourceNodeIsOwnedByContext","createAudioBufferSourceNode","createAudioContextConstructor","nativeAudioContext","TypeError","_baseLatency","_nativeAudioContext","_state","state","revokeState","close","then","mediaElement","mediaStream","mediaStreamTrack","reject","resolvePromise","resume","suspend","createAudioDestinationNodeConstructor","createAudioDestinationNodeRenderer","createNativeAudioDestinationNode","nativeAudioDestinationNode","_isNodeOfNativeOfflineAudioContext","_nativeAudioDestinationNode","maxChannelCount","nativeAudioDestinationNodePromise","render","createAudioDestinationNode","createAudioListenerFactory","nativeListener","listener","forwardX","forwardY","forwardZ","positionX","positionY","positionZ","upX","upY","upZ","channelMergerNode","scriptProcessorNode","createFakeAudioParam","constantSourceNode","lastOrientation","lastPosition","onaudioprocess","inputBuffer","orientation","some","setOrientation","positon","setPosition","createFakeAudioParams","createAudioParamFactory","addAudioParamConnections","audioParamStore","createAudioParamRenderer","isAudioParamOfOfflineAudioContext","nativeAudioParam","maxValue","minValue","automationEventList","setValueAtTime","currentTime","cancelAndHoldAtTime","flush","previousLastEvent","Array","from","pop","currentLastEvent","cancelScheduledValues","exponentialRampToValueAtTime","linearRampToValueAtTime","setValueCurveAtTime","setTargetAtTime","firstSample","lastSample","numberOfInterpolatedValues","interpolatedValues","timeOfLastSample","numberOfOutputs","outputChannelCount","parameterData","processorOptions","createChannelCount","createAudioWorkletNodeConstructor","sanitizedOptions","nodeNameToProcessorConstructorMap","processorConstructor","nativeAudioWorkletNode","nm","_nativeAudioWorkletNode","_onprocessorerror","_parameters","onprocessorerror","nativeOnProcessorError","port","createBaseAudioContextConstructor","_nativeContext","_audioWorklet","addModule","moduleURL","maxDelayTime","real","imag","constraints","disableNormalization","audioData","successCallback","errorCallback","Q","detune","frequency","createBiquadFilterNodeConstructor","nativeBiquadFilterNode","_Q","_detune","_frequency","_gain","log10","_nativeBiquadFilterNode","frequencyHz","magResponse","phaseResponse","getFrequencyResponse","createBiquadFilterNodeRendererFactory","renderedNativeBiquadFilterNodes","renderedNativeBiquadFilterNode","nativeBiquadFilterNodeIsOwnedByContext","createBiquadFilterNode","createCacheTestResult","ongoingTests","testResults","tester","test","cachedTestResult","ongoingTest","synchronousTestResult","finalTestResult","createChannelMergerNodeConstructor","createChannelMergerNodeRendererFactory","renderedNativeAudioNodes","renderedNativeAudioNode","createAudioNode","createChannelSplitterNodeConstructor","createChannelSplitterNodeRendererFactory","createConnectAudioParam","createConnectMultipleOutputs","outputAudioNodes","outputAudioNode","createConnectedNativeAudioBufferSourceNodeFactory","createConstantSourceNodeConstructor","createConstantSourceNodeRendererFactory","nativeConstantSourceNode","constantSourceNodeRenderer","_constantSourceNodeRenderer","_nativeConstantSourceNode","_offset","renderedNativeConstantSourceNodes","renderedNativeConstantSourceNode","nativeConstantSourceNodeIsOwnedByContext","createConstantSourceNode","createConvertNumberToUnsignedLong","unit32Array","createConvolverNodeConstructor","nativeConvolverNode","_nativeConvolverNode","normalize","createConvolverNodeRendererFactory","renderedNativeConvolverNodes","renderedNativeConvolverNode","createConvolverNode","createCreateNativeOfflineAudioContext","createDataCloneError","createDecrementCycleCounter","cycleCounters","count","cycleCounter","nativeDestinationAudioParam","delayTime","createDelayNodeConstructor","nativeDelayNode","_delayTime","createDelayNodeRendererFactory","renderedNativeDelayNodes","renderedNativeDelayNode","nativeDelayNodeIsOwnedByContext","createDelayNode","createDeleteUnrenderedAudioWorkletNode","getOutputAudioNodeAtIndex","createDisconnectMultipleOutputs","destinationOrOutput","attack","knee","ratio","release","threshold","createDynamicsCompressorNodeConstructor","nativeDynamicsCompressorNode","_attack","_knee","_nativeDynamicsCompressorNode","_ratio","_release","_threshold","previousChannelCount","reduction","createDynamicsCompressorNodeRendererFactory","renderedNativeDynamicsCompressorNodes","renderedNativeDynamicsCompressorNode","nativeDynamicsCompressorNodeIsOwnedByContext","createDynamicsCompressorNode","createEncodingError","createEvaluateSource","source","SyntaxError","head","document","script","createElement","blob","Blob","url","URL","createObjectURL","originalOnErrorHandler","onerror","removeErrorEventListenerAndRevokeUrl","revokeObjectURL","message","src","lineno","colno","error","location","href","onload","appendChild","createEventTargetConstructor","_nativeEventTarget","_listeners","wrappedEventListener","dispatchEvent","createExposeCurrentFrameAndCurrentTime","fn","currentFrame","configurable","createFetchSource","response","fetch","ok","text","createGainNodeConstructor","createGainNodeRendererFactory","renderedNativeGainNodes","renderedNativeGainNode","nativeGainNodeIsOwnedByContext","createGainNode","createGetAudioNodeRenderer","audioNodeConnections","createGetAudioParamRenderer","audioParamConnections","createGetBackupNativeContext","backupNativeContext","bckpNtveCntxt","createGetNativeContext","contextStore","createGetUnrenderedAudioWorkletNodes","unrenderedAudioWorkletNodes","createIIRFilterNodeRendererFactory","filteredBufferPromise","nativeIIRFilterNode","nativeIIRFilterNodeIsOwnedByContext","createIIRFilter","ntvCntxt","partialOfflineAudioContext","renderedBuffer","filteredBuffer","filterFullBuffer","createIncrementCycleCounterFactory","createIsAnyAudioContext","anything","createIsAnyAudioNode","audioNodeStore","createIsAnyAudioParam","createIsAnyOfflineAudioContext","createIsNativeAudioContext","createIsNativeAudioNode","AudioNode","createIsNativeAudioParam","AudioParam","createIsNativeContext","createIsNativeOfflineAudioContext","createIsSecureContext","createIsSupportedPromise","testAudioBufferCopyChannelMethodsSubarraySupport","testAudioContextCloseMethodSupport","testAudioContextDecodeAudioDataMethodTypeErrorSupport","testAudioContextOptionsSupport","testAudioNodeConnectMethodSupport","testAudioWorkletProcessorNoOutputsSupport","testChannelMergerNodeChannelCountSupport","testConstantSourceNodeAccurateSchedulingSupport","testConvolverNodeBufferReassignabilitySupport","testIsSecureContextSupport","testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport","testStereoPannerNodeDefaultValueSupport","testTransferablesSupport","all","every","result","createMediaElementAudioSourceNodeConstructor","nativeMediaElementAudioSourceNode","_mediaElement","_nativeMediaElementAudioSourceNode","createMediaStreamAudioDestinationNodeConstructor","nativeMediaStreamAudioDestinationNode","_nativeMediaStreamAudioDestinationNode","stream","createMediaStreamAudioSourceNodeConstructor","nativeMediaStreamAudioSourceNode","_nativeMediaStreamAudioSourceNode","createMediaStreamTrackAudioSourceNodeConstructor","createMinimalAudioContextConstructor","createMinimalBaseAudioContextConstructor","_destination","_listener","_onstatechange","onstatechange","nativeOnStateChange","createMinimalOfflineAudioContextConstructor","delayStateChangeEvent","stopImmediatePropagation","_waitForThePromiseToSettle","_length","_nativeOfflineAudioContext","createMonitorConnections","whenConnected","whenDisconnected","connections","wasDisconnected","connection","wasConnected","apply","clear","isDisconnected","createNativeAudioBufferConstructor","createNativeAudioContextConstructor","AudioContext","webkitAudioContext","createNativeAudioDestinationNodeFactory","isNodeOfNativeOfflineAudioContext","gainNode","createNativeAudioNodeFactory","factoryFunction","createNativeAudioWorkletNodeConstructor","AudioWorkletNode","createNativeBiquadFilterNodeFactory","createBiquadFilter","createNativeChannelMergerNodeFactory","nativeChannelMergerNode","createChannelMerger","createNativeConstantSourceNodeFactory","createConstantSource","createNativeConstantSourceNodeFakerFactory","audioNodeOptions","audioBufferSourceNode","nativeConstantSourceNodeFaker","args","createNativeConvolverNodeFactory","createConvolver","createNativeConvolverNodeFakerFactory","convolverNode","nativeConvolverNodeFaker","createNativeDelayNodeFactory","createDelay","createNativeDynamicsCompressorNodeFactory","createDynamicsCompressor","createNativeGainNodeFactory","createGain","createNativeIIRFilterNodeFactory","divide","a","b","denominator","evaluatePolynomial","coefficient","z","createNativeIIRFilterNodeFakerFactory","bufferSize","bufferIndexes","xBuffers","yBuffers","outputBuffer","nyquist","nativeIIRFilterNodeFaker","omega","PI","cos","sin","sqrt","atan2","createNativeMediaElementAudioSourceNodeFactory","ntvDCntxt","createMediaElementSource","createNativeMediaStreamAudioDestinationNodeFactory","createMediaStreamDestination","createNativeMediaStreamAudioSourceNodeFactory","audioStreamTracks","getAudioTracks","filteredAudioStreamTracks","sort","id","createMediaStreamSource","MediaStream","createNativeMediaStreamTrackAudioSourceNodeFactory","createMediaStreamTrackSource","kind","createNativeOfflineAudioContextConstructor","OfflineAudioContext","webkitOfflineAudioContext","createNativeOscillatorNodeFactory","nativeOscillatorNode","createOscillator","periodicWave","setPeriodicWave","createNativePannerNodeFactory","nativePannerNode","createPanner","orientationX","createNativePannerNodeFakerFactory","coneInnerAngle","coneOuterAngle","coneOuterGain","distanceModel","maxDistance","orientationY","orientationZ","panningModel","refDistance","rolloffFactor","pannerNode","SINGLE_CHANNEL_OPTIONS","inputGainNode","orientationXGainNode","orientationYGainNode","orientationZGainNode","positionXGainNode","positionYGainNode","positionZGainNode","waveShaperNode","oversample","nativePannerNodeFaker","createNativePeriodicWaveFactory","wrappedImag","wrappedReal","createPeriodicWave","createNativeScriptProcessorNodeFactory","numberOfInputChannels","numberOfOutputChannels","createScriptProcessor","createNativeStereoPannerNodeFactory","createNativeStereoPannerNodeFaker","createStereoPanner","nativeStereoPannerNode","createNativeStereoPannerNodeFakerFactory","DC_CURVE","HALF_PI","SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS","buildInternalGraph","panGainNode","leftWaveShaperCurve","rightWaveShaperCurve","leftGainNode","leftWaveShaperNode","panWaveShaperNode","rightGainNode","rightWaveShaperNode","buildInternalGraphForMono","leftInputForLeftOutputWaveShaperCurve","leftInputForRightOutputWaveShaperCurve","rightInputForLeftOutputWaveShaperCurve","rightInputForRightOutputWaveShaperCurve","centerIndex","CURVE_SIZE","channelSplitterNode","leftInputForLeftOutputGainNode","leftInputForLeftOutputWaveShaperNode","leftInputForRightOutputGainNode","leftInputForRightOutputWaveShaperNode","rightInputForLeftOutputGainNode","rightInputForLeftOutputWaveShaperNode","rightInputForRightOutputGainNode","rightInputForRightOutputWaveShaperNode","buildInternalGraphForStereo","pan","connectGraph","disconnectGraph","isConnected","createNativeWaveShaperNodeFactory","nativeWaveShaperNode","createWaveShaper","disconnectNativeAudioBufferSourceNode","createNativeWaveShaperNodeFakerFactory","negativeWaveShaperNode","positiveWaveShaperNode","invertGainNode","outputGainNode","revertGainNode","unmodifiedCurve","nativeWaveShaperNodeFaker","curveLength","negativeCurve","positiveCurve","createOfflineAudioContextConstructor","createOscillatorNodeConstructor","oscillatorNodeRenderer","_nativeOscillatorNode","_oscillatorNodeRenderer","createOscillatorNodeRendererFactory","renderedNativeOscillatorNodes","renderedNativeOscillatorNode","nativeOscillatorNodeIsOwnedByContext","createOscillatorNode","createPannerNodeConstructor","_nativePannerNode","_orientationX","_orientationY","_orientationZ","_positionX","_positionY","_positionZ","createPannerNodeRendererFactory","renderedBufferPromise","renderedNativeGainNodeOrNativePannerNode","commonAudioNodeOptions","commonNativePannerNodeOptions","nativePannerNodeIsOwnedByContext","nativeConstantSourceNodes","channelDatas","gateGainNode","partialPannerNode","createPeriodicWaveConstructor","periodicWaveStore","PeriodicWave","createRenderAutomation","getAudioParamRenderer","replay","createRenderInputsOfAudioNode","nextTrace","filter","includes","reduce","allRenderingPromises","renderingPromises","createRenderInputsOfAudioParam","createRenderNativeOfflineAudioContext","testOfflineAudioContextCurrentTimeSupport","isOfflineAudioContextCurrentTimeSupported","oncomplete","createStartRendering","createStereoPannerNodeConstructor","_pan","createStereoPannerNodeRendererFactory","renderedNativeStereoPannerNodes","renderedNativeStereoPannerNode","nativeStereoPannerNodeIsOwnedByContext","createStereoPannerNode","createTestAudioBufferConstructorSupport","createTestAudioBufferCopyChannelMethodsSubarraySupport","createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport","createBufferSource","createTestAudioBufferSourceNodeStartMethodDurationParameterSupport","offlineAudioContext","createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport","createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport","createTestAudioContextCloseMethodSupport","audioContext","isAudioContextClosable","createTestAudioContextDecodeAudioDataMethodTypeErrorSupport","isPending","createTestAudioContextOptionsSupport","createTestAudioNodeConnectMethodSupport","createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport","createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport","createTestAudioWorkletProcessorNoOutputsSupport","isCallingProcess","audioWorklet","onmessage","createTestChannelMergerNodeChannelCountSupport","createTestConstantSourceNodeAccurateSchedulingSupport","Number","POSITIVE_INFINITY","createTestConvolverNodeBufferReassignabilitySupport","createTestIsSecureContextSupport","createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport","createTestOfflineAudioContextCurrentTimeSupport","createTestStereoPannerNodeDefaultValueSupport","stereoPanner","createWaveShaperNodeConstructor","_isCurveNullified","_nativeWaveShaperNode","createWaveShaperNodeRendererFactory","renderedNativeWaveShaperNodes","renderedNativeWaveShaperNode","createWaveShaperNode","createWindow","createWrapAudioBufferCopyChannelMethods","channelNumberAsNumber","bufferOffsetAsNumber","audioBufferLength","destinationLength","sourceLength","createWrapAudioBufferCopyChannelMethodsOutOfBounds","createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer","nullifiedBuffer","createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","disconnectGainNode","isStopped","createWrapChannelMergerNode","monitorConnectionsFunction","arrayBuffer","ArrayBuffer","port1","port2","MessageChannel","data","postMessage","wrapAudioBufferSourceNodeStartMethodOffsetClamping","clampedOffset","isAudioWorkletNode","deleteEventListenerOfAudioNode","isPassiveAudioNode","pickElementFromSet","matchingElements","matchingElement","setInternalStateToPassiveWhenNecessary","testAudioNodeDisconnectMethodSupport","analyzer","dummy","ones","chnnlDt","sample","visitEachAudioNodeOnce","cycles","visitor","counts","cycle","addActiveInputConnectionToAudioNode","activeInputConnection","addActiveInputConnectionToAudioParam","addPassiveInputConnectionToAudioNode","passiveInputConnections","passiveInputConnection","addPassiveInputConnectionToAudioParam","deletePassiveInputConnectionToAudioNode","matchingConnection","deletePassiveInputConnectionToAudioParam","addConnectionToAudioNodeOfAudioContext","eventListeners","isActive","partialConnection","deleteActiveInputConnectionToAudioNode","addConnectionToAudioParamOfAudioContext","deleteActiveInputConnectionToAudioParam","deleteActiveInputConnection","activeInputConnections","deleteInputsOfAudioNode","deleteInputConnectionOfAudioNode","deleteInputsOfAudioParam","deleteInputConnectionOfAudioParam","createAudioNodeConstructor","addAudioNodeConnections","createIncrementCycleCounter","decrementCycleCounter","detectCycles","_context","_nativeAudioNode","returnValue","connectionsToDestination","filteredConnections","wrapAudioNodeDisconnectMethod","auxiliaryGainNodes","addConnectionToAudioNodeOfOfflineAudioContext","addConnectionToAudioParamOfOfflineAudioContext","destinations","audioNodeConnectionsOfSource","deleteAnyConnection","deleteConnectionAtOutput","deleteConnectionToDestination","createAudioWorkletProcessorPromise","audioWorkletNodeOptions","onmessageerror","cloneAudioWorkletNodeOptions","createNativeAudioWorkletNodeFakerFactory","sum","numberOfParameters","parameterDescriptors","messageChannel","gainNodes","inputChannelSplitterNodes","constantSourceNodes","inputChannelMergerNode","outputChannelSplitterNode","outputChannelMergerNodes","parameterMap","nativeAudioWorkletNodeFaker","_","patchedEventListeners","unpatchedEventListener","patchedEventListener","audioWorkletProcessor","nodeToProcessorMap","audioWorkletProcessorPromise","createAudioWorkletProcessor","dWrkltPrcssr","prmtrs","disconnectOutputsGraph","outputChannelSplitterNodeOutput","outputChannelMergerNode","potentiallyEmptyInputs","activeSourceFlag","process","ErrorEvent","disconnectFakeGraph","connectFakeGraph","handler","construct","IMPORT_STATEMENT_REGEX","splitImportStatements","importStatements","sourceWithoutImportStatements","replace","match","unresolvedUrl","importStatementWithResolvedUrl","toString","join","verifyParameterDescriptors","isArray","verifyProcessorCtor","processorCtor","constructible","Proxy","isConstructible","createAddAudioWorkletModule","evaluateSource","fetchSource","ongoingRequests","resolvedRequests","credentials","absoluteUrl","resolvedRequestsOfContext","ongoingRequestsOfContext","promiseOfOngoingRequest","evaluateAudioWorkletGlobalScope","_AWGS","trim","rslvdRqstsFCntxt","ngngRqstsFCntxt","testAnalyserNodeGetFloatTimeDomainDataMethodSupport","createNativeAnalyserNodeFactory","createAnalyser","byteTimeDomainData","Uint8Array","wrapAnalyserNodeGetFloatTimeDomainDataMethod","createNativeAudioBufferSourceNodeFactory","testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport","testAudioBufferSourceNodeStartMethodDurationParameterSupport","testAudioBufferSourceNodeStartMethodOffsetClampingSupport","testAudioBufferSourceNodeStopMethodNullifiedBufferSupport","wrapAudioBufferSourceNodeStartMethodOffsetClampling","wrapAudioBufferSourceNodeStopMethodNullifiedBuffer","isScheduled","wrapAudioBufferSourceNodeStartMethodConsecutiveCalls","stopTime","actualStartTime","durationInBufferTime","wrapAudioBufferSourceNodeStartMethodDurationParameter","processBuffer","processedBuffer","getAudioWorkletProcessor","createAudioWorkletNodeRendererFactory","processedBufferPromise","renderedNativeAudioWorkletNodeOrGainNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","renderBuffer","createDecodeAudioData","detachedArrayBuffers","anyContext","complete","detachArrayBuffer","fail","createDetectCycles","chain","nextLink","isDelayNode","mergedCycles","nestedCycles","concat","createIIRFilterNodeConstructor","wrapIIRFilterNodeGetFrequencyResponseMethod","_nativeIIRFilterNode","createNativeAudioWorkletNodeFactory","testClonabilityOfAudioWorkletNodeOptions","createNativeChannelSplitterNodeFactory","nativeChannelSplitterNode","createChannelSplitter","wrapChannelSplitterNode","arrayWithHoles","iterableToArrayLimit","unsupportedIterableToArray","nonIterableRest","arr","_arr","_n","_d","_e","_s","_i","next","done","arrayLikeToArray","minLen","constructor","len","arr2","Constructor","_defineProperties","props","writable","protoProps","staticProps","version","assert","statement","assertRange","gte","lte","Infinity","assertContextRunning","warn","defaultLogger","console","setLogger","logger","log","isUndef","arg","isDefined","isFunction","isNumber","isObject","isBoolean","isString","isNote","theWindow","hasAudioContext","__decorate","decorators","desc","arguments","Reflect","decorate","__awaiter","_arguments","P","generator","fulfilled","step","e","rejected","Ticker","updateInterval","_callback","_type","_updateInterval","_createClock","toFixed","blobUrl","worker","Worker","_worker","_timeout","_createTimeout","_createWorker","clearTimeout","terminate","interval","_disposeClock","isAudioParam","isOfflineAudioContext","isAudioContext","isAudioBuffer","noCopy","deepMerge","sources","shift","assign","optionsFromArguments","defaults","argsArray","objKey","opts","indexOf","defaultArg","given","fallback","omitFromObject","obj","omit","prop","debug","_wasDisposed","TONE_DEBUG_CLASS","GT","GTE","EQ","LT","abs","clamp","_timeline","getDefaults","memory","increasing","valueOf","lastValue","_search","diff","param","after","beginning","end","midPoint","nextEvent","lowerBound","upperBound","_iterate","dispose","notifyNewContext","onContextInit","cb","notifyCloseContext","onContextClose","split","eventName","_events","boundCallback","off","on","eventList","constr","_constants","_timeouts","_timeoutIds","_initialized","_workletModules","createAudioContext","_ticker","emit","clockSource","_timeoutLoop","_setLatencyHint","lookAhead","ctx","feedForward","initialize","_transport","_draw","createAudioWorkletNode","rawContext","promises","_latencyHint","hint","lookAheadValue","val","constant","now","firstEvent","peek","timeout","remove","intervalFn","readOnly","str","noOp","reverse","load","_buffer","getContext","loaded","_reversed","_reverse","doneLoading","downloads","isMultidimensional","channels","multiChannelArray","chanNum","fromArray","toArray","outputArray","numChannels","channelArray","ret","startSamples","endSamples","retBuffer","subarray","rev","matches","extensions","extension","ext","supportsType","baseUrl","endsWith","canPlayType","_currentTime","_duration","asynchronous","yieldEvery","workletsAreReady","_renderClock","dummyContext","_numberOfChannels","_sampleRate","_numberOfInputs","_numberOfOutputs","_maxDelayTime","_feedForward","_feedback","_real","_imag","_constraints","_stream","_audioData","_name","_options","_url","_fn","_id","_interval","_val","globalContext","setContext","TONE_SILENCE_LOGGING","prefix","printString","dbToGain","db","gainToDb","LN10","intervalToFrequencyRatio","A4","ftom","ftomf","mtof","midi","units","defaultUnits","_units","_expressions","_getExpressions","hz","method","_frequencyToUnits","parseFloat","regexp","_ticksToUnits","parseInt","_beatsToUnits","_getTimeSignature","dot","numericValue","scalar","number","_secondsToUnits","samples","tr","q","total","fromType","_noArg","typeName","quantity","expr","matching","freq","beats","_getBpm","seconds","ticks","_getPPQ","_now","transport","bpm","timeSignature","PPQ","toSeconds","toTicks","toFrequency","toMidi","capture","quantize","quantTo","nextSubdivision","subdiv","percent","subdivision","testNotations","power","closest","closestSeconds","notation","notationSeconds","quarterTime","quarters","measures","sixteenths","sixteenthString","Time","setA4","note","pitch","octave","noteNumber","noteToScaleIndex","toLowerCase","intervals","transpose","scaleIndexToNote","cbb","cx","dbb","dx","ebb","eb","ex","fbb","fb","f","fx","gbb","gb","g","gx","abb","ab","ax","bbb","bb","bx","Frequency","TransportTime","defaultContext","attribute","member","_getPartialProperties","initial","_initial","setStateAtTime","overridden","_minOutput","_param","_swappable","swappable","_initialValue","convert","_minValue","_maxValue","_toType","getValueAtTime","_fromType","_is","computedTime","isFinite","JSON","stringify","_assertRange","getAfter","before","beforeValue","previous","getBefore","_linearInterpolate","_exponentialInterpolate","previousVal","_exponentialApproach","currentVal","rampTime","setRampPoint","exponentialApproachValueAtTime","scaling","startingValue","segTime","cancel","valueAtTime","sampleTime","exponentialRampTo","linearRampTo","previousEvent","subdivisions","forEachAfter","t0","v0","v1","t1","_internalChannels","node","nodeList","_isAudioNode","_getInternalNodes","_getChannelProperties","_setChannelProperties","outputNum","inputNum","toDestination","nodes","connectSeries","first","prev","current","srcNode","dstNode","outputNumber","inputNumber","_gainNode","_stopTime","getStateAtTime","_fadeIn","fadeIn","_fadeOut","fadeOut","_curve","fadeInTime","_stopGain","cancelStop","fadeOutTime","targetRampTo","additionalTail","_stopSource","disposeCallback","requestIdleCallback","_source","_startGain","override","_constantSource","connectSignal","rampTo","signal","_multiplier","multiplier","computedValue","prevEvent","segments","rampVal","ticksUntilTime","_getTicksUntilEvent","computedVal","segmentDur","val0","val1","onTheLineEvent","currentTick","getTicksAtTime","getTimeOfTick","tick","delta","sol1","sol2","getDurationOfTicks","computedDuration","startTicks","ticksToTime","timeToTicks","_tickOffset","setTicksAtTime","stopEvent","getLastState","tmpEvent","lastState","elapsedTicks","forEachBetween","periodStartTime","offsetEvent","getSecondsAtTime","elapsedSeconds","absoluteTicks","lastStateEvent","forEachTickBetween","maxStartTime","nextTickTime","_lastUpdate","_boundLoop","_loop","_tickSource","pause","mixin","initialValue","Ticks","_root","IntervalNode","insert","updateHeight","updateMax","_rebalance","results","search","_removeNode","forEachFrom","replacement","isLeftChild","left","right","_setRoot","_replaceNodeInParent","temp","getBalance","pivotNode","balance","_rotateLeft","_rotateRight","low","allNodes","traverse","searchAfter","high","_left","_right","height","point","_eventId","_once","once","_currentId","_nextId","_nextTick","_boundRestart","_restart","_createEvents","invoke","scheduleOnce","_loopStart","_loopEnd","_scheduledEvents","_repeatedEvents","_syncedSignals","_swingAmount","_ppq","ppq","_clock","_processTick","_bindClockEvents","_timeSignature","_swingTicks","swing","swingSubdivision","tickTime","progress","amount","forEachAtTime","_addEvent","eventId","item","timeline","computedAfter","offsetTicks","timeSig","startPosition","endPosition","toNotation","toBarsBeatsSixteenths","remainingTicks","computedFreq","ratioSignal","syncedSignal","maxDelayInSeconds","maxDelay","_maxDelay","_delayNode","volume","_unmutedVolume","mute","Offline","originalContext","bufferPromise","_buffers","_loadingCount","urls","_bufferLoaded","Midi","expiration","anticipation","_boundDrawLoop","_drawLoop","_animationFrame","requestAnimationFrame","cancelAnimationFrame","draw","_synced","_scheduled","_syncedStart","_syncedStop","_volume","onstop","_clampToCurrentTime","sched","schedule","_start","immediate","restart","getNextState","_stop","stateEvent","startOffset","unsync","_sourceStarted","_sourceStopped","computedOffset","loopDuration","computedDur","_noiseBuffers","rate","random","_noiseCache","brown","pink","white","channelNum","lastOut","b0","b1","b2","b3","b4","b5","b6","labelOrId","supported","devices","enumerateDevices","_device","find","device","label","deviceId","audio","echoCancellation","noiseSuppression","mozNoiseSuppression","navigator","mediaDevices","getUserMedia","mediaStreamNode","_mediaStream","track","active","groupId","generateWaveform","_oscillator","_partials","partials","_partialCount","partialCount","baseType","phase","oscillator","_wave","syncSignal","unsyncSignal","_periodicWaveCache","description","_phase","arrayA","arrayB","oscProps","isBasicType","cache","_getCachedPeriodicWave","wave","_getRealImaginary","partial","exec","fullPartials","v","periodicWaveSize","piFactor","twoPi","_inverseFFT","_shaper","mapping","setMap","normalized","oversampling","_norm","_mult","factor","_modulationScale","_modulationNode","_carrier","_modulator","modulationType","harmonicity","modulationIndex","_widthGate","_thresh","width","_triangle","_oscillators","_spread","spread","_forEach","osc","sourceType","_scale","_pulse","modulationFrequency","carrierType","OmniOscillatorSourceMap","am","fat","fm","pulse","pwm","_sourceType","substr","_createNewOscillator","_getOscType","oscType","OscConstructor","oldOsc","blockTime","sType","mType","_sum","addend","_add","_min","_max","_setRange","getConstant","_stoppedValue","_clampValue","_amplitudeGain","amplitude","_stoppedSignal","_zeros","_a2g","_scaler","sync","syncFrequency","unsyncFrequency","getInitialValue","currentMin","currentMax","range","valueMap","propertyKey","newValue","timeRange","_activeSources","_onload","autostart","origDuration","_onSourceEnd","implicitEnd","_players","player","_tick","grainSize","_grainSize","_overlap","overlap","_onstop","_abs","_multiply","_neg","subtrahend","_subtract","_gtz","comparator","_exponentScaler","_expFunc","_exponent","exponent","_exp","_lastVal","scheduleRepeat","_onTick","_syncedCallback","_anchorValue","_sig","decay","sustain","attackCurve","releaseCurve","decayCurve","direction","curveName","EnvelopeCurves","curveDef","_getCurve","_attackCurve","_setCurve","_releaseCurve","_decayCurve","velocity","currentValue","decayValue","decayStart","triggerAttack","triggerRelease","attackPortion","envelopeDuration","sustainTime","totalDuration","clone","triggerAttackRelease","cosineCurve","rippleCurve","curveLen","sineWave","stairsCurve","sineCurve","bounceCurve","invertCurve","out","bounce","In","Out","cosine","exponential","linear","ripple","sine","_original_triggerAttack","_original_triggerRelease","_syncMethod","timePosition","originalMethod","portamento","onsilence","_triggerEnvelopeAttack","setNote","_triggerEnvelopeRelease","computedFrequency","getLevelAtTime","portTime","envelope","computedAttack","computedDecay","modulation","modulationEnvelope","fan","_filter","freqValues","magValues","phaseValues","filterClone","_filters","rolloff","_rolloff","rolloffNum","possibilities","cascadingCount","totalResponse","_octaves","octaves","_baseFrequency","baseFrequency","filterEnvelope","voice0","voice1","_vibrato","vibratoRate","_vibratoGain","vibratoAmount","inharmRatios","_freqMultipliers","_amplitude","_highpass","mult","_filterFreqScaler","resonance","freqMult","pitchDecay","hertz","maxNote","noise","workletContext","addToWorklet","classOrFunction","registerProcessor","classDesc","processor","workletOptions","_audioWorkletName","_dummyGain","_dummyParam","disposed","_worklet","onReady","setParam","_createFilter","oldFilter","a0","fq","_combFilter","_lowpass","dampening","_noise","attackNoise","_lfcf","delayAmount","_availableVoices","_activeVoices","_voices","_gcTimeout","_averageActiveVoices","voice","maxPolyphony","_dummyVoice","_getNextAvailableVoice","setInterval","_collectGarbage","activeVoiceIndex","_makeVoiceAvailable","activeVoices","firstAvail","notes","midiNote","released","_triggerAttack","_triggerRelease","_scheduleEvent","durationSeconds","clearInterval","urlMap","mid","midiFloat","remainder","difference","_findClosest","closestNote","_startOffset","_probability","probability","_humanize","humanize","_rescheduleEvents","startTick","_getLoopDuration","prob","variation","reschedulTime","lastEvent","_event","iterations","iters","events","_startNote","timeInTicks","at","_restartEvent","attr","_setAll","_testLoopBoundries","upPatternGen","clampToArraySize","downPatternGen","infiniteGen","gen","alternatingGenerator","directionUp","jumpUp","stepIndex","jumpDown","randomOnce","copy","PatternGenerator","pattern","randomIndex","randomGen","randomWalk","_values","_pattern","_part","_seqCallback","_eventsArray","_subdivision","_createSequence","_eventsUpdated","_indexTime","_rescheduleSequence","sequence","eventOffset","_panner","_split","_g2a","fade","_dryWet","wet","effectSend","effectReturn","effect","_lfo","depth","connectEffect","oct","smoothing","_smoothing","_follower","follower","_sweepRange","_inputBoost","_bandpass","_peaking","_setSweepRange","sensitivity","baseFreq","_bitCrusherWorklet","bits","_order","order","degree","memo","_getCoefficient","_splitter","_merger","_merge","_feedbackL","_feedbackR","_feedbackSplit","_feedbackMerge","_depth","_lfoL","_lfoR","_delayNodeL","_delayNodeR","connectEffectLeft","connectEffectRight","deviation","_distortion","distortion","deg","_feedbackGain","offset90","_bank0","_createAllPassFilterBank","_bank1","_oneSampleDelay","bankValues","coefficients","_sine","_cosine","_sineMultiply","_cosineMultiply","_negate","_phaseShifter","combFilterTunings","allpassFilterFrequencies","_combFilters","_allpassFiltersL","_allpassFiltersR","roomSize","allpassL","allpassR","lfpf","al","ar","cf","combFilterDelayTimes","combFilterResonances","allpassFilterFreqs","_allpassFilters","_feedbackCombFilters","_scaleRoomSize","allpass","fbcf","apf","_leftDelay","_rightDelay","_rightPreDelay","_delayA","_lfoA","_delayB","_lfoB","_crossFade","_crossFadeLFO","_feedbackDelay","_pitch","_windowSize","windowSize","_filtersL","_makeFilters","stages","_filtersR","connectToFreq","filters","_convolver","ready","_decay","_preDelay","preDelay","generate","previousReady","noiseL","noiseR","merge","renderPromise","_midAdd","SQRT1_2","_sideSubtract","side","_leftMult","_rightMult","_midSideMerge","_midSideSplit","_midSend","_sideSend","_midReturn","_sideReturn","_twoTimesWidthMid","_twoTimesWidthSide","_midMult","connectEffectMid","_oneMinusWidth","_sideMult","connectEffectSide","_amplitudeL","_amplitudeR","_analysers","analyser","_analyser","_rms","normalRange","aValues","vals","totalSquared","rms","_allSolos","solo","_isSoloed","_addSolo","_removeSolo","_updateSolo","_soloed","_noSolos","_solo","_panVol","muted","buses","bus","_getBus","sendKnob","_lowMidFilter","lowFrequency","highFrequency","_recorder","MediaRecorder","mimeType","startPromise","handleStart","dataPromise","handleData","_compressor","_gt","_gate","thresh","smoothingTime","_multibandSplit","_lowGain","_midGain","_highGain","buff","norm","getTransport","Master","getDestination","getListener","getDraw","Buffer","Buffers","BufferSource"],"mappings":"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","file":"Tone.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Tone\"] = factory();\n\telse\n\t\troot[\"Tone\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 684);\n","export const ACTIVE_AUDIO_NODE_STORE = new WeakSet();\nexport const AUDIO_NODE_CONNECTIONS_STORE = new WeakMap();\nexport const AUDIO_NODE_STORE = new WeakMap();\nexport const AUDIO_PARAM_CONNECTIONS_STORE = new WeakMap();\nexport const AUDIO_PARAM_STORE = new WeakMap();\nexport const BACKUP_NATIVE_CONTEXT_STORE = new WeakMap();\nexport const CONTEXT_STORE = new WeakMap();\nexport const EVENT_LISTENERS = new WeakMap();\nexport const CYCLE_COUNTERS = new WeakMap();\n// This clunky name is borrowed from the spec. :-)\nexport const NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = new WeakMap();\nexport const NODE_TO_PROCESSOR_MAPS = new WeakMap();\n//# sourceMappingURL=/build/es2019/globals.js.map","import { assignNativeAudioNodeOption } from './assign-native-audio-node-option';\nexport const assignNativeAudioNodeOptions = (nativeAudioNode, options) => {\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCount');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCountMode');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelInterpretation');\n};\n//# sourceMappingURL=/build/es2019/helpers/assign-native-audio-node-options.js.map","export const MOST_NEGATIVE_SINGLE_FLOAT = -3.4028234663852886e38;\nexport const MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;\n//# sourceMappingURL=/build/es2019/constants.js.map","export const isOwnedByContext = (nativeAudioNode, nativeContext) => {\n    return nativeAudioNode.context === nativeContext;\n};\n//# sourceMappingURL=/build/es2019/helpers/is-owned-by-context.js.map","export const assignNativeAudioNodeOption = (nativeAudioNode, options, option) => {\n    const value = options[option];\n    if (value !== undefined && value !== nativeAudioNode[option]) {\n        nativeAudioNode[option] = value;\n    }\n};\n//# sourceMappingURL=/build/es2019/helpers/assign-native-audio-node-option.js.map","export const assignNativeAudioNodeAudioParamValue = (nativeAudioNode, options, audioParam) => {\n    const value = options[audioParam];\n    if (value !== undefined && value !== nativeAudioNode[audioParam].value) {\n        nativeAudioNode[audioParam].value = value;\n    }\n};\n//# sourceMappingURL=/build/es2019/helpers/assign-native-audio-node-audio-param-value.js.map","import { AUDIO_NODE_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioNode = (audioNode) => {\n    return getValueForKey(AUDIO_NODE_STORE, audioNode);\n};\n//# sourceMappingURL=/build/es2019/helpers/get-native-audio-node.js.map","export const createInvalidStateError = () => {\n    try {\n        return new DOMException('', 'InvalidStateError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 11;\n        err.name = 'InvalidStateError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2019/factories/invalid-state-error.js.map","import { AUDIO_NODE_CONNECTIONS_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioNodeConnections = (audioNode) => {\n    return getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);\n};\n//# sourceMappingURL=/build/es2019/helpers/get-audio-node-connections.js.map","export const getValueForKey = (map, key) => {\n    const value = map.get(key);\n    if (value === undefined) {\n        throw new Error('A value with the given key could not be found.');\n    }\n    return value;\n};\n//# sourceMappingURL=/build/es2019/helpers/get-value-for-key.js.map","export const createNotSupportedError = () => {\n    try {\n        return new DOMException('', 'NotSupportedError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 9;\n        err.name = 'NotSupportedError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2019/factories/not-supported-error.js.map","export const interceptConnections = (original, interceptor) => {\n    original.connect = interceptor.connect.bind(interceptor);\n    original.disconnect = interceptor.disconnect.bind(interceptor);\n    return original;\n};\n//# sourceMappingURL=/build/es2019/helpers/intercept-connections.js.map","export const isNativeAudioNodeFaker = (nativeAudioNodeOrNativeAudioNodeFaker) => {\n    return 'inputs' in nativeAudioNodeOrNativeAudioNodeFaker;\n};\n//# sourceMappingURL=/build/es2019/guards/native-audio-node-faker.js.map","import { createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent } from 'automation-events';\nimport { createAbortError } from './factories/abort-error';\nimport { createAddAudioNodeConnections } from './factories/add-audio-node-connections';\nimport { createAddAudioParamConnections } from './factories/add-audio-param-connections';\nimport { createAddAudioWorkletModule } from './factories/add-audio-worklet-module';\nimport { createAddSilentConnection } from './factories/add-silent-connection';\nimport { createAddUnrenderedAudioWorkletNode } from './factories/add-unrendered-audio-worklet-node';\nimport { createAnalyserNodeConstructor } from './factories/analyser-node-constructor';\nimport { createAnalyserNodeRendererFactory } from './factories/analyser-node-renderer-factory';\nimport { createAudioBufferConstructor } from './factories/audio-buffer-constructor';\nimport { createAudioBufferSourceNodeConstructor } from './factories/audio-buffer-source-node-constructor';\nimport { createAudioBufferSourceNodeRendererFactory } from './factories/audio-buffer-source-node-renderer-factory';\nimport { createAudioContextConstructor } from './factories/audio-context-constructor';\nimport { createAudioDestinationNodeConstructor } from './factories/audio-destination-node-constructor';\nimport { createAudioDestinationNodeRenderer } from './factories/audio-destination-node-renderer-factory';\nimport { createAudioListenerFactory } from './factories/audio-listener-factory';\nimport { createAudioNodeConstructor } from './factories/audio-node-constructor';\nimport { createAudioParamFactory } from './factories/audio-param-factory';\nimport { createAudioParamRenderer } from './factories/audio-param-renderer';\nimport { createAudioWorkletNodeConstructor } from './factories/audio-worklet-node-constructor';\nimport { createAudioWorkletNodeRendererFactory } from './factories/audio-worklet-node-renderer-factory';\nimport { createBaseAudioContextConstructor } from './factories/base-audio-context-constructor';\nimport { createBiquadFilterNodeConstructor } from './factories/biquad-filter-node-constructor';\nimport { createBiquadFilterNodeRendererFactory } from './factories/biquad-filter-node-renderer-factory';\nimport { createCacheTestResult } from './factories/cache-test-result';\nimport { createChannelMergerNodeConstructor } from './factories/channel-merger-node-constructor';\nimport { createChannelMergerNodeRendererFactory } from './factories/channel-merger-node-renderer-factory';\nimport { createChannelSplitterNodeConstructor } from './factories/channel-splitter-node-constructor';\nimport { createChannelSplitterNodeRendererFactory } from './factories/channel-splitter-node-renderer-factory';\nimport { createConnectAudioParam } from './factories/connect-audio-param';\nimport { createConnectMultipleOutputs } from './factories/connect-multiple-outputs';\nimport { createConnectedNativeAudioBufferSourceNodeFactory } from './factories/connected-native-audio-buffer-source-node-factory';\nimport { createConstantSourceNodeConstructor } from './factories/constant-source-node-constructor';\nimport { createConstantSourceNodeRendererFactory } from './factories/constant-source-node-renderer-factory';\nimport { createConvertNumberToUnsignedLong } from './factories/convert-number-to-unsigned-long';\nimport { createConvolverNodeConstructor } from './factories/convolver-node-constructor';\nimport { createConvolverNodeRendererFactory } from './factories/convolver-node-renderer-factory';\nimport { createCreateNativeOfflineAudioContext } from './factories/create-native-offline-audio-context';\nimport { createDataCloneError } from './factories/data-clone-error';\nimport { createDecodeAudioData } from './factories/decode-audio-data';\nimport { createDecrementCycleCounter } from './factories/decrement-cycle-counter';\nimport { createDelayNodeConstructor } from './factories/delay-node-constructor';\nimport { createDelayNodeRendererFactory } from './factories/delay-node-renderer-factory';\nimport { createDeleteUnrenderedAudioWorkletNode } from './factories/delete-unrendered-audio-worklet-node';\nimport { createDetectCycles } from './factories/detect-cycles';\nimport { createDisconnectMultipleOutputs } from './factories/disconnect-multiple-outputs';\nimport { createDynamicsCompressorNodeConstructor } from './factories/dynamics-compressor-node-constructor';\nimport { createDynamicsCompressorNodeRendererFactory } from './factories/dynamics-compressor-node-renderer-factory';\nimport { createEncodingError } from './factories/encoding-error';\nimport { createEvaluateSource } from './factories/evaluate-source';\nimport { createEventTargetConstructor } from './factories/event-target-constructor';\nimport { createExposeCurrentFrameAndCurrentTime } from './factories/expose-current-frame-and-current-time';\nimport { createFetchSource } from './factories/fetch-source';\nimport { createGainNodeConstructor } from './factories/gain-node-constructor';\nimport { createGainNodeRendererFactory } from './factories/gain-node-renderer-factory';\nimport { createGetAudioNodeRenderer } from './factories/get-audio-node-renderer';\nimport { createGetAudioParamRenderer } from './factories/get-audio-param-renderer';\nimport { createGetBackupNativeContext } from './factories/get-backup-native-context';\nimport { createGetNativeContext } from './factories/get-native-context';\nimport { createGetUnrenderedAudioWorkletNodes } from './factories/get-unrendered-audio-worklet-nodes';\nimport { createIIRFilterNodeConstructor } from './factories/iir-filter-node-constructor';\nimport { createIIRFilterNodeRendererFactory } from './factories/iir-filter-node-renderer-factory';\nimport { createIncrementCycleCounterFactory } from './factories/increment-cycle-counter-factory';\nimport { createIndexSizeError } from './factories/index-size-error';\nimport { createInvalidAccessError } from './factories/invalid-access-error';\nimport { createInvalidStateError } from './factories/invalid-state-error';\nimport { createIsAnyAudioContext } from './factories/is-any-audio-context';\nimport { createIsAnyAudioNode } from './factories/is-any-audio-node';\nimport { createIsAnyAudioParam } from './factories/is-any-audio-param';\nimport { createIsAnyOfflineAudioContext } from './factories/is-any-offline-audio-context';\nimport { createIsNativeAudioContext } from './factories/is-native-audio-context';\nimport { createIsNativeAudioNode } from './factories/is-native-audio-node';\nimport { createIsNativeAudioParam } from './factories/is-native-audio-param';\nimport { createIsNativeContext } from './factories/is-native-context';\nimport { createIsNativeOfflineAudioContext } from './factories/is-native-offline-audio-context';\nimport { createIsSecureContext } from './factories/is-secure-context';\nimport { createIsSupportedPromise } from './factories/is-supported-promise';\nimport { createMediaElementAudioSourceNodeConstructor } from './factories/media-element-audio-source-node-constructor';\nimport { createMediaStreamAudioDestinationNodeConstructor } from './factories/media-stream-audio-destination-node-constructor';\nimport { createMediaStreamAudioSourceNodeConstructor } from './factories/media-stream-audio-source-node-constructor';\nimport { createMediaStreamTrackAudioSourceNodeConstructor } from './factories/media-stream-track-audio-source-node-constructor';\nimport { createMinimalAudioContextConstructor } from './factories/minimal-audio-context-constructor';\nimport { createMinimalBaseAudioContextConstructor } from './factories/minimal-base-audio-context-constructor';\nimport { createMinimalOfflineAudioContextConstructor } from './factories/minimal-offline-audio-context-constructor';\nimport { createMonitorConnections } from './factories/monitor-connections';\nimport { createNativeAnalyserNodeFactory } from './factories/native-analyser-node-factory';\nimport { createNativeAudioBufferConstructor } from './factories/native-audio-buffer-constructor';\nimport { createNativeAudioBufferSourceNodeFactory } from './factories/native-audio-buffer-source-node-factory';\nimport { createNativeAudioContextConstructor } from './factories/native-audio-context-constructor';\nimport { createNativeAudioDestinationNodeFactory } from './factories/native-audio-destination-node';\nimport { createNativeAudioNodeFactory } from './factories/native-audio-node-factory';\nimport { createNativeAudioWorkletNodeConstructor } from './factories/native-audio-worklet-node-constructor';\nimport { createNativeAudioWorkletNodeFactory } from './factories/native-audio-worklet-node-factory';\nimport { createNativeAudioWorkletNodeFakerFactory } from './factories/native-audio-worklet-node-faker-factory';\nimport { createNativeBiquadFilterNodeFactory } from './factories/native-biquad-filter-node-factory';\nimport { createNativeChannelMergerNodeFactory } from './factories/native-channel-merger-node-factory';\nimport { createNativeChannelSplitterNodeFactory } from './factories/native-channel-splitter-node-factory';\nimport { createNativeConstantSourceNodeFactory } from './factories/native-constant-source-node-factory';\nimport { createNativeConstantSourceNodeFakerFactory } from './factories/native-constant-source-node-faker-factory';\nimport { createNativeConvolverNodeFactory } from './factories/native-convolver-node-factory';\nimport { createNativeConvolverNodeFakerFactory } from './factories/native-convolver-node-faker-factory';\nimport { createNativeDelayNodeFactory } from './factories/native-delay-node-factory';\nimport { createNativeDynamicsCompressorNodeFactory } from './factories/native-dynamics-compressor-node-factory';\nimport { createNativeGainNodeFactory } from './factories/native-gain-node-factory';\nimport { createNativeIIRFilterNodeFactory } from './factories/native-iir-filter-node-factory';\nimport { createNativeIIRFilterNodeFakerFactory } from './factories/native-iir-filter-node-faker-factory';\nimport { createNativeMediaElementAudioSourceNodeFactory } from './factories/native-media-element-audio-source-node-factory';\nimport { createNativeMediaStreamAudioDestinationNodeFactory } from './factories/native-media-stream-audio-destination-node-factory';\nimport { createNativeMediaStreamAudioSourceNodeFactory } from './factories/native-media-stream-audio-source-node-factory';\nimport { createNativeMediaStreamTrackAudioSourceNodeFactory } from './factories/native-media-stream-track-audio-source-node-factory';\nimport { createNativeOfflineAudioContextConstructor } from './factories/native-offline-audio-context-constructor';\nimport { createNativeOscillatorNodeFactory } from './factories/native-oscillator-node-factory';\nimport { createNativePannerNodeFactory } from './factories/native-panner-node-factory';\nimport { createNativePannerNodeFakerFactory } from './factories/native-panner-node-faker-factory';\nimport { createNativePeriodicWaveFactory } from './factories/native-periodic-wave-factory';\nimport { createNativeScriptProcessorNodeFactory } from './factories/native-script-processor-node-factory';\nimport { createNativeStereoPannerNodeFactory } from './factories/native-stereo-panner-node-factory';\nimport { createNativeStereoPannerNodeFakerFactory } from './factories/native-stereo-panner-node-faker-factory';\nimport { createNativeWaveShaperNodeFactory } from './factories/native-wave-shaper-node-factory';\nimport { createNativeWaveShaperNodeFakerFactory } from './factories/native-wave-shaper-node-faker-factory';\nimport { createNotSupportedError } from './factories/not-supported-error';\nimport { createOfflineAudioContextConstructor } from './factories/offline-audio-context-constructor';\nimport { createOscillatorNodeConstructor } from './factories/oscillator-node-constructor';\nimport { createOscillatorNodeRendererFactory } from './factories/oscillator-node-renderer-factory';\nimport { createPannerNodeConstructor } from './factories/panner-node-constructor';\nimport { createPannerNodeRendererFactory } from './factories/panner-node-renderer-factory';\nimport { createPeriodicWaveConstructor } from './factories/periodic-wave-constructor';\nimport { createRenderAutomation } from './factories/render-automation';\nimport { createRenderInputsOfAudioNode } from './factories/render-inputs-of-audio-node';\nimport { createRenderInputsOfAudioParam } from './factories/render-inputs-of-audio-param';\nimport { createRenderNativeOfflineAudioContext } from './factories/render-native-offline-audio-context';\nimport { createStartRendering } from './factories/start-rendering';\nimport { createStereoPannerNodeConstructor } from './factories/stereo-panner-node-constructor';\nimport { createStereoPannerNodeRendererFactory } from './factories/stereo-panner-node-renderer-factory';\nimport { createTestAudioBufferConstructorSupport } from './factories/test-audio-buffer-constructor-support';\nimport { createTestAudioBufferCopyChannelMethodsSubarraySupport } from './factories/test-audio-buffer-copy-channel-methods-subarray-support';\nimport { createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport } from './factories/test-audio-buffer-source-node-start-method-consecutive-calls-support';\nimport { createTestAudioBufferSourceNodeStartMethodDurationParameterSupport } from './factories/test-audio-buffer-source-node-start-method-duration-parameter-support';\nimport { createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport } from './factories/test-audio-buffer-source-node-start-method-offset-clamping-support';\nimport { createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport } from './factories/test-audio-buffer-source-node-stop-method-nullified-buffer-support';\nimport { createTestAudioContextCloseMethodSupport } from './factories/test-audio-context-close-method-support';\nimport { createTestAudioContextDecodeAudioDataMethodTypeErrorSupport } from './factories/test-audio-context-decode-audio-data-method-type-error-support';\nimport { createTestAudioContextOptionsSupport } from './factories/test-audio-context-options-support';\nimport { createTestAudioNodeConnectMethodSupport } from './factories/test-audio-node-connect-method-support';\nimport { createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport } from './factories/test-audio-scheduled-source-node-start-method-negative-parameters-support';\nimport { createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport } from './factories/test-audio-scheduled-source-node-stop-method-consecutive-calls-support';\nimport { createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport } from './factories/test-audio-scheduled-source-node-stop-method-negative-parameters-support';\nimport { createTestAudioWorkletProcessorNoOutputsSupport } from './factories/test-audio-worklet-processor-no-outputs-support';\nimport { createTestChannelMergerNodeChannelCountSupport } from './factories/test-channel-merger-node-channel-count-support';\nimport { createTestConstantSourceNodeAccurateSchedulingSupport } from './factories/test-constant-source-node-accurate-scheduling-support';\nimport { createTestConvolverNodeBufferReassignabilitySupport } from './factories/test-convolver-node-buffer-reassignability-support';\nimport { createTestIsSecureContextSupport } from './factories/test-is-secure-context-support';\nimport { createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport } from './factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support';\nimport { createTestOfflineAudioContextCurrentTimeSupport } from './factories/test-offline-audio-context-current-time-support';\nimport { createTestStereoPannerNodeDefaultValueSupport } from './factories/test-stereo-panner-node-default-value-support';\nimport { createUnknownError } from './factories/unknown-error';\nimport { createWaveShaperNodeConstructor } from './factories/wave-shaper-node-constructor';\nimport { createWaveShaperNodeRendererFactory } from './factories/wave-shaper-node-renderer-factory';\nimport { createWindow } from './factories/window';\nimport { createWrapAudioBufferCopyChannelMethods } from './factories/wrap-audio-buffer-copy-channel-methods';\nimport { createWrapAudioBufferCopyChannelMethodsOutOfBounds } from './factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds';\nimport { createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer } from './factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer';\nimport { createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls } from './factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls';\nimport { createWrapChannelMergerNode } from './factories/wrap-channel-merger-node';\nimport { AUDIO_NODE_CONNECTIONS_STORE, AUDIO_NODE_STORE, AUDIO_PARAM_CONNECTIONS_STORE, AUDIO_PARAM_STORE, CONTEXT_STORE, CYCLE_COUNTERS } from './globals';\nimport { connectNativeAudioNodeToNativeAudioNode } from './helpers/connect-native-audio-node-to-native-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from './helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from './helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from './helpers/get-audio-param-connections';\nimport { getNativeAudioNode } from './helpers/get-native-audio-node';\nimport { getNativeAudioParam } from './helpers/get-native-audio-param';\nimport { getValueForKey } from './helpers/get-value-for-key';\nimport { insertElementInSet } from './helpers/insert-element-in-set';\nimport { isActiveAudioNode } from './helpers/is-active-audio-node';\nimport { isDCCurve } from './helpers/is-dc-curve';\nimport { isPartOfACycle } from './helpers/is-part-of-a-cycle';\nimport { overwriteAccessors } from './helpers/overwrite-accessors';\nimport { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from './helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { testPromiseSupport } from './helpers/test-promise-support';\nimport { testTransferablesSupport } from './helpers/test-transferables-support';\nimport { wrapAudioBufferSourceNodeStartMethodOffsetClamping } from './helpers/wrap-audio-buffer-source-node-start-method-offset-clamping';\nimport { wrapEventListener } from './helpers/wrap-event-listener';\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\nconst cacheTestResult = createCacheTestResult(new Map(), new WeakMap());\nconst window = createWindow();\nconst nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window);\nconst isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);\nconst nativeAudioContextConstructor = createNativeAudioContextConstructor(window);\nconst getBackupNativeContext = createGetBackupNativeContext(isNativeOfflineAudioContext, nativeAudioContextConstructor, nativeOfflineAudioContextConstructor);\nconst createNativeAudioNode = createNativeAudioNodeFactory(getBackupNativeContext);\nconst createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError, createNativeAudioNode);\nconst getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);\nconst renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);\nconst createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst auxiliaryGainNodeStore = new WeakMap();\nconst getNativeContext = createGetNativeContext(CONTEXT_STORE);\nconst audioParamAudioNodeStore = new WeakMap();\nconst eventTargetConstructor = createEventTargetConstructor(wrapEventListener);\nconst isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);\nconst isNativeAudioNode = createIsNativeAudioNode(window);\nconst isNativeAudioParam = createIsNativeAudioParam(window);\nconst audioNodeConstructor = createAudioNodeConstructor(createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE), auxiliaryGainNodeStore, cacheTestResult, createIncrementCycleCounterFactory(CYCLE_COUNTERS, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode), createIndexSizeError, createInvalidAccessError, createNotSupportedError, createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, CYCLE_COUNTERS, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext), createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey), eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext);\nconst analyserNodeConstructor = createAnalyserNodeConstructor(audioNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext);\nexport { analyserNodeConstructor as AnalyserNode };\nconst audioBufferStore = new WeakSet();\nconst nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window);\nconst convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));\nconst wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);\nconst wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);\nconst audioBufferConstructor = createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nexport { audioBufferConstructor as AudioBuffer };\nconst createNativeGainNode = createNativeGainNodeFactory(createNativeAudioNode);\nconst addSilentConnection = createAddSilentConnection(createNativeGainNode);\nconst testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport(createNativeAudioNode);\nconst testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(createNativeAudioNode);\nconst testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport(createNativeAudioNode);\nconst wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(createNativeAudioNode);\nconst renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);\nconst connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);\nconst createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeAudioNode, createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(createNativeAudioNode), createTestAudioBufferSourceNodeStartMethodDurationParameterSupport(nativeOfflineAudioContextConstructor), createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport(createNativeAudioNode), createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport(createNativeAudioNode), testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClamping, createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors), wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);\nconst createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst createAudioParam = createAudioParamFactory(createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE), audioParamAudioNodeStore, AUDIO_PARAM_STORE, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor);\nconst audioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nexport { audioBufferSourceNodeConstructor as AudioBufferSourceNode };\nconst audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors), getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode);\nconst createNativeBiquadFilterNode = createNativeBiquadFilterNodeFactory(createNativeAudioNode);\nconst createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst biquadFilterNodeConstructor = createBiquadFilterNodeConstructor(audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext);\nconst monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode);\nconst wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, createNativeAudioNode, monitorConnections);\nconst createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(createNativeAudioNode, wrapChannelMergerNode);\nconst createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst channelMergerNodeConstructor = createChannelMergerNodeConstructor(audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeChannelSplitterNode = createNativeChannelSplitterNodeFactory(createNativeAudioNode);\nconst createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst channelSplitterNodeConstructor = createChannelSplitterNodeConstructor(audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections);\nconst createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeAudioNode, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);\nconst createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst constantSourceNodeConstructor = createConstantSourceNodeConstructor(audioNodeConstructor, createAudioParam, createConstantSourceNodeRenderer, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nconst createNativeConvolverNodeFaker = createNativeConvolverNodeFakerFactory(createNativeAudioNode, createNativeGainNode, monitorConnections);\nconst createNativeConvolverNode = createNativeConvolverNodeFactory(createNativeAudioNode, createNativeConvolverNodeFaker, createNotSupportedError, overwriteAccessors);\nconst createConvolverNodeRenderer = createConvolverNodeRendererFactory(createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst convolverNodeConstructor = createConvolverNodeConstructor(audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeDelayNode = createNativeDelayNodeFactory(createNativeAudioNode);\nconst createDelayNodeRenderer = createDelayNodeRendererFactory(connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst delayNodeConstructor = createDelayNodeConstructor(audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNativeAudioNode, createNotSupportedError);\nconst createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst dynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext);\nconst createGainNodeRenderer = createGainNodeRendererFactory(connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst gainNodeConstructor = createGainNodeConstructor(audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeScriptProcessorNode = createNativeScriptProcessorNodeFactory(createNativeAudioNode);\nconst createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError);\nconst renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor));\nconst createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, createNativeAudioNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\nconst createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeAudioNode, createNativeIIRFilterNodeFaker);\nconst iIRFilterNodeConstructor = createIIRFilterNodeConstructor(audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\nconst createAudioListener = createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, isNativeOfflineAudioContext);\nconst unrenderedAudioWorkletNodeStore = new WeakMap();\nconst minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener);\nconst createNativeOscillatorNode = createNativeOscillatorNodeFactory(addSilentConnection, cacheTestResult, createNativeAudioNode, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst oscillatorNodeConstructor = createOscillatorNodeConstructor(audioNodeConstructor, createAudioParam, createInvalidStateError, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nconst createConnectedNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode);\nconst createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeGainNode, isDCCurve, monitorConnections);\nconst createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, overwriteAccessors);\nconst createNativePannerNodeFaker = createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeAudioNode, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, monitorConnections);\nconst createNativePannerNode = createNativePannerNodeFactory(createNativeAudioNode, createNativePannerNodeFaker);\nconst createPannerNodeRenderer = createPannerNodeRendererFactory(connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\nconst pannerNodeConstructor = createPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\nconst createNativePeriodicWave = createNativePeriodicWaveFactory(getBackupNativeContext);\nconst periodicWaveConstructor = createPeriodicWaveConstructor(createNativePeriodicWave, getNativeContext, new WeakSet());\nconst nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections);\nconst createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(createNativeAudioNode, nativeStereoPannerNodeFakerFactory, createNotSupportedError);\nconst createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst stereoPannerNodeConstructor = createStereoPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\nconst createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst waveShaperNodeConstructor = createWaveShaperNodeConstructor(audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\nconst isSecureContext = createIsSecureContext(window);\nconst exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window);\n// The addAudioWorkletModule() function is only available in a SecureContext.\nexport const addAudioWorkletModule = (isSecureContext) ?\n    createAddAudioWorkletModule(createNotSupportedError, createEvaluateSource(window), exposeCurrentFrameAndCurrentTime, createFetchSource(createAbortError), getBackupNativeContext, getNativeContext, new WeakMap(), new WeakMap(), \n    // @todo window is guaranteed to be defined because isSecureContext checks that as well.\n    window) :\n    undefined;\nconst isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);\nexport const decodeAudioData = createDecodeAudioData(audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, new WeakSet(), getNativeContext, isNativeContext, isNativeOfflineAudioContext, nativeOfflineAudioContextConstructor, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nconst baseAudioContextConstructor = createBaseAudioContextConstructor(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor);\nconst createNativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNodeFactory(createNativeAudioNode);\nconst mediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNodeFactory(createNativeAudioNode, createNotSupportedError);\nconst mediaStreamAudioDestinationNodeConstructor = createMediaStreamAudioDestinationNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNodeFactory(createNativeAudioNode);\nconst mediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError, createNativeAudioNode, isNativeOfflineAudioContext);\nconst mediaStreamTrackAudioSourceNodeConstructor = createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);\nconst audioContextConstructor = createAudioContextConstructor(baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor);\nexport { audioContextConstructor as AudioContext };\nconst getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);\nconst addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);\nconst deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);\nconst createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(auxiliaryGainNodeStore, connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, monitorConnections);\nconst createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioNode, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections);\nconst nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window);\nconst createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\n// The AudioWorkletNode constructor is only available in a SecureContext.\nconst audioWorkletNodeConstructor = (isSecureContext) ?\n    createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, wrapEventListener) :\n    undefined;\nexport { audioWorkletNodeConstructor as AudioWorkletNode };\nexport { biquadFilterNodeConstructor as BiquadFilterNode };\nexport { channelMergerNodeConstructor as ChannelMergerNode };\nexport { channelSplitterNodeConstructor as ChannelSplitterNode };\nexport { convolverNodeConstructor as ConvolverNode };\nexport { constantSourceNodeConstructor as ConstantSourceNode };\nexport { delayNodeConstructor as DelayNode };\nexport { dynamicsCompressorNodeConstructor as DynamicsCompressorNode };\nexport { gainNodeConstructor as GainNode };\nexport { iIRFilterNodeConstructor as IIRFilterNode };\nexport { mediaElementAudioSourceNodeConstructor as MediaElementAudioSourceNode };\nexport { mediaStreamAudioDestinationNodeConstructor as MediaStreamAudioDestinationNode };\nexport { mediaStreamAudioSourceNodeConstructor as MediaStreamAudioSourceNode };\nexport { mediaStreamTrackAudioSourceNodeConstructor as MediaStreamTrackAudioSourceNode };\nconst minimalAudioContextConstructor = createMinimalAudioContextConstructor(createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor);\nexport { minimalAudioContextConstructor as MinimalAudioContext };\nconst createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(createNotSupportedError, nativeOfflineAudioContextConstructor);\nconst startRendering = createStartRendering(audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nconst minimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering);\nexport { minimalOfflineAudioContextConstructor as MinimalOfflineAudioContext };\nconst offlineAudioContextConstructor = createOfflineAudioContextConstructor(baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering);\nexport { offlineAudioContextConstructor as OfflineAudioContext };\nexport { oscillatorNodeConstructor as OscillatorNode };\nexport { pannerNodeConstructor as PannerNode };\nexport { periodicWaveConstructor as PeriodicWave };\nexport { stereoPannerNodeConstructor as StereoPannerNode };\nexport { waveShaperNodeConstructor as WaveShaperNode };\nexport const isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);\nexport const isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode);\nexport const isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);\nexport const isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);\nexport const isSupported = () => createIsSupportedPromise(cacheTestResult, createTestAudioBufferCopyChannelMethodsSubarraySupport(nativeOfflineAudioContextConstructor), createTestAudioContextCloseMethodSupport(nativeAudioContextConstructor), createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(nativeOfflineAudioContextConstructor), createTestAudioContextOptionsSupport(nativeAudioContextConstructor), createTestAudioNodeConnectMethodSupport(nativeOfflineAudioContextConstructor), createTestAudioWorkletProcessorNoOutputsSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), createTestChannelMergerNodeChannelCountSupport(createNativeAudioNode, nativeOfflineAudioContextConstructor), createTestConstantSourceNodeAccurateSchedulingSupport(createNativeAudioNode, nativeOfflineAudioContextConstructor), createTestConvolverNodeBufferReassignabilitySupport(nativeOfflineAudioContextConstructor), createTestIsSecureContextSupport(window), createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport(nativeAudioContextConstructor), createTestStereoPannerNodeDefaultValueSupport(nativeOfflineAudioContextConstructor), testTransferablesSupport);\n//# sourceMappingURL=/build/es2019/module.js.map","export const testPromiseSupport = (nativeContext) => {\n    // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.\n    const uint32Array = new Uint32Array([\n        1179011410,\n        40,\n        1163280727,\n        544501094,\n        16,\n        131073,\n        44100,\n        176400,\n        1048580,\n        1635017060,\n        4,\n        0\n    ]);\n    try {\n        // Bug #1: Safari requires a successCallback.\n        const promise = nativeContext.decodeAudioData(uint32Array.buffer, () => {\n            // Ignore the success callback.\n        });\n        if (promise === undefined) {\n            return false;\n        }\n        promise.catch(() => {\n            // Ignore rejected errors.\n        });\n        return true;\n    }\n    catch {\n        // Ignore errors.\n    }\n    return false;\n};\n//# sourceMappingURL=/build/es2019/helpers/test-promise-support.js.map","export const createIndexSizeError = () => {\n    try {\n        return new DOMException('', 'IndexSizeError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 1;\n        err.name = 'IndexSizeError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2019/factories/index-size-error.js.map","export const insertElementInSet = (set, element, predicate, ignoreDuplicates) => {\n    for (const lmnt of set) {\n        if (predicate(lmnt)) {\n            if (ignoreDuplicates) {\n                return false;\n            }\n            throw Error('The set contains at least one similar element.');\n        }\n    }\n    set.add(element);\n    return true;\n};\n//# sourceMappingURL=/build/es2019/helpers/insert-element-in-set.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const setInternalStateToActive = (audioNode) => {\n    if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is already stored.');\n    }\n    ACTIVE_AUDIO_NODE_STORE.add(audioNode);\n    getEventListenersOfAudioNode(audioNode)\n        .forEach((eventListener) => eventListener(true));\n};\n//# sourceMappingURL=/build/es2019/helpers/set-internal-state-to-active.js.map","(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass'], factory) :\n    (global = global || self, factory(global.automationEvents = {}, global._slicedToArray, global._classCallCheck, global._createClass));\n}(this, (function (exports, _slicedToArray, _classCallCheck, _createClass) { 'use strict';\n\n    _slicedToArray = _slicedToArray && Object.prototype.hasOwnProperty.call(_slicedToArray, 'default') ? _slicedToArray['default'] : _slicedToArray;\n    _classCallCheck = _classCallCheck && Object.prototype.hasOwnProperty.call(_classCallCheck, 'default') ? _classCallCheck['default'] : _classCallCheck;\n    _createClass = _createClass && Object.prototype.hasOwnProperty.call(_createClass, 'default') ? _createClass['default'] : _createClass;\n\n    var createExtendedExponentialRampToValueAutomationEvent = function createExtendedExponentialRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createExtendedLinearRampToValueAutomationEvent = function createExtendedLinearRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetValueAutomationEvent = function createSetValueAutomationEvent(value, startTime) {\n      return {\n        startTime: startTime,\n        type: 'setValue',\n        value: value\n      };\n    };\n\n    var createSetValueCurveAutomationEvent = function createSetValueCurveAutomationEvent(values, startTime, duration) {\n      return {\n        duration: duration,\n        startTime: startTime,\n        type: 'setValueCurve',\n        values: values\n      };\n    };\n\n    var getTargetValueAtTime = function getTargetValueAtTime(time, valueAtStartTime, _ref) {\n      var startTime = _ref.startTime,\n          target = _ref.target,\n          timeConstant = _ref.timeConstant;\n      return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);\n    };\n\n    var isExponentialRampToValueAutomationEvent = function isExponentialRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'exponentialRampToValue';\n    };\n\n    var isLinearRampToValueAutomationEvent = function isLinearRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'linearRampToValue';\n    };\n\n    var isAnyRampToValueAutomationEvent = function isAnyRampToValueAutomationEvent(automationEvent) {\n      return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);\n    };\n\n    var isSetValueAutomationEvent = function isSetValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValue';\n    };\n\n    var isSetValueCurveAutomationEvent = function isSetValueCurveAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValueCurve';\n    };\n\n    var getValueOfAutomationEventAtIndexAtTime = function getValueOfAutomationEventAtIndexAtTime(automationEvents, index, time, defaultValue) {\n      var automationEvent = automationEvents[index];\n      return automationEvent === undefined ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);\n    };\n\n    var getEndTimeAndValueOfPreviousAutomationEvent = function getEndTimeAndValueOfPreviousAutomationEvent(automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) {\n      return currentAutomationEvent === undefined ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime + currentAutomationEvent.duration, currentAutomationEvent.values[currentAutomationEvent.values.length - 1]] : [currentAutomationEvent.startTime, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)];\n    };\n\n    var isCancelAndHoldAutomationEvent = function isCancelAndHoldAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelAndHold';\n    };\n\n    var isCancelScheduledValuesAutomationEvent = function isCancelScheduledValuesAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelScheduledValues';\n    };\n\n    var getEventTime = function getEventTime(automationEvent) {\n      if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n        return automationEvent.cancelTime;\n      }\n\n      if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {\n        return automationEvent.endTime;\n      }\n\n      return automationEvent.startTime;\n    };\n\n    var getExponentialRampValueAtTime = function getExponentialRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n          value = _ref.value;\n\n      if (valueAtStartTime === value) {\n        return value;\n      }\n\n      if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {\n        return valueAtStartTime * Math.pow(value / valueAtStartTime, (time - startTime) / (endTime - startTime));\n      }\n\n      return 0;\n    };\n\n    var getLinearRampValueAtTime = function getLinearRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n          value = _ref.value;\n      return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);\n    };\n\n    var interpolateValue = function interpolateValue(values, theoreticIndex) {\n      var lowerIndex = Math.floor(theoreticIndex);\n      var upperIndex = Math.ceil(theoreticIndex);\n\n      if (lowerIndex === upperIndex) {\n        return values[lowerIndex];\n      }\n\n      return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n    };\n\n    var getValueCurveValueAtTime = function getValueCurveValueAtTime(time, _ref) {\n      var duration = _ref.duration,\n          startTime = _ref.startTime,\n          values = _ref.values;\n      var theoreticIndex = (time - startTime) / duration * (values.length - 1);\n      return interpolateValue(values, theoreticIndex);\n    };\n\n    var isSetTargetAutomationEvent = function isSetTargetAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setTarget';\n    };\n\n    var AutomationEventList = /*#__PURE__*/function () {\n      function AutomationEventList(defaultValue) {\n        _classCallCheck(this, AutomationEventList);\n\n        this._automationEvents = [];\n        this._currenTime = 0;\n        this._defaultValue = defaultValue;\n      }\n\n      _createClass(AutomationEventList, [{\n        key: Symbol.iterator,\n        value: function value() {\n          return this._automationEvents[Symbol.iterator]();\n        }\n      }, {\n        key: \"add\",\n        value: function add(automationEvent) {\n          var eventTime = getEventTime(automationEvent);\n\n          if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n            var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              return getEventTime(currentAutomationEvent) >= eventTime;\n            });\n\n            var removedAutomationEvent = this._automationEvents[index];\n\n            if (index !== -1) {\n              this._automationEvents = this._automationEvents.slice(0, index);\n            }\n\n            if (isCancelAndHoldAutomationEvent(automationEvent)) {\n              var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n\n              if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n                if (isSetTargetAutomationEvent(lastAutomationEvent)) {\n                  throw new Error('The internal list is malformed.');\n                }\n\n                var startTime = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);\n                var startValue = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;\n                var value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n                var truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n\n                this._automationEvents.push(truncatedAutomationEvent);\n              }\n\n              if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n              }\n\n              if (lastAutomationEvent !== undefined && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {\n                this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(new Float32Array([6, 7]), lastAutomationEvent.startTime, eventTime - lastAutomationEvent.startTime);\n              }\n            }\n          } else {\n            var _index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              return getEventTime(currentAutomationEvent) > eventTime;\n            });\n\n            var previousAutomationEvent = _index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[_index - 1];\n\n            if (previousAutomationEvent !== undefined && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {\n              return false;\n            }\n\n            var persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;\n\n            if (_index === -1) {\n              this._automationEvents.push(persistentAutomationEvent);\n            } else {\n              if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[_index])) {\n                return false;\n              }\n\n              this._automationEvents.splice(_index, 0, persistentAutomationEvent);\n            }\n          }\n\n          return true;\n        }\n      }, {\n        key: \"flush\",\n        value: function flush(time) {\n          var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n            return getEventTime(currentAutomationEvent) > time;\n          });\n\n          if (index > 1) {\n            var remainingAutomationEvents = this._automationEvents.slice(index - 1);\n\n            var firstRemainingAutomationEvent = remainingAutomationEvents[0];\n\n            if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n              remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));\n            }\n\n            this._automationEvents = remainingAutomationEvents;\n          }\n        }\n      }, {\n        key: \"getValue\",\n        value: function getValue(time) {\n          if (this._automationEvents.length === 0) {\n            return this._defaultValue;\n          }\n\n          var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n\n          var index = this._automationEvents.findIndex(function (automationEvent) {\n            return getEventTime(automationEvent) > time;\n          });\n\n          var nextAutomationEvent = this._automationEvents[index];\n          var currentAutomationEvent = getEventTime(lastAutomationEvent) <= time ? lastAutomationEvent : this._automationEvents[index - 1];\n\n          if (currentAutomationEvent !== undefined && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {\n            return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);\n          }\n\n          if (currentAutomationEvent !== undefined && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n\n          if (currentAutomationEvent !== undefined && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {\n            if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n              return getValueCurveValueAtTime(time, currentAutomationEvent);\n            }\n\n            return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n          }\n\n          if (currentAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n\n          if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, index - 1, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n                _getEndTimeAndValueOf2 = _slicedToArray(_getEndTimeAndValueOf, 2),\n                startTime = _getEndTimeAndValueOf2[0],\n                value = _getEndTimeAndValueOf2[1];\n\n            return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n          }\n\n          if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf3 = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, index - 1, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n                _getEndTimeAndValueOf4 = _slicedToArray(_getEndTimeAndValueOf3, 2),\n                _startTime = _getEndTimeAndValueOf4[0],\n                _value = _getEndTimeAndValueOf4[1];\n\n            return getLinearRampValueAtTime(time, _startTime, _value, nextAutomationEvent);\n          }\n\n          return this._defaultValue;\n        }\n      }]);\n\n      return AutomationEventList;\n    }();\n\n    var createCancelAndHoldAutomationEvent = function createCancelAndHoldAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelAndHold'\n      };\n    };\n\n    var createCancelScheduledValuesAutomationEvent = function createCancelScheduledValuesAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelScheduledValues'\n      };\n    };\n\n    var createExponentialRampToValueAutomationEvent = function createExponentialRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createLinearRampToValueAutomationEvent = function createLinearRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetTargetAutomationEvent = function createSetTargetAutomationEvent(target, startTime, timeConstant) {\n      return {\n        startTime: startTime,\n        target: target,\n        timeConstant: timeConstant,\n        type: 'setTarget'\n      };\n    };\n\n    exports.AutomationEventList = AutomationEventList;\n    exports.createCancelAndHoldAutomationEvent = createCancelAndHoldAutomationEvent;\n    exports.createCancelScheduledValuesAutomationEvent = createCancelScheduledValuesAutomationEvent;\n    exports.createExponentialRampToValueAutomationEvent = createExponentialRampToValueAutomationEvent;\n    exports.createLinearRampToValueAutomationEvent = createLinearRampToValueAutomationEvent;\n    exports.createSetTargetAutomationEvent = createSetTargetAutomationEvent;\n    exports.createSetValueAutomationEvent = createSetValueAutomationEvent;\n    exports.createSetValueCurveAutomationEvent = createSetValueCurveAutomationEvent;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","import { CYCLE_COUNTERS } from '../globals';\nexport const isPartOfACycle = (audioNode) => {\n    return CYCLE_COUNTERS.has(audioNode);\n};\n//# sourceMappingURL=/build/es2019/helpers/is-part-of-a-cycle.js.map","import { EVENT_LISTENERS } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getEventListenersOfAudioNode = (audioNode) => {\n    return getValueForKey(EVENT_LISTENERS, audioNode);\n};\n//# sourceMappingURL=/build/es2019/helpers/get-event-listeners-of-audio-node.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const setInternalStateToPassive = (audioNode) => {\n    if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is not stored.');\n    }\n    ACTIVE_AUDIO_NODE_STORE.delete(audioNode);\n    getEventListenersOfAudioNode(audioNode)\n        .forEach((eventListener) => eventListener(false));\n};\n//# sourceMappingURL=/build/es2019/helpers/set-internal-state-to-passive.js.map","import { isAudioNode } from './audio-node';\nexport const isAudioNodeOutputConnection = (outputConnection) => {\n    return isAudioNode(outputConnection[0]);\n};\n//# sourceMappingURL=/build/es2019/guards/audio-node-output-connection.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isActiveAudioNode = (audioNode) => ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n//# sourceMappingURL=/build/es2019/helpers/is-active-audio-node.js.map","export const isAudioNode = (audioNodeOrAudioParam) => {\n    return 'context' in audioNodeOrAudioParam;\n};\n//# sourceMappingURL=/build/es2019/guards/audio-node.js.map","export const isNativeAudioNode = (nativeAudioNodeOrAudioParam) => {\n    return 'context' in nativeAudioNodeOrAudioParam;\n};\n//# sourceMappingURL=/build/es2019/guards/native-audio-node.js.map","import { AUDIO_PARAM_CONNECTIONS_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioParamConnections = (audioParam) => {\n    return getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);\n};\n//# sourceMappingURL=/build/es2019/helpers/get-audio-param-connections.js.map","import { AUDIO_PARAM_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioParam = (audioParam) => {\n    return getValueForKey(AUDIO_PARAM_STORE, audioParam);\n};\n//# sourceMappingURL=/build/es2019/helpers/get-native-audio-param.js.map","export const wrapEventListener = (target, eventListener) => {\n    return (event) => {\n        const descriptor = { value: target };\n        Object.defineProperties(event, {\n            currentTarget: descriptor,\n            target: descriptor\n        });\n        if (typeof eventListener === 'function') {\n            return eventListener.call(target, event);\n        }\n        return eventListener.handleEvent.call(target, event);\n    };\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-event-listener.js.map","import { createIndexSizeError } from '../factories/index-size-error';\nexport const wrapAudioBufferGetChannelDataMethod = (audioBuffer) => {\n    audioBuffer.getChannelData = ((getChannelData) => {\n        return (channel) => {\n            try {\n                return getChannelData.call(audioBuffer, channel);\n            }\n            catch (err) {\n                if (err.code === 12) {\n                    throw createIndexSizeError();\n                }\n                throw err;\n            }\n        };\n    })(audioBuffer.getChannelData);\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-audio-buffer-get-channel-data-method.js.map","export const wrapAudioScheduledSourceNodeStartMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {\n    nativeAudioScheduledSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration) => {\n            if ((typeof duration === 'number' && duration < 0) || offset < 0 || when < 0) {\n                throw new RangeError(\"The parameters can't be negative.\");\n            }\n            // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n            start.call(nativeAudioScheduledSourceNode, when, offset, duration);\n        };\n    })(nativeAudioScheduledSourceNode.start);\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js.map","export const wrapAudioScheduledSourceNodeStopMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            if (when < 0) {\n                throw new RangeError(\"The parameter can't be negative.\");\n            }\n            stop.call(nativeAudioScheduledSourceNode, when);\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js.map","export const testAudioBufferCopyChannelMethodsOutOfBoundsSupport = (nativeAudioBuffer) => {\n    try {\n        nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);\n    }\n    catch {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=/build/es2019/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nexport const connectNativeAudioNodeToNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];\n        nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);\n        return [fakeNativeDestinationAudioNode, output, 0];\n    }\n    nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);\n    return [nativeDestinationAudioNode, output, input];\n};\n//# sourceMappingURL=/build/es2019/helpers/connect-native-audio-node-to-native-audio-node.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nexport const disconnectNativeAudioNodeFromNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output, 0);\n    }\n    else {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);\n    }\n};\n//# sourceMappingURL=/build/es2019/helpers/disconnect-native-audio-node-from-native-audio-node.js.map","export function copyFromChannel(audioBuffer, \n// @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\nparent, key, channelNumber, bufferOffset) {\n    if (typeof audioBuffer.copyFromChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = new Float32Array(128);\n        }\n        audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);\n        // Bug #5: Safari does not support copyFromChannel().\n    }\n    else {\n        const channelData = audioBuffer.getChannelData(channelNumber);\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n        }\n        else {\n            const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n            parent[key].set(slicedInput);\n        }\n    }\n}\n//# sourceMappingURL=/build/es2019/helpers/copy-from-channel.js.map","export const createNestedArrays = (x, y) => {\n    const arrays = [];\n    for (let i = 0; i < x; i += 1) {\n        const array = [];\n        const length = (typeof y === 'number') ? y : y[i];\n        for (let j = 0; j < length; j += 1) {\n            array.push(new Float32Array(128));\n        }\n        arrays.push(array);\n    }\n    return arrays;\n};\n//# sourceMappingURL=/build/es2019/helpers/create-nested-arrays.js.map","export const createInvalidAccessError = () => {\n    try {\n        return new DOMException('', 'InvalidAccessError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 15;\n        err.name = 'InvalidAccessError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2019/factories/invalid-access-error.js.map","export const overwriteAccessors = (object, property, createGetter, createSetter) => {\n    let prototype = Object.getPrototypeOf(object);\n    while (!prototype.hasOwnProperty(property)) {\n        prototype = Object.getPrototypeOf(prototype);\n    }\n    const { get, set } = Object.getOwnPropertyDescriptor(prototype, property);\n    Object.defineProperty(object, property, { get: createGetter(get), set: createSetter(set) });\n};\n//# sourceMappingURL=/build/es2019/helpers/overwrite-accessors.js.map","export const isValidLatencyHint = (latencyHint) => {\n    return latencyHint === undefined ||\n        typeof latencyHint === 'number' ||\n        (typeof latencyHint === 'string' && (latencyHint === 'balanced' || latencyHint === 'interactive' || latencyHint === 'playback'));\n};\n//# sourceMappingURL=/build/es2019/helpers/is-valid-latency-hint.js.map","export class ReadOnlyMap {\n    constructor(parameters) {\n        this._map = new Map(parameters);\n    }\n    get size() {\n        return this._map.size;\n    }\n    entries() {\n        return this._map.entries();\n    }\n    forEach(callback, thisArg = null) {\n        return this._map.forEach((value, key) => callback.call(thisArg, value, key, this));\n    }\n    get(name) {\n        return this._map.get(name);\n    }\n    has(name) {\n        return this._map.has(name);\n    }\n    keys() {\n        return this._map.keys();\n    }\n    values() {\n        return this._map.values();\n    }\n}\n//# sourceMappingURL=/build/es2019/read-only-map.js.map","export const copyToChannel = (audioBuffer, parent, key, channelNumber, bufferOffset) => {\n    if (typeof audioBuffer.copyToChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);\n        }\n        // Bug #5: Safari does not support copyToChannel().\n    }\n    else {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer\n                .getChannelData(channelNumber)\n                .set(parent[key], bufferOffset);\n        }\n    }\n};\n//# sourceMappingURL=/build/es2019/helpers/copy-to-channel.js.map","// This implementation as shamelessly inspired by source code of\n// tslint:disable-next-line:max-line-length\n// {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.\nexport const filterBuffer = (feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, bufferIndex, bufferLength, input, output) => {\n    const inputLength = input.length;\n    let i = bufferIndex;\n    for (let j = 0; j < inputLength; j += 1) {\n        let y = feedforward[0] * input[j];\n        for (let k = 1; k < minLength; k += 1) {\n            const x = (i - k) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n            y += feedforward[k] * xBuffer[x];\n            y -= feedback[k] * yBuffer[x];\n        }\n        for (let k = minLength; k < feedforwardLength; k += 1) {\n            y += feedforward[k] * xBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n        for (let k = minLength; k < feedbackLength; k += 1) {\n            y -= feedback[k] * yBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n        xBuffer[i] = input[j];\n        yBuffer[i] = y;\n        i = (i + 1) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n        output[j] = y;\n    }\n    return i;\n};\n//# sourceMappingURL=/build/es2019/helpers/filter-buffer.js.map","export const computeBufferSize = (baseLatency, sampleRate) => {\n    if (baseLatency === null) {\n        return 512;\n    }\n    return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));\n};\n//# sourceMappingURL=/build/es2019/helpers/compute-buffer-size.js.map","export const createUnknownError = () => {\n    try {\n        return new DOMException('', 'UnknownError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.name = 'UnknownError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2019/factories/unknown-error.js.map","export const isDCCurve = (curve) => {\n    if (curve === null) {\n        return false;\n    }\n    const length = curve.length;\n    if (length % 2 !== 0) {\n        return (curve[Math.floor(length / 2)] !== 0);\n    }\n    return (curve[(length / 2) - 1] + curve[length / 2] !== 0);\n};\n//# sourceMappingURL=/build/es2019/helpers/is-dc-curve.js.map","export * from './analyser-node';\nexport * from './analyser-options';\nexport * from './audio-buffer';\nexport * from './audio-buffer-options';\nexport * from './audio-buffer-source-node';\nexport * from './audio-buffer-source-node-renderer';\nexport * from './audio-buffer-source-options';\nexport * from './audio-context';\nexport * from './audio-context-options';\nexport * from './audio-destination-node';\nexport * from './audio-listener';\nexport * from './audio-node';\nexport * from './audio-node-options';\nexport * from './audio-node-renderer';\nexport * from './audio-param';\nexport * from './audio-param-descriptor';\nexport * from './audio-param-renderer';\nexport * from './audio-scheduled-source-node';\nexport * from './audio-scheduled-source-node-event-map';\nexport * from './audio-worklet';\nexport * from './audio-worklet-node';\nexport * from './audio-worklet-node-event-map';\nexport * from './audio-worklet-node-options';\nexport * from './audio-worklet-processor';\nexport * from './audio-worklet-processor-constructor';\nexport * from './automation';\nexport * from './base-audio-context';\nexport * from './biquad-filter-node';\nexport * from './biquad-filter-options';\nexport * from './channel-merger-options';\nexport * from './channel-splitter-options';\nexport * from './common-audio-context';\nexport * from './common-offline-audio-context';\nexport * from './constant-source-node';\nexport * from './constant-source-node-renderer';\nexport * from './constant-source-options';\nexport * from './convolver-node';\nexport * from './convolver-options';\nexport * from './delay-node';\nexport * from './delay-options';\nexport * from './dynamics-compressor-node';\nexport * from './dynamics-compressor-options';\nexport * from './gain-node';\nexport * from './gain-options';\nexport * from './iir-filter-node';\nexport * from './iir-filter-options';\nexport * from './media-element-audio-source-node';\nexport * from './media-element-audio-source-options';\nexport * from './media-stream-audio-destination-node';\nexport * from './media-stream-audio-source-node';\nexport * from './media-stream-audio-source-options';\nexport * from './media-stream-track-audio-source-node';\nexport * from './media-stream-track-audio-source-options';\nexport * from './minimal-audio-context';\nexport * from './minimal-base-audio-context';\nexport * from './minimal-base-audio-context-event-map';\nexport * from './minimal-offline-audio-context';\nexport * from './native-audio-node-faker';\nexport * from './native-audio-worklet-node-faker';\nexport * from './native-constant-source-node-faker';\nexport * from './native-convolver-node-faker';\nexport * from './native-iir-filter-node-faker';\nexport * from './native-panner-node-faker';\nexport * from './native-stereo-panner-node-faker';\nexport * from './native-wave-shaper-node-faker';\nexport * from './offline-audio-completion-event';\nexport * from './offline-audio-context';\nexport * from './offline-audio-context-constructor';\nexport * from './offline-audio-context-options';\nexport * from './oscillator-node';\nexport * from './oscillator-node-renderer';\nexport * from './oscillator-options';\nexport * from './panner-node';\nexport * from './panner-options';\nexport * from './periodic-wave';\nexport * from './periodic-wave-constraints';\nexport * from './periodic-wave-options';\nexport * from './read-only-map';\nexport * from './stereo-panner-node';\nexport * from './stereo-panner-options';\nexport * from './wave-shaper-node';\nexport * from './wave-shaper-options';\nexport * from './worklet-options';\n//# sourceMappingURL=/build/es2019/interfaces/index.js.map","export * from './abort-error-factory';\nexport * from './active-input-connection';\nexport * from './add-audio-node-connections-factory';\nexport * from './add-audio-node-connections-function';\nexport * from './add-audio-param-connections-factory';\nexport * from './add-audio-param-connections-function';\nexport * from './add-audio-worklet-module-factory';\nexport * from './add-audio-worklet-module-function';\nexport * from './add-silent-connection-factory';\nexport * from './add-silent-connection-function';\nexport * from './add-unrendered-audio-worklet-node-factory';\nexport * from './add-unrendered-audio-worklet-node-function';\nexport * from './analyser-node-constructor';\nexport * from './analyser-node-constructor-factory';\nexport * from './analyser-node-renderer-factory';\nexport * from './analyser-node-renderer-factory-factory';\nexport * from './any-audio-buffer';\nexport * from './any-context';\nexport * from './audio-buffer-constructor';\nexport * from './audio-buffer-constructor-factory';\nexport * from './audio-buffer-source-node-constructor';\nexport * from './audio-buffer-source-node-constructor-factory';\nexport * from './audio-buffer-source-node-renderer';\nexport * from './audio-buffer-source-node-renderer-factory';\nexport * from './audio-buffer-source-node-renderer-factory-factory';\nexport * from './audio-buffer-store';\nexport * from './audio-context-constructor';\nexport * from './audio-context-constructor-factory';\nexport * from './audio-context-latency-category';\nexport * from './audio-context-state';\nexport * from './audio-destination-node-constructor';\nexport * from './audio-destination-node-constructor-factory';\nexport * from './audio-destination-node-renderer-factory';\nexport * from './audio-listener-factory';\nexport * from './audio-listener-factory-factory';\nexport * from './audio-node-connections';\nexport * from './audio-node-connections-store';\nexport * from './audio-node-constructor';\nexport * from './audio-node-constructor-factory';\nexport * from './audio-node-output-connection';\nexport * from './audio-node-renderer';\nexport * from './audio-node-store';\nexport * from './audio-param-audio-node-store';\nexport * from './audio-param-connections';\nexport * from './audio-param-connections-store';\nexport * from './audio-param-factory';\nexport * from './audio-param-factory-factory';\nexport * from './audio-param-map';\nexport * from './audio-param-output-connection';\nexport * from './audio-param-renderer-factory';\nexport * from './audio-param-store';\nexport * from './audio-worklet-node-constructor';\nexport * from './audio-worklet-node-constructor-factory';\nexport * from './audio-worklet-node-renderer-factory';\nexport * from './audio-worklet-node-renderer-factory-factory';\nexport * from './auxiliary-gain-node-store';\nexport * from './base-audio-context-constructor';\nexport * from './base-audio-context-constructor-factory';\nexport * from './biquad-filter-node-constructor';\nexport * from './biquad-filter-node-constructor-factory';\nexport * from './biquad-filter-node-renderer-factory';\nexport * from './biquad-filter-node-renderer-factory-factory';\nexport * from './biquad-filter-type';\nexport * from './channel-count-mode';\nexport * from './channel-interpretation';\nexport * from './channel-merger-node-constructor';\nexport * from './channel-merger-node-constructor-factory';\nexport * from './channel-merger-node-renderer-factory';\nexport * from './channel-merger-node-renderer-factory-factory';\nexport * from './channel-splitter-node-constructor';\nexport * from './channel-splitter-node-constructor-factory';\nexport * from './channel-splitter-node-renderer-factory';\nexport * from './channel-splitter-node-renderer-factory-factory';\nexport * from './cache-test-result-factory';\nexport * from './cache-test-result-function';\nexport * from './connect-audio-param-factory';\nexport * from './connect-audio-param-function';\nexport * from './connect-multiple-outputs-factory';\nexport * from './connect-multiple-outputs-function';\nexport * from './connect-native-audio-node-to-native-audio-node-function';\nexport * from './connected-native-audio-buffer-source-node-factory';\nexport * from './connected-native-audio-buffer-source-node-factory-factory';\nexport * from './constant-source-node-constructor';\nexport * from './constant-source-node-constructor-factory';\nexport * from './constant-source-node-renderer';\nexport * from './constant-source-node-renderer-factory';\nexport * from './constant-source-node-renderer-factory-factory';\nexport * from './constructor';\nexport * from './context';\nexport * from './context-store';\nexport * from './convert-number-to-unsigned-long-factory';\nexport * from './convert-number-to-unsigned-long-function';\nexport * from './convolver-node-constructor';\nexport * from './convolver-node-constructor-factory';\nexport * from './convolver-node-renderer-factory';\nexport * from './convolver-node-renderer-factory-factory';\nexport * from './create-native-offline-audio-context-factory';\nexport * from './create-native-offline-audio-context-function';\nexport * from './cycle-counters';\nexport * from './data-clone-error-factory';\nexport * from './decode-audio-data-factory';\nexport * from './decode-audio-data-function';\nexport * from './decode-error-callback';\nexport * from './decode-success-callback';\nexport * from './decrement-cycle-counter-factory';\nexport * from './decrement-cycle-counter-function';\nexport * from './delay-node-constructor';\nexport * from './delay-node-constructor-factory';\nexport * from './delay-node-renderer-factory';\nexport * from './delay-node-renderer-factory-factory';\nexport * from './delete-unrendered-audio-worklet-node-factory';\nexport * from './delete-unrendered-audio-worklet-node-function';\nexport * from './detect-cycles-factory';\nexport * from './detect-cycles-function';\nexport * from './disconnect-multiple-outputs-factory';\nexport * from './disconnect-multiple-outputs-function';\nexport * from './disconnect-native-audio-node-from-native-audio-node-function';\nexport * from './distance-model-type';\nexport * from './dynamics-compressor-node-constructor';\nexport * from './dynamics-compressor-node-constructor-factory';\nexport * from './dynamics-compressor-node-renderer-factory';\nexport * from './dynamics-compressor-node-renderer-factory-factory';\nexport * from './encoding-error-factory';\nexport * from './error-event-handler';\nexport * from './evaluate-audio-worklet-global-scope-function';\nexport * from './evaluate-source-factory';\nexport * from './evaluate-source-function';\nexport * from './event-handler';\nexport * from './event-target-constructor';\nexport * from './event-target-constructor-factory';\nexport * from './expose-current-frame-and-current-time-factory';\nexport * from './expose-current-frame-and-current-time-function';\nexport * from './fetch-source-factory';\nexport * from './fetch-source-function';\nexport * from './gain-node-constructor';\nexport * from './gain-node-constructor-factory';\nexport * from './gain-node-renderer-factory';\nexport * from './gain-node-renderer-factory-factory';\nexport * from './get-audio-node-connections-function';\nexport * from './get-audio-node-renderer-factory';\nexport * from './get-audio-node-renderer-function';\nexport * from './get-audio-param-connections-function';\nexport * from './get-audio-param-renderer-factory';\nexport * from './get-audio-param-renderer-function';\nexport * from './get-backup-native-context-factory';\nexport * from './get-backup-native-context-function';\nexport * from './get-native-audio-node-function';\nexport * from './get-native-audio-param-function';\nexport * from './get-native-context-function';\nexport * from './get-native-context-factory';\nexport * from './get-unrendered-audio-worklet-nodes-factory';\nexport * from './get-unrendered-audio-worklet-nodes-function';\nexport * from './get-value-for-key-function';\nexport * from './iir-filter-node-constructor';\nexport * from './iir-filter-node-constructor-factory';\nexport * from './iir-filter-node-renderer-factory';\nexport * from './iir-filter-node-renderer-factory-factory';\nexport * from './increment-cycle-counter-factory';\nexport * from './increment-cycle-counter-factory-factory';\nexport * from './increment-cycle-counter-function';\nexport * from './index-size-error-factory';\nexport * from './insert-element-in-set-function';\nexport * from './internal-state-event-listener';\nexport * from './invalid-access-error-factory';\nexport * from './invalid-state-error-factory';\nexport * from './is-active-audio-node-function';\nexport * from './is-any-audio-context-factory';\nexport * from './is-any-audio-context-function';\nexport * from './is-any-audio-node-factory';\nexport * from './is-any-audio-node-function';\nexport * from './is-any-audio-param-factory';\nexport * from './is-any-audio-param-function';\nexport * from './is-any-offline-audio-context-factory';\nexport * from './is-any-offline-audio-context-function';\nexport * from './is-dc-curve-function';\nexport * from './is-native-audio-context-factory';\nexport * from './is-native-audio-context-function';\nexport * from './is-native-audio-node-factory';\nexport * from './is-native-audio-node-function';\nexport * from './is-native-audio-param-factory';\nexport * from './is-native-audio-param-function';\nexport * from './is-native-context-factory';\nexport * from './is-native-context-function';\nexport * from './is-native-offline-audio-context-factory';\nexport * from './is-native-offline-audio-context-function';\nexport * from './is-part-of-a-cycle-function';\nexport * from './is-secure-context-factory';\nexport * from './is-supported-promise-factory';\nexport * from './media-element-audio-source-node-constructor';\nexport * from './media-element-audio-source-node-constructor-factory';\nexport * from './media-stream-audio-destination-node-constructor';\nexport * from './media-stream-audio-destination-node-constructor-factory';\nexport * from './media-stream-audio-source-node-constructor';\nexport * from './media-stream-audio-source-node-constructor-factory';\nexport * from './media-stream-track-audio-source-node-constructor';\nexport * from './media-stream-track-audio-source-node-constructor-factory';\nexport * from './minimal-audio-context-constructor';\nexport * from './minimal-audio-context-constructor-factory';\nexport * from './minimal-base-audio-context-constructor';\nexport * from './minimal-base-audio-context-constructor-factory';\nexport * from './minimal-offline-audio-context-constructor';\nexport * from './minimal-offline-audio-context-constructor-factory';\nexport * from './monitor-connections-factory';\nexport * from './monitor-connections-function';\nexport * from './native-analyser-node';\nexport * from './native-analyser-node-factory';\nexport * from './native-analyser-node-factory-factory';\nexport * from './native-audio-buffer';\nexport * from './native-audio-buffer-constructor';\nexport * from './native-audio-buffer-constructor-factory';\nexport * from './native-audio-buffer-source-node';\nexport * from './native-audio-buffer-source-node-factory';\nexport * from './native-audio-buffer-source-node-factory-factory';\nexport * from './native-audio-context';\nexport * from './native-audio-context-constructor';\nexport * from './native-audio-context-constructor-factory';\nexport * from './native-audio-destination-node';\nexport * from './native-audio-destination-node-factory';\nexport * from './native-audio-destination-node-factory-factory';\nexport * from './native-audio-listener';\nexport * from './native-audio-node';\nexport * from './native-audio-node-factory';\nexport * from './native-audio-node-factory-factory';\nexport * from './native-audio-param';\nexport * from './native-audio-param-map';\nexport * from './native-audio-worklet';\nexport * from './native-audio-worklet-node';\nexport * from './native-audio-worklet-node-constructor';\nexport * from './native-audio-worklet-node-constructor-factory';\nexport * from './native-audio-worklet-node-factory';\nexport * from './native-audio-worklet-node-factory-factory';\nexport * from './native-audio-worklet-node-faker-factory';\nexport * from './native-audio-worklet-node-faker-factory-factory';\nexport * from './native-audio-worklet-node-options';\nexport * from './native-biquad-filter-node';\nexport * from './native-biquad-filter-node-factory';\nexport * from './native-biquad-filter-node-factory-factory';\nexport * from './native-channel-merger-node';\nexport * from './native-channel-merger-node-factory';\nexport * from './native-channel-merger-node-factory-factory';\nexport * from './native-channel-splitter-node';\nexport * from './native-channel-splitter-node-factory';\nexport * from './native-channel-splitter-node-factory-factory';\nexport * from './native-constant-source-node';\nexport * from './native-constant-source-node-factory';\nexport * from './native-constant-source-node-factory-factory';\nexport * from './native-constant-source-node-faker-factory';\nexport * from './native-constant-source-node-faker-factory-factory';\nexport * from './native-context';\nexport * from './native-convolver-node';\nexport * from './native-convolver-node-factory';\nexport * from './native-convolver-node-factory-factory';\nexport * from './native-convolver-node-faker-factory';\nexport * from './native-convolver-node-faker-factory-factory';\nexport * from './native-delay-node-factory';\nexport * from './native-delay-node-factory-factory';\nexport * from './native-delay-node';\nexport * from './native-dynamics-compressor-node';\nexport * from './native-dynamics-compressor-node-factory';\nexport * from './native-dynamics-compressor-node-factory-factory';\nexport * from './native-event-target';\nexport * from './native-gain-node';\nexport * from './native-gain-node-factory';\nexport * from './native-gain-node-factory-factory';\nexport * from './native-iir-filter-node';\nexport * from './native-iir-filter-node-factory';\nexport * from './native-iir-filter-node-factory-factory';\nexport * from './native-iir-filter-node-faker-factory';\nexport * from './native-iir-filter-node-faker-factory-factory';\nexport * from './native-media-element-audio-source-node';\nexport * from './native-media-element-audio-source-node-factory';\nexport * from './native-media-element-audio-source-node-factory-factory';\nexport * from './native-media-stream-audio-destination-node';\nexport * from './native-media-stream-audio-destination-node-factory';\nexport * from './native-media-stream-audio-destination-node-factory-factory';\nexport * from './native-media-stream-audio-source-node';\nexport * from './native-media-stream-audio-source-node-factory';\nexport * from './native-media-stream-audio-source-node-factory-factory';\nexport * from './native-media-stream-track-audio-source-node';\nexport * from './native-media-stream-track-audio-source-node-factory';\nexport * from './native-media-stream-track-audio-source-node-factory-factory';\nexport * from './native-offline-audio-context';\nexport * from './native-offline-audio-context-constructor';\nexport * from './native-offline-audio-context-constructor-factory';\nexport * from './native-oscillator-node';\nexport * from './native-oscillator-node-factory';\nexport * from './native-oscillator-node-factory-factory';\nexport * from './native-panner-node';\nexport * from './native-panner-node-factory';\nexport * from './native-panner-node-factory-factory';\nexport * from './native-panner-node-faker-factory';\nexport * from './native-panner-node-faker-factory-factory';\nexport * from './native-periodic-wave';\nexport * from './native-periodic-wave-factory';\nexport * from './native-periodic-wave-factory-factory';\nexport * from './native-script-processor-node';\nexport * from './native-script-processor-node-factory';\nexport * from './native-script-processor-node-factory-factory';\nexport * from './native-stereo-panner-node';\nexport * from './native-stereo-panner-node-factory';\nexport * from './native-stereo-panner-node-factory-factory';\nexport * from './native-stereo-panner-node-faker-factory';\nexport * from './native-stereo-panner-node-faker-factory-factory';\nexport * from './native-wave-shaper-node';\nexport * from './native-wave-shaper-node-factory';\nexport * from './native-wave-shaper-node-factory-factory';\nexport * from './native-wave-shaper-node-faker-factory';\nexport * from './native-wave-shaper-node-faker-factory-factory';\nexport * from './not-supported-error-factory';\nexport * from './offline-audio-context-constructor-factory';\nexport * from './oscillator-node-constructor';\nexport * from './oscillator-node-constructor-factory';\nexport * from './oscillator-node-renderer';\nexport * from './oscillator-node-renderer-factory';\nexport * from './oscillator-node-renderer-factory-factory';\nexport * from './oscillator-type';\nexport * from './output-connection';\nexport * from './over-sample-type';\nexport * from './overwrite-accessors-function';\nexport * from './panner-node-constructor';\nexport * from './panner-node-constructor-factory';\nexport * from './panner-node-renderer-factory';\nexport * from './panner-node-renderer-factory-factory';\nexport * from './panning-model-type';\nexport * from './passive-audio-node-input-connection';\nexport * from './passive-audio-param-input-connection';\nexport * from './periodic-wave-constructor';\nexport * from './periodic-wave-constructor-factory';\nexport * from './render-automation-factory';\nexport * from './render-automation-function';\nexport * from './render-inputs-of-audio-node-factory';\nexport * from './render-inputs-of-audio-node-function';\nexport * from './render-inputs-of-audio-param-factory';\nexport * from './render-inputs-of-audio-param-function';\nexport * from './render-native-offline-audio-context-factory';\nexport * from './render-native-offline-audio-context-function';\nexport * from './start-rendering-factory';\nexport * from './start-rendering-function';\nexport * from './stereo-panner-node-constructor';\nexport * from './stereo-panner-node-constructor-factory';\nexport * from './stereo-panner-node-renderer-factory-factory';\nexport * from './stereo-panner-node-renderer-factory';\nexport * from './test-audio-buffer-copy-channel-methods-subarray-support-factory';\nexport * from './test-audio-buffer-constructor-support-factory';\nexport * from './test-audio-buffer-source-node-start-method-consecutive-calls-support-factory';\nexport * from './test-audio-buffer-source-node-start-method-duration-parameter-support-factory';\nexport * from './test-audio-buffer-source-node-start-method-offset-clamping-support-factory';\nexport * from './test-audio-buffer-source-node-stop-method-nullified-buffer-support-factory';\nexport * from './test-audio-context-close-method-support-factory';\nexport * from './test-audio-context-decode-audio-data-method-type-error-support-factory';\nexport * from './test-audio-context-options-support-factory';\nexport * from './test-audio-node-connect-method-support-factory';\nexport * from './test-audio-scheduled-source-node-start-method-consecutive-calls-support-factory';\nexport * from './test-audio-scheduled-source-node-stop-method-consecutive-calls-support-factory';\nexport * from './test-audio-scheduled-source-node-stop-method-negative-parameters-support-factory';\nexport * from './test-audio-worklet-processor-no-outputs-support-factory';\nexport * from './test-channel-merger-node-channel-count-support-factory';\nexport * from './test-constant-source-node-accurate-scheduling-support-factory';\nexport * from './test-convolver-node-buffer-reassignability-support-factory';\nexport * from './test-is-secure-context-support-factory';\nexport * from './test-media-stream-audio-source-node-media-stream-without-audio-track-support';\nexport * from './test-offline-audio-context-current-time-support-factory';\nexport * from './test-stereo-panner-node-default-value-support-factory';\nexport * from './typed-array';\nexport * from './unknown-error-factory';\nexport * from './unrendered-audio-worklet-node-store';\nexport * from './unrendered-audio-worklet-nodes';\nexport * from './wave-shaper-node-constructor';\nexport * from './wave-shaper-node-constructor-factory';\nexport * from './wave-shaper-node-renderer-factory-factory';\nexport * from './wave-shaper-node-renderer-factory';\nexport * from './window-factory';\nexport * from './wrap-audio-buffer-copy-channel-methods-factory';\nexport * from './wrap-audio-buffer-copy-channel-methods-function';\nexport * from './wrap-audio-buffer-copy-channel-methods-out-of-bounds-factory';\nexport * from './wrap-audio-buffer-copy-channel-methods-out-of-bounds-function';\nexport * from './wrap-audio-buffer-source-node-start-method-offset-clamping-function';\nexport * from './wrap-audio-buffer-source-node-stop-method-nullified-buffer-factory';\nexport * from './wrap-audio-buffer-source-node-stop-method-nullified-buffer-function';\nexport * from './wrap-audio-scheduled-source-node-stop-method-consecutive-calls-factory';\nexport * from './wrap-audio-scheduled-source-node-stop-method-consecutive-calls-function';\nexport * from './wrap-channel-merger-node-factory';\nexport * from './wrap-channel-merger-node-function';\nexport * from './wrap-event-listener-function';\n//# sourceMappingURL=/build/es2019/types/index.js.map","export const createAbortError = () => {\n    try {\n        return new DOMException('', 'AbortError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 20;\n        err.name = 'AbortError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2019/factories/abort-error.js.map","export const createAddAudioNodeConnections = (audioNodeConnectionsStore) => {\n    return (audioNode, audioNodeRenderer, nativeAudioNode) => {\n        const activeInputs = [];\n        for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {\n            activeInputs.push(new Set());\n        }\n        audioNodeConnectionsStore.set(audioNode, {\n            activeInputs,\n            outputs: new Set(),\n            passiveInputs: new WeakMap(),\n            renderer: audioNodeRenderer\n        });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/add-audio-node-connections.js.map","export const createAddAudioParamConnections = (audioParamConnectionsStore) => {\n    return (audioParam, audioParamRenderer) => {\n        audioParamConnectionsStore.set(audioParam, { activeInputs: new Set(), passiveInputs: new WeakMap(), renderer: audioParamRenderer });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/add-audio-param-connections.js.map","export const createAddSilentConnection = (createNativeGainNode) => {\n    return (nativeContext, nativeAudioScheduledSourceNode) => {\n        const nativeGainNode = createNativeGainNode(nativeContext, { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete', gain: 0 });\n        nativeAudioScheduledSourceNode\n            .connect(nativeGainNode)\n            /*\n             * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is\n             * used here to make sure to connect the right destination.\n             */\n            .connect(nativeGainNode.context.destination);\n        const disconnect = () => {\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnect);\n            nativeAudioScheduledSourceNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n        nativeAudioScheduledSourceNode.addEventListener('ended', disconnect);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/add-silent-connection.js.map","export const createAddUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext)\n            .add(audioWorkletNode);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/add-unrendered-audio-worklet-node.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    fftSize: 2048,\n    maxDecibels: -30,\n    minDecibels: -100,\n    smoothingTimeConstant: 0.8\n};\nexport const createAnalyserNodeConstructor = (audionNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class AnalyserNode extends audionNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAnalyserNode = createNativeAnalyserNode(nativeContext, mergedOptions);\n            const analyserNodeRenderer = ((isNativeOfflineAudioContext(nativeContext))\n                ? createAnalyserNodeRenderer()\n                : null);\n            super(context, false, nativeAnalyserNode, analyserNodeRenderer);\n            this._nativeAnalyserNode = nativeAnalyserNode;\n        }\n        get fftSize() {\n            return this._nativeAnalyserNode.fftSize;\n        }\n        set fftSize(value) {\n            this._nativeAnalyserNode.fftSize = value;\n        }\n        get frequencyBinCount() {\n            return this._nativeAnalyserNode.frequencyBinCount;\n        }\n        get maxDecibels() {\n            return this._nativeAnalyserNode.maxDecibels;\n        }\n        set maxDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const maxDecibels = this._nativeAnalyserNode.maxDecibels;\n            this._nativeAnalyserNode.maxDecibels = value;\n            if (!(value > this._nativeAnalyserNode.minDecibels)) {\n                this._nativeAnalyserNode.maxDecibels = maxDecibels;\n                throw createIndexSizeError();\n            }\n        }\n        get minDecibels() {\n            return this._nativeAnalyserNode.minDecibels;\n        }\n        set minDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const minDecibels = this._nativeAnalyserNode.minDecibels;\n            this._nativeAnalyserNode.minDecibels = value;\n            if (!(this._nativeAnalyserNode.maxDecibels > value)) {\n                this._nativeAnalyserNode.minDecibels = minDecibels;\n                throw createIndexSizeError();\n            }\n        }\n        get smoothingTimeConstant() {\n            return this._nativeAnalyserNode.smoothingTimeConstant;\n        }\n        set smoothingTimeConstant(value) {\n            this._nativeAnalyserNode.smoothingTimeConstant = value;\n        }\n        getByteFrequencyData(array) {\n            this._nativeAnalyserNode.getByteFrequencyData(array);\n        }\n        getByteTimeDomainData(array) {\n            this._nativeAnalyserNode.getByteTimeDomainData(array);\n        }\n        getFloatFrequencyData(array) {\n            this._nativeAnalyserNode.getFloatFrequencyData(array);\n        }\n        getFloatTimeDomainData(array) {\n            this._nativeAnalyserNode.getFloatTimeDomainData(array);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/analyser-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createAnalyserNodeRendererFactory = (createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAnalyserNodes = new WeakMap();\n        const createAnalyserNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAnalyserNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAnalyserNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);\n            if (!nativeAnalyserNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAnalyserNode.channelCount,\n                    channelCountMode: nativeAnalyserNode.channelCountMode,\n                    channelInterpretation: nativeAnalyserNode.channelInterpretation,\n                    fftSize: nativeAnalyserNode.fftSize,\n                    maxDecibels: nativeAnalyserNode.maxDecibels,\n                    minDecibels: nativeAnalyserNode.minDecibels,\n                    smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant\n                };\n                nativeAnalyserNode = createNativeAnalyserNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAnalyserNode, trace);\n            return nativeAnalyserNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAnalyserNode !== undefined) {\n                    return Promise.resolve(renderedNativeAnalyserNode);\n                }\n                return createAnalyserNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/analyser-node-renderer-factory.js.map","import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createAudioBufferConstructor = (audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    let nativeOfflineAudioContext = null;\n    return class AudioBuffer {\n        constructor(options) {\n            if (nativeOfflineAudioContextConstructor === null) {\n                throw new Error('Missing the native OfflineAudioContext constructor.');\n            }\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            if (nativeOfflineAudioContext === null) {\n                nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n            }\n            /*\n             * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n             * factory function. But since Firefox also supports the constructor everything should be fine.\n             */\n            const audioBuffer = (nativeAudioBufferConstructor !== null &&\n                cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport)) ?\n                new nativeAudioBufferConstructor({ length, numberOfChannels, sampleRate }) :\n                nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n            // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n            if (audioBuffer.numberOfChannels === 0) {\n                throw createNotSupportedError();\n            }\n            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n            // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n            if (typeof audioBuffer.copyFromChannel !== 'function') {\n                wrapAudioBufferCopyChannelMethods(audioBuffer);\n                wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n            }\n            else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            }\n            audioBufferStore.add(audioBuffer);\n            /*\n             * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n             * (Offline)AudioContexts.\n             */\n            return audioBuffer;\n        }\n        static [Symbol.hasInstance](instance) {\n            return (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype)\n                || (audioBufferStore.has(instance));\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-buffer-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    // Bug #149: Safari does not yet support the detune AudioParam.\n    loop: false,\n    loopEnd: 0,\n    loopStart: 0,\n    playbackRate: 1\n};\nexport const createAudioBufferSourceNodeConstructor = (audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n    return class AudioBufferSourceNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const audioBufferSourceNodeRenderer = ((isOffline)\n                ? createAudioBufferSourceNodeRenderer()\n                : null);\n            super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n            this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n            this._isBufferNullified = false;\n            this._isBufferSet = (options.buffer !== null && options.buffer !== undefined);\n            this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n            this._onended = null;\n            // Bug #73: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._playbackRate = createAudioParam(this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get buffer() {\n            if (this._isBufferNullified) {\n                return null;\n            }\n            return this._nativeAudioBufferSourceNode.buffer;\n        }\n        set buffer(value) {\n            // Bug #71: Edge does not allow to set the buffer to null.\n            try {\n                this._nativeAudioBufferSourceNode.buffer = value;\n            }\n            catch (err) {\n                if (value !== null || err.code !== 17) {\n                    throw err;\n                }\n                // This will modify the buffer in place. Luckily that works in Edge and has the same effect as setting the buffer to null.\n                if (this._nativeAudioBufferSourceNode.buffer !== null) {\n                    const buffer = this._nativeAudioBufferSourceNode.buffer;\n                    const numberOfChannels = buffer.numberOfChannels;\n                    for (let i = 0; i < numberOfChannels; i += 1) {\n                        buffer\n                            .getChannelData(i)\n                            .fill(0);\n                    }\n                    this._isBufferNullified = true;\n                }\n            }\n            // Bug #72: Only Chrome, Edge & Opera do not allow to reassign the buffer yet.\n            if (value !== null) {\n                if (this._isBufferSet) {\n                    throw createInvalidStateError();\n                }\n                this._isBufferSet = true;\n            }\n        }\n        get loop() {\n            return this._nativeAudioBufferSourceNode.loop;\n        }\n        set loop(value) {\n            this._nativeAudioBufferSourceNode.loop = value;\n        }\n        get loopEnd() {\n            return this._nativeAudioBufferSourceNode.loopEnd;\n        }\n        set loopEnd(value) {\n            this._nativeAudioBufferSourceNode.loopEnd = value;\n        }\n        get loopStart() {\n            return this._nativeAudioBufferSourceNode.loopStart;\n        }\n        set loopStart(value) {\n            this._nativeAudioBufferSourceNode.loopStart = value;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = (typeof value === 'function') ? wrapEventListener(this, value) : null;\n            this._nativeAudioBufferSourceNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n            this._onended = (nativeOnEnded !== null && nativeOnEnded === wrappedListener)\n                ? value\n                : nativeOnEnded;\n        }\n        get playbackRate() {\n            return this._playbackRate;\n        }\n        start(when = 0, offset = 0, duration) {\n            this._nativeAudioBufferSourceNode.start(when, offset, duration);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.start = (duration === undefined) ? [when, offset] : [when, offset, duration];\n            }\n            else {\n                setInternalStateToActive(this);\n                const resetInternalStateToPassive = () => {\n                    this._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n                    // @todo Determine a meaningful delay instead of just using one second.\n                    setTimeout(() => setInternalStateToPassive(this), 1000);\n                };\n                this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeAudioBufferSourceNode.stop(when);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-buffer-source-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createAudioBufferSourceNodeRendererFactory = (connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAudioBufferSourceNodes = new WeakMap();\n        let start = null;\n        let stop = null;\n        const createAudioBufferSourceNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioBufferSourceNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeAudioBufferSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeAudioBufferSourceNode.buffer,\n                    channelCount: nativeAudioBufferSourceNode.channelCount,\n                    channelCountMode: nativeAudioBufferSourceNode.channelCountMode,\n                    channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,\n                    // Bug #149: Safari does not yet support the detune AudioParam.\n                    loop: nativeAudioBufferSourceNode.loop,\n                    loopEnd: nativeAudioBufferSourceNode.loopEnd,\n                    loopStart: nativeAudioBufferSourceNode.loopStart,\n                    playbackRate: nativeAudioBufferSourceNode.playbackRate.value\n                };\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeAudioBufferSourceNode.start(...start);\n                }\n                if (stop !== null) {\n                    nativeAudioBufferSourceNode.stop(stop);\n                }\n            }\n            renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await renderAutomation(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate, trace);\n            }\n            else {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await connectAudioParam(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode, trace);\n            return nativeAudioBufferSourceNode;\n        };\n        return {\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioBufferSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioBufferSourceNode);\n                }\n                return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-buffer-source-node-renderer-factory.js.map","import { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nexport const createAudioContextConstructor = (baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor) => {\n    return class AudioContext extends baseAudioContextConstructor {\n        constructor(options = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n            const nativeAudioContext = new nativeAudioContextConstructor(options);\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n            // Bug #51 Only Chrome and Opera throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);\n            }\n            // Bug #150 Only Chrome, Firefox and Opera support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n            super(nativeAudioContext, 2);\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency = (typeof nativeAudioContext.baseLatency === 'number')\n                ? nativeAudioContext.baseLatency\n                : (latencyHint === 'balanced')\n                    ? (512 / sampleRate)\n                    : (latencyHint === 'interactive' || latencyHint === undefined)\n                        ? (256 / sampleRate)\n                        : (latencyHint === 'playback')\n                            ? (1024 / sampleRate)\n                            /*\n                             * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                             * ScriptProcessorNode.\n                             */\n                            : ((Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate);\n            this._nativeAudioContext = nativeAudioContext;\n            this._state = null;\n            /*\n             * Bug #34: Chrome and Opera pretend to be running right away, but fire an onstatechange event when the state actually changes\n             * to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n        get baseLatency() {\n            return this._baseLatency;\n        }\n        get state() {\n            return (this._state !== null) ? this._state : this._nativeAudioContext.state;\n        }\n        close() {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext\n                    .close()\n                    .then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n            return this._nativeAudioContext.close();\n            /*\n             * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n             * ...then(() => deleteAudioGraph(this, this._nativeAudioContext));\n             */\n        }\n        createMediaElementSource(mediaElement) {\n            return new mediaElementAudioSourceNodeConstructor(this, { mediaElement });\n        }\n        createMediaStreamDestination() {\n            return new mediaStreamAudioDestinationNodeConstructor(this);\n        }\n        createMediaStreamSource(mediaStream) {\n            return new mediaStreamAudioSourceNodeConstructor(this, { mediaStream });\n        }\n        createMediaStreamTrackSource(mediaStreamTrack) {\n            return new mediaStreamTrackAudioSourceNodeConstructor(this, { mediaStreamTrack });\n        }\n        resume() {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        }\n                        else {\n                            this\n                                .resume()\n                                .then(resolve, reject);\n                        }\n                    };\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n            return this._nativeAudioContext\n                .resume()\n                .catch((err) => {\n                // Bug #55: Chrome, Edge and Opera do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n                throw err;\n            });\n        }\n        suspend() {\n            return this._nativeAudioContext\n                .suspend()\n                .catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n                throw err;\n            });\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-context-constructor.js.map","export const createAudioDestinationNodeConstructor = (audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode) => {\n    return class AudioDestinationNode extends audioNodeConstructor {\n        constructor(context, channelCount) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);\n            const audioDestinationNodeRenderer = ((isOffline)\n                ? createAudioDestinationNodeRenderer(renderInputsOfAudioNode)\n                : null);\n            super(context, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);\n            this._isNodeOfNativeOfflineAudioContext = isOffline;\n            this._nativeAudioDestinationNode = nativeAudioDestinationNode;\n        }\n        get channelCount() {\n            return this._nativeAudioDestinationNode.channelCount;\n        }\n        set channelCount(value) {\n            // Bug #52: Chrome, Edge, Opera & Safari do not throw an exception at all.\n            // Bug #54: Firefox does throw an IndexSizeError.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n            // Bug #47: The AudioDestinationNode in Edge and Safari do not initialize the maxChannelCount property correctly.\n            if (value > this._nativeAudioDestinationNode.maxChannelCount) {\n                throw createIndexSizeError();\n            }\n            this._nativeAudioDestinationNode.channelCount = value;\n        }\n        get channelCountMode() {\n            return this._nativeAudioDestinationNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            // Bug #53: No browser does throw an exception yet.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n            this._nativeAudioDestinationNode.channelCountMode = value;\n        }\n        get maxChannelCount() {\n            return this._nativeAudioDestinationNode.maxChannelCount;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-destination-node-constructor.js.map","export const createAudioDestinationNodeRenderer = (renderInputsOfAudioNode) => {\n    let nativeAudioDestinationNodePromise = null;\n    const createAudioDestinationNode = async (proxy, nativeOfflineAudioContext, trace) => {\n        const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode, trace);\n        return nativeAudioDestinationNode;\n    };\n    return {\n        render(proxy, nativeOfflineAudioContext, trace) {\n            if (nativeAudioDestinationNodePromise === null) {\n                nativeAudioDestinationNodePromise = createAudioDestinationNode(proxy, nativeOfflineAudioContext, trace);\n            }\n            return nativeAudioDestinationNodePromise;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-destination-node-renderer-factory.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nexport const createAudioListenerFactory = (createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, isNativeOfflineAudioContext) => {\n    return (context, nativeContext) => {\n        const nativeListener = nativeContext.listener;\n        // Bug #117: Only Chrome & Opera support the new interface already.\n        const createFakeAudioParams = () => {\n            const channelMergerNode = createNativeChannelMergerNode(nativeContext, { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'speakers', numberOfInputs: 9 });\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0);\n            const createFakeAudioParam = (input, value) => {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete', offset: value });\n                constantSourceNode.connect(channelMergerNode, 0, input);\n                // @todo This should be stopped when the context is closed.\n                constantSourceNode.start();\n                Object.defineProperty(constantSourceNode.offset, 'defaultValue', {\n                    get() {\n                        return value;\n                    }\n                });\n                /*\n                 * Bug #62 & #74: Edge & Safari do not support ConstantSourceNodes and do not export the correct values for maxValue and\n                 * minValue for GainNodes.\n                 */\n                return createAudioParam({ context }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            };\n            let lastOrientation = [0, 0, -1, 0, 1, 0];\n            let lastPosition = [0, 0, 0];\n            scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n                const orientation = [\n                    inputBuffer.getChannelData(0)[0],\n                    inputBuffer.getChannelData(1)[0],\n                    inputBuffer.getChannelData(2)[0],\n                    inputBuffer.getChannelData(3)[0],\n                    inputBuffer.getChannelData(4)[0],\n                    inputBuffer.getChannelData(5)[0]\n                ];\n                if (orientation.some((value, index) => (value !== lastOrientation[index]))) {\n                    nativeListener.setOrientation(...orientation); // tslint:disable-line:deprecation\n                    lastOrientation = orientation;\n                }\n                const positon = [\n                    inputBuffer.getChannelData(6)[0],\n                    inputBuffer.getChannelData(7)[0],\n                    inputBuffer.getChannelData(8)[0]\n                ];\n                if (positon.some((value, index) => (value !== lastPosition[index]))) {\n                    nativeListener.setPosition(...positon); // tslint:disable-line:deprecation\n                    lastPosition = positon;\n                }\n            };\n            channelMergerNode.connect(scriptProcessorNode);\n            return {\n                forwardX: createFakeAudioParam(0, 0),\n                forwardY: createFakeAudioParam(1, 0),\n                forwardZ: createFakeAudioParam(2, -1),\n                positionX: createFakeAudioParam(6, 0),\n                positionY: createFakeAudioParam(7, 0),\n                positionZ: createFakeAudioParam(8, 0),\n                upX: createFakeAudioParam(3, 0),\n                upY: createFakeAudioParam(4, 1),\n                upZ: createFakeAudioParam(5, 0)\n            };\n        };\n        const { forwardX, forwardY, forwardZ, positionX, positionY, positionZ, upX, upY, upZ } = (nativeListener.forwardX === undefined)\n            ? createFakeAudioParams()\n            : nativeListener;\n        return {\n            get forwardX() {\n                return forwardX;\n            },\n            get forwardY() {\n                return forwardY;\n            },\n            get forwardZ() {\n                return forwardZ;\n            },\n            get positionX() {\n                return positionX;\n            },\n            get positionY() {\n                return positionY;\n            },\n            get positionZ() {\n                return positionZ;\n            },\n            get upX() {\n                return upX;\n            },\n            get upY() {\n                return upY;\n            },\n            get upZ() {\n                return upZ;\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-listener-factory.js.map","import { AutomationEventList } from 'automation-events';\nexport const createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor) => {\n    return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {\n        const automationEventList = new AutomationEventList(nativeAudioParam.defaultValue);\n        const audioParamRenderer = (isAudioParamOfOfflineAudioContext) ? createAudioParamRenderer(automationEventList) : null;\n        const audioParam = {\n            get defaultValue() {\n                return nativeAudioParam.defaultValue;\n            },\n            get maxValue() {\n                return (maxValue === null) ? nativeAudioParam.maxValue : maxValue;\n            },\n            get minValue() {\n                return (minValue === null) ? nativeAudioParam.minValue : minValue;\n            },\n            get value() {\n                return nativeAudioParam.value;\n            },\n            set value(value) {\n                nativeAudioParam.value = value;\n                // Bug #98: Edge, Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n                audioParam.setValueAtTime(value, audioNode.context.currentTime);\n            },\n            cancelAndHoldAtTime(cancelTime) {\n                // Bug #28: Edge, Firefox & Safari do not yet implement cancelAndHoldAtTime().\n                if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n                }\n                else {\n                    const previousLastEvent = Array\n                        .from(automationEventList)\n                        .pop();\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    const currentLastEvent = Array\n                        .from(automationEventList)\n                        .pop();\n                    nativeAudioParam.cancelScheduledValues(cancelTime);\n                    if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n                        if (currentLastEvent.type === 'exponentialRampToValue') {\n                            nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'linearRampToValue') {\n                            nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'setValue') {\n                            nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n                        }\n                        else if (currentLastEvent.type === 'setValueCurve') {\n                            nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n                        }\n                    }\n                }\n                return audioParam;\n            },\n            cancelScheduledValues(cancelTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n                nativeAudioParam.cancelScheduledValues(cancelTime);\n                return audioParam;\n            },\n            exponentialRampToValueAtTime(value, endTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            linearRampToValueAtTime(value, endTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.linearRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            setTargetAtTime(target, startTime, timeConstant) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n                return audioParam;\n            },\n            setValueAtTime(value, startTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetValueAutomationEvent(value, startTime));\n                nativeAudioParam.setValueAtTime(value, startTime);\n                return audioParam;\n            },\n            setValueCurveAtTime(values, startTime, duration) {\n                /*\n                 * Bug #152: Safari does not correctly interpolate the values of the curve.\n                 * @todo Unfortunately there is no way to test for this behavior in synchronous fashion which is why testing for the\n                 * existence of the webkitAudioContext is used as a workaround here.\n                 */\n                if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                    const endTime = startTime + duration;\n                    const sampleRate = audioNode.context.sampleRate;\n                    const firstSample = Math.ceil(startTime * sampleRate);\n                    const lastSample = Math.floor((endTime) * sampleRate);\n                    const numberOfInterpolatedValues = lastSample - firstSample;\n                    const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n                    for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n                        const theoreticIndex = ((values.length - 1) / duration) * (((firstSample + i) / sampleRate) - startTime);\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        interpolatedValues[i] = (lowerIndex === upperIndex)\n                            ? values[lowerIndex]\n                            : ((1 - (theoreticIndex - lowerIndex)) * values[lowerIndex])\n                                + ((1 - (upperIndex - theoreticIndex)) * values[upperIndex]);\n                    }\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n                    const timeOfLastSample = lastSample / sampleRate;\n                    if (timeOfLastSample < endTime) {\n                        audioParam.setValueAtTime(interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n                    }\n                    audioParam.setValueAtTime(values[values.length - 1], endTime);\n                }\n                else {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(values, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(values, startTime, duration);\n                }\n                return audioParam;\n            }\n        };\n        audioParamStore.set(audioParam, nativeAudioParam);\n        audioParamAudioNodeStore.set(audioParam, audioNode);\n        addAudioParamConnections(audioParam, audioParamRenderer);\n        return audioParam;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-param-factory.js.map","export const createAudioParamRenderer = (automationEventList) => {\n    return {\n        replay(audioParam) {\n            for (const automationEvent of automationEventList) {\n                if (automationEvent.type === 'exponentialRampToValue') {\n                    const { endTime, value } = automationEvent;\n                    audioParam.exponentialRampToValueAtTime(value, endTime);\n                }\n                else if (automationEvent.type === 'linearRampToValue') {\n                    const { endTime, value } = automationEvent;\n                    audioParam.linearRampToValueAtTime(value, endTime);\n                }\n                else if (automationEvent.type === 'setTarget') {\n                    const { startTime, target, timeConstant } = automationEvent;\n                    audioParam.setTargetAtTime(target, startTime, timeConstant);\n                }\n                else if (automationEvent.type === 'setValue') {\n                    const { startTime, value } = automationEvent;\n                    audioParam.setValueAtTime(value, startTime);\n                }\n                else if (automationEvent.type === 'setValueCurve') {\n                    const { duration, startTime, values } = automationEvent;\n                    audioParam.setValueCurveAtTime(values, startTime, duration);\n                }\n                else {\n                    throw new Error(\"Can't apply an unknown automation.\");\n                }\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-param-renderer.js.map","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    outputChannelCount: undefined,\n    parameterData: {},\n    processorOptions: {}\n};\nconst createChannelCount = (length) => {\n    const channelCount = [];\n    for (let i = 0; i < length; i += 1) {\n        channelCount.push(1);\n    }\n    return channelCount;\n};\nconst sanitizedOptions = (options) => {\n    return {\n        ...options,\n        outputChannelCount: (options.outputChannelCount !== undefined) ?\n            options.outputChannelCount :\n            (options.numberOfInputs === 1 && options.numberOfOutputs === 1) ?\n                /*\n                 * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n                 * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n                 * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n                 */\n                [options.channelCount] :\n                createChannelCount(options.numberOfOutputs)\n    };\n};\nexport const createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, wrapEventListener) => {\n    return class AudioWorkletNode extends audioNodeConstructor {\n        constructor(context, name, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = (nodeNameToProcessorConstructorMap === undefined) ?\n                undefined :\n                nodeNameToProcessorConstructorMap.get(name);\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n            const audioWorkletNodeRenderer = ((isOffline)\n                ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor)\n                : null);\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n            const parameters = [];\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n                parameters.push([nm, audioParam]);\n            });\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n             * the destination.\n             */\n            if (isOffline) {\n                addUnrenderedAudioWorkletNode(nativeContext, this);\n            }\n        }\n        get onprocessorerror() {\n            return this._onprocessorerror;\n        }\n        set onprocessorerror(value) {\n            const wrappedListener = (typeof value === 'function')\n                ? wrapEventListener(this, value)\n                : null;\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n            this._onprocessorerror = (nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener)\n                ? value\n                : nativeOnProcessorError;\n        }\n        get parameters() {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return this._nativeAudioWorkletNode.parameters;\n            }\n            return this._parameters;\n        }\n        get port() {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-worklet-node-constructor.js.map","export const createBaseAudioContextConstructor = (addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor) => {\n    return class BaseAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(_nativeContext, numberOfChannels) {\n            super(_nativeContext, numberOfChannels);\n            this._nativeContext = _nativeContext;\n            this._audioWorklet = (addAudioWorkletModule === undefined) ?\n                undefined :\n                {\n                    addModule: (moduleURL, options) => {\n                        return addAudioWorkletModule(this, moduleURL, options);\n                    }\n                };\n        }\n        get audioWorklet() {\n            return this._audioWorklet;\n        }\n        createAnalyser() {\n            return new analyserNodeConstructor(this);\n        }\n        createBiquadFilter() {\n            return new biquadFilterNodeConstructor(this);\n        }\n        createBuffer(numberOfChannels, length, sampleRate) {\n            return new audioBufferConstructor({ length, numberOfChannels, sampleRate });\n        }\n        createBufferSource() {\n            return new audioBufferSourceNodeConstructor(this);\n        }\n        createChannelMerger(numberOfInputs = 6) {\n            return new channelMergerNodeConstructor(this, { numberOfInputs });\n        }\n        createChannelSplitter(numberOfOutputs = 6) {\n            return new channelSplitterNodeConstructor(this, { numberOfOutputs });\n        }\n        createConstantSource() {\n            return new constantSourceNodeConstructor(this);\n        }\n        createConvolver() {\n            return new convolverNodeConstructor(this);\n        }\n        createDelay(maxDelayTime = 1) {\n            return new delayNodeConstructor(this, { maxDelayTime });\n        }\n        createDynamicsCompressor() {\n            return new dynamicsCompressorNodeConstructor(this);\n        }\n        createGain() {\n            return new gainNodeConstructor(this);\n        }\n        createIIRFilter(feedforward, feedback) {\n            return new iIRFilterNodeConstructor(this, { feedback, feedforward });\n        }\n        createOscillator() {\n            return new oscillatorNodeConstructor(this);\n        }\n        createPanner() {\n            return new pannerNodeConstructor(this);\n        }\n        createPeriodicWave(real, imag, constraints = { disableNormalization: false }) {\n            return new periodicWaveConstructor(this, { ...constraints, imag, real });\n        }\n        createStereoPanner() {\n            return new stereoPannerNodeConstructor(this);\n        }\n        createWaveShaper() {\n            return new waveShaperNodeConstructor(this);\n        }\n        decodeAudioData(audioData, successCallback, errorCallback) {\n            return decodeAudioData(this._nativeContext, audioData)\n                .then((audioBuffer) => {\n                if (typeof successCallback === 'function') {\n                    successCallback(audioBuffer);\n                }\n                return audioBuffer;\n            })\n                .catch((err) => {\n                if (typeof errorCallback === 'function') {\n                    errorCallback(err);\n                }\n                throw err;\n            });\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/base-audio-context-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n    Q: 1,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    detune: 0,\n    frequency: 350,\n    gain: 0,\n    type: 'lowpass'\n};\nexport const createBiquadFilterNodeConstructor = (audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class BiquadFilterNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const biquadFilterNodeRenderer = ((isOffline) ? createBiquadFilterNodeRenderer() : null);\n            super(context, false, nativeBiquadFilterNode, biquadFilterNodeRenderer);\n            // Bug #80: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._Q = createAudioParam(this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // Bug #78: Edge, Firefox, Opera & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(this, isOffline, nativeBiquadFilterNode.detune, 1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT), -1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT));\n            /*\n             * Bug #77: Edge does not export the correct values for maxValue and minValue. Firefox & Safari do not export the correct value\n             * for minValue.\n             */\n            this._frequency = createAudioParam(this, isOffline, nativeBiquadFilterNode.frequency, context.sampleRate / 2, 0);\n            // Bug #79: Edge, Firefox, Opera & Safari do not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(this, isOffline, nativeBiquadFilterNode.gain, 40 * Math.log10(MOST_POSITIVE_SINGLE_FLOAT), MOST_NEGATIVE_SINGLE_FLOAT);\n            this._nativeBiquadFilterNode = nativeBiquadFilterNode;\n        }\n        get detune() {\n            return this._detune;\n        }\n        get frequency() {\n            return this._frequency;\n        }\n        get gain() {\n            return this._gain;\n        }\n        get Q() {\n            return this._Q;\n        }\n        get type() {\n            return this._nativeBiquadFilterNode.type;\n        }\n        set type(value) {\n            this._nativeBiquadFilterNode.type = value;\n        }\n        getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n            // Bug #68: Only Chrome, Firefox & Opera do throw an error if the parameters differ in their length.\n            if ((frequencyHz.length !== magResponse.length) || (magResponse.length !== phaseResponse.length)) {\n                throw createInvalidAccessError();\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/biquad-filter-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createBiquadFilterNodeRendererFactory = (connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeBiquadFilterNodes = new WeakMap();\n        const createBiquadFilterNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeBiquadFilterNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeBiquadFilterNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                const options = {\n                    Q: nativeBiquadFilterNode.Q.value,\n                    channelCount: nativeBiquadFilterNode.channelCount,\n                    channelCountMode: nativeBiquadFilterNode.channelCountMode,\n                    channelInterpretation: nativeBiquadFilterNode.channelInterpretation,\n                    detune: nativeBiquadFilterNode.detune.value,\n                    frequency: nativeBiquadFilterNode.frequency.value,\n                    gain: nativeBiquadFilterNode.gain.value,\n                    type: nativeBiquadFilterNode.type\n                };\n                nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode, trace);\n            return nativeBiquadFilterNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeBiquadFilterNode !== undefined) {\n                    return Promise.resolve(renderedNativeBiquadFilterNode);\n                }\n                return createBiquadFilterNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/biquad-filter-node-renderer-factory.js.map","export const createCacheTestResult = (ongoingTests, testResults) => {\n    return (tester, test) => {\n        const cachedTestResult = testResults.get(tester);\n        if (cachedTestResult !== undefined) {\n            return cachedTestResult;\n        }\n        const ongoingTest = ongoingTests.get(tester);\n        if (ongoingTest !== undefined) {\n            return ongoingTest;\n        }\n        try {\n            const synchronousTestResult = test();\n            if (synchronousTestResult instanceof Promise) {\n                ongoingTests.set(tester, synchronousTestResult);\n                return synchronousTestResult\n                    .catch(() => false)\n                    .then((finalTestResult) => {\n                    ongoingTests.delete(tester);\n                    testResults.set(tester, finalTestResult);\n                    return finalTestResult;\n                });\n            }\n            testResults.set(tester, synchronousTestResult);\n            return synchronousTestResult;\n        }\n        catch {\n            testResults.set(tester, false);\n            return false;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/cache-test-result.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 1,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 6\n};\nexport const createChannelMergerNodeConstructor = (audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class ChannelMergerNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeChannelMergerNode = createNativeChannelMergerNode(nativeContext, mergedOptions);\n            const channelMergerNodeRenderer = ((isNativeOfflineAudioContext(nativeContext))\n                ? createChannelMergerNodeRenderer()\n                : null);\n            super(context, false, nativeChannelMergerNode, channelMergerNodeRenderer);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/channel-merger-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createChannelMergerNodeRendererFactory = (createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAudioNodes = new WeakMap();\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfInputs: nativeAudioNode.numberOfInputs\n                };\n                nativeAudioNode = createNativeChannelMergerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode, trace);\n            return nativeAudioNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/channel-merger-node-renderer-factory.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 6,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'discrete',\n    numberOfOutputs: 6\n};\nconst sanitizedOptions = (options) => {\n    return { ...options, channelCount: options.numberOfOutputs };\n};\nexport const createChannelSplitterNodeConstructor = (audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class ChannelSplitterNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nativeChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, mergedOptions);\n            const channelSplitterNodeRenderer = ((isNativeOfflineAudioContext(nativeContext))\n                ? createChannelSplitterNodeRenderer()\n                : null);\n            super(context, false, nativeChannelSplitterNode, channelSplitterNodeRenderer);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/channel-splitter-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createChannelSplitterNodeRendererFactory = (createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAudioNodes = new WeakMap();\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfOutputs: nativeAudioNode.numberOfOutputs\n                };\n                nativeAudioNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode, trace);\n            return nativeAudioNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/channel-splitter-node-renderer-factory.js.map","export const createConnectAudioParam = (renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam, trace) => {\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam, trace);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/connect-audio-param.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const createConnectMultipleOutputs = (createIndexSizeError) => {\n    return (outputAudioNodes, destination, output = 0, input = 0) => {\n        const outputAudioNode = outputAudioNodes[output];\n        if (outputAudioNode === undefined) {\n            throw createIndexSizeError();\n        }\n        if (isNativeAudioNode(destination)) {\n            return outputAudioNode.connect(destination, 0, input);\n        }\n        return outputAudioNode.connect(destination, 0);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/connect-multiple-outputs.js.map","export const createConnectedNativeAudioBufferSourceNodeFactory = (createNativeAudioBufferSourceNode) => {\n    return (nativeContext, nativeAudioNode) => {\n        const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext);\n        const nativeAudioBuffer = nativeContext.createBuffer(1, 2, nativeContext.sampleRate);\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        nativeAudioBufferSourceNode.loop = true;\n        nativeAudioBufferSourceNode.connect(nativeAudioNode);\n        nativeAudioBufferSourceNode.start();\n        return () => {\n            nativeAudioBufferSourceNode.stop();\n            nativeAudioBufferSourceNode.disconnect(nativeAudioNode);\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/connected-native-audio-buffer-source-node-factory.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    offset: 1\n};\nexport const createConstantSourceNodeConstructor = (audioNodeConstructor, createAudioParam, createConstantSourceNodeRendererFactory, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n    return class ConstantSourceNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConstantSourceNode = createNativeConstantSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const constantSourceNodeRenderer = ((isOffline)\n                ? createConstantSourceNodeRendererFactory()\n                : null);\n            super(context, false, nativeConstantSourceNode, constantSourceNodeRenderer);\n            this._constantSourceNodeRenderer = constantSourceNodeRenderer;\n            this._nativeConstantSourceNode = nativeConstantSourceNode;\n            /*\n             * Bug #62 & #74: Edge & Safari do not support ConstantSourceNodes and do not export the correct values for maxValue and\n             * minValue for GainNodes.\n             */\n            this._offset = createAudioParam(this, isOffline, nativeConstantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._onended = null;\n        }\n        get offset() {\n            return this._offset;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = (typeof value === 'function') ? wrapEventListener(this, value) : null;\n            this._nativeConstantSourceNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeConstantSourceNode.onended;\n            this._onended = (nativeOnEnded !== null && nativeOnEnded === wrappedListener)\n                ? value\n                : nativeOnEnded;\n        }\n        start(when = 0) {\n            this._nativeConstantSourceNode.start(when);\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.start = when;\n            }\n            else {\n                setInternalStateToActive(this);\n                const resetInternalStateToPassive = () => {\n                    this._nativeConstantSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n                    // @todo Determine a meaningful delay instead of just using one second.\n                    setTimeout(() => setInternalStateToPassive(this), 1000);\n                };\n                this._nativeConstantSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeConstantSourceNode.stop(when);\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/constant-source-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createConstantSourceNodeRendererFactory = (connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeConstantSourceNodes = new WeakMap();\n        let start = null;\n        let stop = null;\n        const createConstantSourceNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeConstantSourceNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeConstantSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeConstantSourceNode.channelCount,\n                    channelCountMode: nativeConstantSourceNode.channelCountMode,\n                    channelInterpretation: nativeConstantSourceNode.channelInterpretation,\n                    offset: nativeConstantSourceNode.offset.value\n                };\n                nativeConstantSourceNode = createNativeConstantSourceNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeConstantSourceNode.start(start);\n                }\n                if (stop !== null) {\n                    nativeConstantSourceNode.stop(stop);\n                }\n            }\n            renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConstantSourceNode, trace);\n            return nativeConstantSourceNode;\n        };\n        return {\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeConstantSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeConstantSourceNode);\n                }\n                return createConstantSourceNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/constant-source-node-renderer-factory.js.map","export const createConvertNumberToUnsignedLong = (unit32Array) => {\n    return (value) => {\n        unit32Array[0] = value;\n        return unit32Array[0];\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/convert-number-to-unsigned-long.js.map","const DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    disableNormalization: false\n};\nexport const createConvolverNodeConstructor = (audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class ConvolverNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConvolverNode = createNativeConvolverNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const convolverNodeRenderer = ((isOffline) ? createConvolverNodeRenderer() : null);\n            super(context, false, nativeConvolverNode, convolverNodeRenderer);\n            this._isBufferNullified = false;\n            this._nativeConvolverNode = nativeConvolverNode;\n        }\n        get buffer() {\n            if (this._isBufferNullified) {\n                return null;\n            }\n            return this._nativeConvolverNode.buffer;\n        }\n        set buffer(value) {\n            this._nativeConvolverNode.buffer = value;\n            // Bug #115: Safari does not allow to set the buffer to null.\n            if (value === null && this._nativeConvolverNode.buffer !== null) {\n                const nativeContext = this._nativeConvolverNode.context;\n                this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);\n                this._isBufferNullified = true;\n            }\n            else {\n                this._isBufferNullified = false;\n            }\n        }\n        get normalize() {\n            return this._nativeConvolverNode.normalize;\n        }\n        set normalize(value) {\n            this._nativeConvolverNode.normalize = value;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/convolver-node-constructor.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createConvolverNodeRendererFactory = (createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeConvolverNodes = new WeakMap();\n        const createConvolverNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeConvolverNode = getNativeAudioNode(proxy);\n            // If the initially used nativeConvolverNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);\n            if (!nativeConvolverNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeConvolverNode.buffer,\n                    channelCount: nativeConvolverNode.channelCount,\n                    channelCountMode: nativeConvolverNode.channelCountMode,\n                    channelInterpretation: nativeConvolverNode.channelInterpretation,\n                    disableNormalization: !nativeConvolverNode.normalize\n                };\n                nativeConvolverNode = createNativeConvolverNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);\n            if (isNativeAudioNodeFaker(nativeConvolverNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0], trace);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode, trace);\n            }\n            return nativeConvolverNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeConvolverNode !== undefined) {\n                    return Promise.resolve(renderedNativeConvolverNode);\n                }\n                return createConvolverNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/convolver-node-renderer-factory.js.map","export const createCreateNativeOfflineAudioContext = (createNotSupportedError, nativeOfflineAudioContextConstructor) => {\n    return (numberOfChannels, length, sampleRate) => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n        try {\n            return new nativeOfflineAudioContextConstructor(numberOfChannels, length, sampleRate);\n        }\n        catch (err) {\n            // Bug #143, #144 & #146: Safari throws a SyntaxError when numberOfChannels, length or sampleRate are invalid.\n            // Bug #143: Edge throws a SyntaxError when numberOfChannels or length are invalid.\n            // Bug #145: Edge throws an IndexSizeError when sampleRate is zero.\n            if (err.name === 'IndexSizeError' || err.name === 'SyntaxError') {\n                throw createNotSupportedError();\n            }\n            throw err;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/create-native-offline-audio-context.js.map","export const createDataCloneError = () => {\n    try {\n        return new DOMException('', 'DataCloneError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 25;\n        err.name = 'DataCloneError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2019/factories/data-clone-error.js.map","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nexport const createDecrementCycleCounter = (connectNativeAudioNodeToNativeAudioNode, cycleCounters, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext) => {\n    return (audioNode, count) => {\n        const cycleCounter = cycleCounters.get(audioNode);\n        if (cycleCounter === undefined) {\n            throw new Error('Missing the expected cycle count.');\n        }\n        const nativeContext = getNativeContext(audioNode.context);\n        const isOffline = isNativeOfflineAudioContext(nativeContext);\n        if (cycleCounter === count) {\n            cycleCounters.delete(audioNode);\n            if (!isOffline && isActiveAudioNode(audioNode)) {\n                const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                const { outputs } = getAudioNodeConnections(audioNode);\n                for (const output of outputs) {\n                    if (isAudioNodeOutputConnection(output)) {\n                        const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n                        connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                    }\n                    else {\n                        const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n                        nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);\n                    }\n                }\n            }\n        }\n        else {\n            cycleCounters.set(audioNode, cycleCounter - count);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/decrement-cycle-counter.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    delayTime: 0,\n    maxDelayTime: 1\n};\nexport const createDelayNodeConstructor = (audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class DelayNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDelayNode = createNativeDelayNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const delayNodeRenderer = ((isOffline)\n                ? createDelayNodeRenderer(mergedOptions.maxDelayTime)\n                : null);\n            super(context, false, nativeDelayNode, delayNodeRenderer);\n            // Bug #161: Edge does not export the correct values for maxValue and minValue.\n            this._delayTime = createAudioParam(this, isOffline, nativeDelayNode.delayTime, mergedOptions.maxDelayTime, 0);\n        }\n        get delayTime() {\n            return this._delayTime;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/delay-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createDelayNodeRendererFactory = (connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return (maxDelayTime) => {\n        const renderedNativeDelayNodes = new WeakMap();\n        const createDelayNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeDelayNode = getNativeAudioNode(proxy);\n            // If the initially used nativeDelayNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);\n            if (!nativeDelayNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeDelayNode.channelCount,\n                    channelCountMode: nativeDelayNode.channelCountMode,\n                    channelInterpretation: nativeDelayNode.channelInterpretation,\n                    delayTime: nativeDelayNode.delayTime.value,\n                    maxDelayTime\n                };\n                nativeDelayNode = createNativeDelayNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);\n            if (!nativeDelayNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDelayNode, trace);\n            return nativeDelayNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeDelayNode !== undefined) {\n                    return Promise.resolve(renderedNativeDelayNode);\n                }\n                return createDelayNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/delay-node-renderer-factory.js.map","export const createDeleteUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext)\n            .delete(audioWorkletNode);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/delete-unrendered-audio-worklet-node.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nconst getOutputAudioNodeAtIndex = (createIndexSizeError, outputAudioNodes, output) => {\n    const outputAudioNode = outputAudioNodes[output];\n    if (outputAudioNode === undefined) {\n        throw createIndexSizeError();\n    }\n    return outputAudioNode;\n};\nexport const createDisconnectMultipleOutputs = (createIndexSizeError) => {\n    return (outputAudioNodes, destinationOrOutput = undefined, output = undefined, input = 0) => {\n        if (destinationOrOutput === undefined) {\n            return outputAudioNodes\n                .forEach((outputAudioNode) => outputAudioNode.disconnect());\n        }\n        if (typeof destinationOrOutput === 'number') {\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, destinationOrOutput)\n                .disconnect();\n        }\n        if (isNativeAudioNode(destinationOrOutput)) {\n            if (output === undefined) {\n                return outputAudioNodes\n                    .forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n            }\n            if (input === undefined) {\n                return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output)\n                    .disconnect(destinationOrOutput, 0);\n            }\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output)\n                .disconnect(destinationOrOutput, 0, input);\n        }\n        if (output === undefined) {\n            return outputAudioNodes\n                .forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n        }\n        return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output)\n            .disconnect(destinationOrOutput, 0);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/disconnect-multiple-outputs.js.map","const DEFAULT_OPTIONS = {\n    attack: 0.003,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    knee: 30,\n    ratio: 12,\n    release: 0.25,\n    threshold: -24\n};\nexport const createDynamicsCompressorNodeConstructor = (audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext) => {\n    return class DynamicsCompressorNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const dynamicsCompressorNodeRenderer = ((isOffline)\n                ? createDynamicsCompressorNodeRenderer()\n                : null);\n            super(context, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer);\n            // Bug #110: Edge does not export the correct values for maxValue and minValue.\n            this._attack = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.attack, 1, 0);\n            this._knee = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.knee, 40, 0);\n            this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;\n            this._ratio = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.ratio, 20, 1);\n            this._release = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.release, 1, 0);\n            this._threshold = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.threshold, 0, -100);\n        }\n        get attack() {\n            return this._attack;\n        }\n        /*\n         * Bug #108: Only Chrome, Firefox and Opera disallow a channelCount of three and above yet which is why the getter and setter needs\n         * to be overwritten here.\n         */\n        get channelCount() {\n            return this._nativeDynamicsCompressorNode.channelCount;\n        }\n        set channelCount(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;\n            this._nativeDynamicsCompressorNode.channelCount = value;\n            if (value > 2) {\n                this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;\n                throw createNotSupportedError();\n            }\n        }\n        /*\n         * Bug #109: Only Chrome, Firefox and Opera disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be\n         * overwritten here.\n         */\n        get channelCountMode() {\n            return this._nativeDynamicsCompressorNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;\n            this._nativeDynamicsCompressorNode.channelCountMode = value;\n            if (value === 'max') {\n                this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;\n                throw createNotSupportedError();\n            }\n        }\n        get knee() {\n            return this._knee;\n        }\n        get ratio() {\n            return this._ratio;\n        }\n        get reduction() {\n            // Bug #111: Safari returns an AudioParam instead of a number.\n            if (typeof this._nativeDynamicsCompressorNode.reduction.value === 'number') {\n                return this._nativeDynamicsCompressorNode.reduction.value;\n            }\n            return this._nativeDynamicsCompressorNode.reduction;\n        }\n        get release() {\n            return this._release;\n        }\n        get threshold() {\n            return this._threshold;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/dynamics-compressor-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createDynamicsCompressorNodeRendererFactory = (connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeDynamicsCompressorNodes = new WeakMap();\n        const createDynamicsCompressorNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeDynamicsCompressorNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeDynamicsCompressorNode was not constructed on the same OfflineAudioContext it needs to be\n             * created again.\n             */\n            const nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                const options = {\n                    attack: nativeDynamicsCompressorNode.attack.value,\n                    channelCount: nativeDynamicsCompressorNode.channelCount,\n                    channelCountMode: nativeDynamicsCompressorNode.channelCountMode,\n                    channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,\n                    knee: nativeDynamicsCompressorNode.knee.value,\n                    ratio: nativeDynamicsCompressorNode.ratio.value,\n                    release: nativeDynamicsCompressorNode.release.value,\n                    threshold: nativeDynamicsCompressorNode.threshold.value\n                };\n                nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode, trace);\n            return nativeDynamicsCompressorNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeDynamicsCompressorNode !== undefined) {\n                    return Promise.resolve(renderedNativeDynamicsCompressorNode);\n                }\n                return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/dynamics-compressor-node-renderer-factory.js.map","export const createEncodingError = () => {\n    try {\n        return new DOMException('', 'EncodingError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 0;\n        err.name = 'EncodingError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2019/factories/encoding-error.js.map","export const createEvaluateSource = (window) => {\n    return (source) => new Promise((resolve, reject) => {\n        if (window === null) {\n            reject(new SyntaxError());\n            return;\n        }\n        const head = window.document.head;\n        if (head === null) {\n            reject(new SyntaxError());\n        }\n        else {\n            const script = window.document.createElement('script');\n            // @todo Safari doesn't like URLs with a type of 'application/javascript; charset=utf-8'.\n            const blob = new Blob([source], { type: 'application/javascript' });\n            const url = URL.createObjectURL(blob);\n            const originalOnErrorHandler = window.onerror;\n            const removeErrorEventListenerAndRevokeUrl = () => {\n                window.onerror = originalOnErrorHandler;\n                URL.revokeObjectURL(url);\n            };\n            window.onerror = (message, src, lineno, colno, error) => {\n                // @todo Edge thinks the source is the one of the html document.\n                if (src === url || (src === window.location.href && lineno === 1 && colno === 1)) {\n                    removeErrorEventListenerAndRevokeUrl();\n                    reject(error);\n                    return false;\n                }\n                if (originalOnErrorHandler !== null) {\n                    return originalOnErrorHandler(message, src, lineno, colno, error);\n                }\n            };\n            script.onerror = () => {\n                removeErrorEventListenerAndRevokeUrl();\n                reject(new SyntaxError());\n            };\n            script.onload = () => {\n                removeErrorEventListenerAndRevokeUrl();\n                resolve();\n            };\n            script.src = url;\n            script.type = 'module';\n            head.appendChild(script);\n        }\n    });\n};\n//# sourceMappingURL=/build/es2019/factories/evaluate-source.js.map","export const createEventTargetConstructor = (wrapEventListener) => {\n    return class EventTarget {\n        constructor(_nativeEventTarget) {\n            this._nativeEventTarget = _nativeEventTarget;\n            this._listeners = new WeakMap();\n        }\n        addEventListener(type, listener, options) {\n            if (listener !== null) {\n                let wrappedEventListener = this._listeners.get(listener);\n                if (wrappedEventListener === undefined) {\n                    wrappedEventListener = wrapEventListener(this, listener);\n                    if (typeof listener === 'function') {\n                        this._listeners.set(listener, wrappedEventListener);\n                    }\n                }\n                this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n            }\n        }\n        dispatchEvent(event) {\n            return this._nativeEventTarget.dispatchEvent(event);\n        }\n        removeEventListener(type, listener, options) {\n            const wrappedEventListener = (listener === null) ? undefined : this._listeners.get(listener);\n            this._nativeEventTarget.removeEventListener(type, (wrappedEventListener === undefined) ? null : wrappedEventListener, options);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/event-target-constructor.js.map","export const createExposeCurrentFrameAndCurrentTime = (window) => {\n    return (currentTime, sampleRate, fn) => {\n        Object.defineProperties(window, {\n            currentFrame: {\n                configurable: true,\n                get() {\n                    return Math.round(currentTime * sampleRate);\n                }\n            },\n            currentTime: {\n                configurable: true,\n                get() {\n                    return currentTime;\n                }\n            }\n        });\n        try {\n            return fn();\n        }\n        finally {\n            if (window !== null) {\n                delete window.currentFrame;\n                delete window.currentTime;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/expose-current-frame-and-current-time.js.map","export const createFetchSource = (createAbortError) => {\n    return async (url) => {\n        try {\n            const response = await fetch(url);\n            if (response.ok) {\n                return response.text();\n            }\n        }\n        catch { /* Ignore errors. */ } // tslint:disable-line:no-empty\n        throw createAbortError();\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/fetch-source.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    gain: 1\n};\nexport const createGainNodeConstructor = (audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class GainNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeGainNode = createNativeGainNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const gainNodeRenderer = ((isOffline) ? createGainNodeRenderer() : null);\n            super(context, false, nativeGainNode, gainNodeRenderer);\n            // Bug #74: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get gain() {\n            return this._gain;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/gain-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createGainNodeRendererFactory = (connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeGainNodes = new WeakMap();\n        const createGainNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeGainNode = getNativeAudioNode(proxy);\n            // If the initially used nativeGainNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);\n            if (!nativeGainNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeGainNode.channelCount,\n                    channelCountMode: nativeGainNode.channelCountMode,\n                    channelInterpretation: nativeGainNode.channelInterpretation,\n                    gain: nativeGainNode.gain.value\n                };\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);\n            if (!nativeGainNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeGainNode, trace);\n            return nativeGainNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNode);\n                }\n                return createGainNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/gain-node-renderer-factory.js.map","export const createGetAudioNodeRenderer = (getAudioNodeConnections) => {\n    return (audioNode) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n        if (audioNodeConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioNode in the audio graph.');\n        }\n        return audioNodeConnections.renderer;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/get-audio-node-renderer.js.map","export const createGetAudioParamRenderer = (getAudioParamConnections) => {\n    return (audioParam) => {\n        const audioParamConnections = getAudioParamConnections(audioParam);\n        if (audioParamConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioParam in the audio graph.');\n        }\n        return audioParamConnections.renderer;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/get-audio-param-renderer.js.map","import { BACKUP_NATIVE_CONTEXT_STORE } from '../globals';\nexport const createGetBackupNativeContext = (isNativeOfflineAudioContext, nativeAudioContextConstructor, nativeOfflineAudioContextConstructor) => {\n    return (nativeContext) => {\n        /*\n         * Bug #50: Only Edge does currently not allow to create AudioNodes on a closed context yet which is why there needs to be no\n         * backupNativeContext in that case.\n         */\n        if (nativeContext.state === 'closed'\n            && nativeAudioContextConstructor !== null\n            && nativeAudioContextConstructor.name !== 'webkitAudioContext') {\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                const backupNativeContext = BACKUP_NATIVE_CONTEXT_STORE.get(nativeContext);\n                if (backupNativeContext !== undefined) {\n                    return backupNativeContext;\n                }\n                if (nativeOfflineAudioContextConstructor !== null) {\n                    // @todo Copy the attached AudioWorkletProcessors and other settings.\n                    const bckpNtveCntxt = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n                    BACKUP_NATIVE_CONTEXT_STORE.set(nativeContext, bckpNtveCntxt);\n                    return bckpNtveCntxt;\n                }\n            }\n            else {\n                const backupNativeContext = BACKUP_NATIVE_CONTEXT_STORE.get(nativeContext);\n                if (backupNativeContext !== undefined) {\n                    return backupNativeContext;\n                }\n                // @todo Copy the attached AudioWorkletProcessors and other settings.\n                const bckpNtveCntxt = new nativeAudioContextConstructor();\n                BACKUP_NATIVE_CONTEXT_STORE.set(nativeContext, bckpNtveCntxt);\n                return bckpNtveCntxt;\n            }\n        }\n        return null;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/get-backup-native-context.js.map","import { createInvalidStateError } from './invalid-state-error';\nexport const createGetNativeContext = (contextStore) => {\n    return (context) => {\n        const nativeContext = contextStore.get(context);\n        if (nativeContext === undefined) {\n            throw createInvalidStateError();\n        }\n        return nativeContext;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/get-native-context.js.map","export const createGetUnrenderedAudioWorkletNodes = (unrenderedAudioWorkletNodeStore) => {\n    return (nativeContext) => {\n        const unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore.get(nativeContext);\n        if (unrenderedAudioWorkletNodes === undefined) {\n            throw new Error('The context has no set of AudioWorkletNodes.');\n        }\n        return unrenderedAudioWorkletNodes;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/get-unrendered-audio-worklet-nodes.js.map","import { filterBuffer } from '../helpers/filter-buffer';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {\n    const feedbackLength = feedback.length;\n    const feedforwardLength = feedforward.length;\n    const minLength = Math.min(feedbackLength, feedforwardLength);\n    if (feedback[0] !== 1) {\n        for (let i = 0; i < feedbackLength; i += 1) {\n            feedforward[i] /= feedback[0];\n        }\n        for (let i = 1; i < feedforwardLength; i += 1) {\n            feedback[i] /= feedback[0];\n        }\n    }\n    const bufferLength = 32;\n    const xBuffer = new Float32Array(bufferLength);\n    const yBuffer = new Float32Array(bufferLength);\n    const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);\n    const numberOfChannels = renderedBuffer.numberOfChannels;\n    for (let i = 0; i < numberOfChannels; i += 1) {\n        const input = renderedBuffer.getChannelData(i);\n        const output = filteredBuffer.getChannelData(i);\n        xBuffer.fill(0);\n        yBuffer.fill(0);\n        filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);\n    }\n    return filteredBuffer;\n};\nexport const createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode, createNativeAudioNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (feedback, feedforward) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let filteredBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioBufferSourceNode = null;\n            let nativeIIRFilterNode = getNativeAudioNode(proxy);\n            // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext);\n            // Bug #9: Safari does not support IIRFilterNodes.\n            if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);\n            }\n            else if (!nativeIIRFilterNodeIsOwnedByContext) {\n                nativeIIRFilterNode = createNativeAudioNode(nativeOfflineAudioContext, (ntvCntxt) => {\n                    return ntvCntxt.createIIRFilter(feedforward, feedback);\n                });\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, (nativeAudioBufferSourceNode === null) ? nativeIIRFilterNode : nativeAudioBufferSourceNode);\n            if (nativeAudioBufferSourceNode !== null) {\n                if (filteredBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                    // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n                    proxy.context.destination.channelCount, \n                    // Bug #17: Safari does not yet expose the length.\n                    proxy.context.length, nativeOfflineAudioContext.sampleRate);\n                    filteredBufferPromise = (async () => {\n                        await renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination, trace);\n                        const renderedBuffer = await renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                        return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);\n                    })();\n                }\n                const filteredBuffer = await filteredBufferPromise;\n                nativeAudioBufferSourceNode.buffer = filteredBuffer;\n                nativeAudioBufferSourceNode.start(0);\n                return nativeAudioBufferSourceNode;\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode, trace);\n            return nativeIIRFilterNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/iir-filter-node-renderer-factory.js.map","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nexport const createIncrementCycleCounterFactory = (cycleCounters, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode) => {\n    return (isOffline) => {\n        return (audioNode, count) => {\n            const cycleCounter = cycleCounters.get(audioNode);\n            if (cycleCounter === undefined) {\n                if (!isOffline && isActiveAudioNode(audioNode)) {\n                    const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                    const { outputs } = getAudioNodeConnections(audioNode);\n                    for (const output of outputs) {\n                        if (isAudioNodeOutputConnection(output)) {\n                            const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n                            disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                        }\n                        else {\n                            const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n                            nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);\n                        }\n                    }\n                }\n                cycleCounters.set(audioNode, count);\n            }\n            else {\n                cycleCounters.set(audioNode, cycleCounter + count);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/increment-cycle-counter-factory.js.map","export const createIsAnyAudioContext = (contextStore, isNativeAudioContext) => {\n    return (anything) => {\n        const nativeContext = contextStore.get(anything);\n        return isNativeAudioContext(nativeContext) || isNativeAudioContext(anything);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/is-any-audio-context.js.map","export const createIsAnyAudioNode = (audioNodeStore, isNativeAudioNode) => {\n    return (anything) => audioNodeStore.has(anything) || isNativeAudioNode(anything);\n};\n//# sourceMappingURL=/build/es2019/factories/is-any-audio-node.js.map","export const createIsAnyAudioParam = (audioParamStore, isNativeAudioParam) => {\n    return (anything) => audioParamStore.has(anything) || isNativeAudioParam(anything);\n};\n//# sourceMappingURL=/build/es2019/factories/is-any-audio-param.js.map","export const createIsAnyOfflineAudioContext = (contextStore, isNativeOfflineAudioContext) => {\n    return (anything) => {\n        const nativeContext = contextStore.get(anything);\n        return isNativeOfflineAudioContext(nativeContext) || isNativeOfflineAudioContext(anything);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/is-any-offline-audio-context.js.map","export const createIsNativeAudioContext = (nativeAudioContextConstructor) => {\n    return (anything) => {\n        return (nativeAudioContextConstructor !== null && anything instanceof nativeAudioContextConstructor);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/is-native-audio-context.js.map","export const createIsNativeAudioNode = (window) => {\n    return (anything) => {\n        return (window !== null && typeof window.AudioNode === 'function' && anything instanceof window.AudioNode);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/is-native-audio-node.js.map","export const createIsNativeAudioParam = (window) => {\n    return (anything) => {\n        return (window !== null && typeof window.AudioParam === 'function' && anything instanceof window.AudioParam);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/is-native-audio-param.js.map","export const createIsNativeContext = (isNativeAudioContext, isNativeOfflineAudioContext) => {\n    return (anything) => {\n        return (isNativeAudioContext(anything) || isNativeOfflineAudioContext(anything));\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/is-native-context.js.map","export const createIsNativeOfflineAudioContext = (nativeOfflineAudioContextConstructor) => {\n    return (anything) => {\n        return (nativeOfflineAudioContextConstructor !== null && anything instanceof nativeOfflineAudioContextConstructor);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/is-native-offline-audio-context.js.map","export const createIsSecureContext = (window) => (window !== null && window.isSecureContext);\n//# sourceMappingURL=/build/es2019/factories/is-secure-context.js.map","export const createIsSupportedPromise = async (cacheTestResult, testAudioBufferCopyChannelMethodsSubarraySupport, testAudioContextCloseMethodSupport, testAudioContextDecodeAudioDataMethodTypeErrorSupport, testAudioContextOptionsSupport, testAudioNodeConnectMethodSupport, testAudioWorkletProcessorNoOutputsSupport, testChannelMergerNodeChannelCountSupport, testConstantSourceNodeAccurateSchedulingSupport, testConvolverNodeBufferReassignabilitySupport, testIsSecureContextSupport, testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport, testStereoPannerNodeDefaultValueSupport, testTransferablesSupport) => {\n    if (cacheTestResult(testAudioBufferCopyChannelMethodsSubarraySupport, testAudioBufferCopyChannelMethodsSubarraySupport)\n        && cacheTestResult(testAudioContextCloseMethodSupport, testAudioContextCloseMethodSupport)\n        && cacheTestResult(testAudioContextOptionsSupport, testAudioContextOptionsSupport)\n        && cacheTestResult(testAudioNodeConnectMethodSupport, testAudioNodeConnectMethodSupport)\n        && cacheTestResult(testChannelMergerNodeChannelCountSupport, testChannelMergerNodeChannelCountSupport)\n        && cacheTestResult(testConstantSourceNodeAccurateSchedulingSupport, testConstantSourceNodeAccurateSchedulingSupport)\n        && cacheTestResult(testConvolverNodeBufferReassignabilitySupport, testConvolverNodeBufferReassignabilitySupport)\n        && cacheTestResult(testIsSecureContextSupport, testIsSecureContextSupport)\n        && cacheTestResult(testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport, testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport)) {\n        const results = await Promise\n            .all([\n            cacheTestResult(testAudioContextDecodeAudioDataMethodTypeErrorSupport, testAudioContextDecodeAudioDataMethodTypeErrorSupport),\n            cacheTestResult(testAudioWorkletProcessorNoOutputsSupport, testAudioWorkletProcessorNoOutputsSupport),\n            cacheTestResult(testStereoPannerNodeDefaultValueSupport, testStereoPannerNodeDefaultValueSupport),\n            cacheTestResult(testTransferablesSupport, testTransferablesSupport)\n        ]);\n        return results.every((result) => result);\n    }\n    return false;\n};\n//# sourceMappingURL=/build/es2019/factories/is-supported-promise.js.map","export const createMediaElementAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class MediaElementAudioSourceNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode(nativeContext, options);\n            // Bug #171: Safari allows to create a MediaElementAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw TypeError();\n            }\n            super(context, true, nativeMediaElementAudioSourceNode, null);\n            // Bug #63: Edge does not expose the mediaElement yet.\n            this._mediaElement = options.mediaElement;\n            this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;\n        }\n        get mediaElement() {\n            return (this._nativeMediaElementAudioSourceNode.mediaElement === undefined) ?\n                this._mediaElement :\n                this._nativeMediaElementAudioSourceNode.mediaElement;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/media-element-audio-source-node-constructor.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers'\n};\nexport const createMediaStreamAudioDestinationNodeConstructor = (audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class MediaStreamAudioDestinationNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            // Bug #173: Safari allows to create a MediaStreamAudioDestinationNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw new TypeError();\n            }\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode(nativeContext, mergedOptions);\n            super(context, false, nativeMediaStreamAudioDestinationNode, null);\n            this._nativeMediaStreamAudioDestinationNode = nativeMediaStreamAudioDestinationNode;\n        }\n        get stream() {\n            return this._nativeMediaStreamAudioDestinationNode.stream;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/media-stream-audio-destination-node-constructor.js.map","export const createMediaStreamAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class MediaStreamAudioSourceNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode(nativeContext, options);\n            // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw new TypeError();\n            }\n            super(context, true, nativeMediaStreamAudioSourceNode, null);\n            this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;\n        }\n        get mediaStream() {\n            return this._nativeMediaStreamAudioSourceNode.mediaStream;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/media-stream-audio-source-node-constructor.js.map","export const createMediaStreamTrackAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext) => {\n    return class MediaStreamTrackAudioSourceNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode(nativeContext, options);\n            super(context, true, nativeMediaStreamTrackAudioSourceNode, null);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/media-stream-track-audio-source-node-constructor.js.map","import { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nexport const createMinimalAudioContextConstructor = (createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor) => {\n    return class MinimalAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(options = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n            const nativeAudioContext = new nativeAudioContextConstructor(options);\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n            // Bug #51 Only Chrome and Opera throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);\n            }\n            // Bug #150 Only Chrome, Firefox and Opera support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n            super(nativeAudioContext, 2);\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency = (typeof nativeAudioContext.baseLatency === 'number')\n                ? nativeAudioContext.baseLatency\n                : (latencyHint === 'balanced')\n                    ? (512 / sampleRate)\n                    : (latencyHint === 'interactive' || latencyHint === undefined)\n                        ? (256 / sampleRate)\n                        : (latencyHint === 'playback')\n                            ? (1024 / sampleRate)\n                            /*\n                             * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                             * ScriptProcessorNode.\n                             */\n                            : ((Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate);\n            this._nativeAudioContext = nativeAudioContext;\n            this._state = null;\n            /*\n             * Bug #34: Chrome and Opera pretend to be running right away, but fire an onstatechange event when the state actually\n             * changes to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n        get baseLatency() {\n            return this._baseLatency;\n        }\n        get state() {\n            return (this._state !== null) ? this._state : this._nativeAudioContext.state;\n        }\n        close() {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext\n                    .close()\n                    .then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n            return this._nativeAudioContext.close();\n            /*\n             * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n             * ...then(() => deleteAudioGraph(this, this._nativeAudioContext));\n             */\n        }\n        resume() {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        }\n                        else {\n                            this\n                                .resume()\n                                .then(resolve, reject);\n                        }\n                    };\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n            return this._nativeAudioContext\n                .resume()\n                .catch((err) => {\n                // Bug #55: Chrome, Edge and Opera do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n                throw err;\n            });\n        }\n        suspend() {\n            return this._nativeAudioContext\n                .suspend()\n                .catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n                throw err;\n            });\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/minimal-audio-context-constructor.js.map","import { CONTEXT_STORE } from '../globals';\nexport const createMinimalBaseAudioContextConstructor = (audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener) => {\n    return class MinimalBaseAudioContext extends eventTargetConstructor {\n        constructor(_nativeContext, numberOfChannels) {\n            super(_nativeContext);\n            this._nativeContext = _nativeContext;\n            CONTEXT_STORE.set(this, _nativeContext);\n            // Bug #93: Edge will set the sampleRate of an AudioContext to zero when it is closed.\n            const sampleRate = _nativeContext.sampleRate;\n            Object.defineProperty(_nativeContext, 'sampleRate', {\n                get: () => sampleRate\n            });\n            if (isNativeOfflineAudioContext(_nativeContext)) {\n                unrenderedAudioWorkletNodeStore.set(_nativeContext, new Set());\n            }\n            this._destination = new audioDestinationNodeConstructor(this, numberOfChannels);\n            this._listener = createAudioListener(this, _nativeContext);\n            this._onstatechange = null;\n        }\n        get currentTime() {\n            return this._nativeContext.currentTime;\n        }\n        get destination() {\n            return this._destination;\n        }\n        get listener() {\n            return this._listener;\n        }\n        get onstatechange() {\n            return this._onstatechange;\n        }\n        set onstatechange(value) {\n            const wrappedListener = (typeof value === 'function') ? wrapEventListener(this, value) : null;\n            this._nativeContext.onstatechange = wrappedListener;\n            const nativeOnStateChange = this._nativeContext.onstatechange;\n            this._onstatechange = (nativeOnStateChange !== null && nativeOnStateChange === wrappedListener)\n                ? value\n                : nativeOnStateChange;\n        }\n        get sampleRate() {\n            return this._nativeContext.sampleRate;\n        }\n        get state() {\n            return this._nativeContext.state;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/minimal-base-audio-context-constructor.js.map","import { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createMinimalOfflineAudioContextConstructor = (cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering) => {\n    return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(options) {\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener('statechange', (() => {\n                    let i = 0;\n                    const delayStateChangeEvent = (event) => {\n                        if (this._state === 'running') {\n                            if (i > 0) {\n                                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                event.stopImmediatePropagation();\n                                this._waitForThePromiseToSettle(event);\n                            }\n                            else {\n                                i += 1;\n                            }\n                        }\n                    };\n                    return delayStateChangeEvent;\n                })());\n            }\n            super(nativeOfflineAudioContext, numberOfChannels);\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n        get length() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n        }\n        get state() {\n            return (this._state === null) ? this._nativeOfflineAudioContext.state : this._state;\n        }\n        startRendering() {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return startRendering(this.destination, this._nativeOfflineAudioContext)\n                .then((audioBuffer) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                return audioBuffer;\n            })\n                // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n                .catch((err) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                throw err;\n            });\n        }\n        _waitForThePromiseToSettle(event) {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            }\n            else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/minimal-offline-audio-context-constructor.js.map","export const createMonitorConnections = (insertElementInSet, isNativeAudioNode) => {\n    return (nativeAudioNode, whenConnected, whenDisconnected) => {\n        const connections = new Set();\n        nativeAudioNode.connect = ((connect) => {\n            return (destination, output = 0, input = 0) => {\n                const wasDisconnected = connections.size === 0;\n                if (isNativeAudioNode(destination)) {\n                    // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                    connect.call(nativeAudioNode, destination, output, input);\n                    insertElementInSet(connections, [destination, output, input], (connection) => (connection[0] === destination && connection[1] === output && connection[2] === input), true);\n                    if (wasDisconnected) {\n                        whenConnected();\n                    }\n                    return destination;\n                }\n                connect.call(nativeAudioNode, destination, output);\n                insertElementInSet(connections, [destination, output], (connection) => (connection[0] === destination && connection[1] === output), true);\n                if (wasDisconnected) {\n                    whenConnected();\n                }\n                return;\n            };\n        })(nativeAudioNode.connect);\n        nativeAudioNode.disconnect = ((disconnect) => {\n            return (destinationOrOutput, output, input) => {\n                const wasConnected = connections.size > 0;\n                if (destinationOrOutput === undefined) {\n                    disconnect.apply(nativeAudioNode);\n                    connections.clear();\n                }\n                else if (typeof destinationOrOutput === 'number') {\n                    // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n                    disconnect.call(nativeAudioNode, destinationOrOutput);\n                    for (const connection of connections) {\n                        if (connection[1] === destinationOrOutput) {\n                            connections.delete(connection);\n                        }\n                    }\n                }\n                else {\n                    if (isNativeAudioNode(destinationOrOutput)) {\n                        // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                        disconnect.call(nativeAudioNode, destinationOrOutput, output, input);\n                    }\n                    else {\n                        // @todo TypeScript cannot infer the overloaded signature with 2 arguments yet.\n                        disconnect.call(nativeAudioNode, destinationOrOutput, output);\n                    }\n                    for (const connection of connections) {\n                        if (connection[0] === destinationOrOutput\n                            && (output === undefined || connection[1] === output)\n                            && (input === undefined || connection[2] === input)) {\n                            connections.delete(connection);\n                        }\n                    }\n                }\n                const isDisconnected = connections.size === 0;\n                if (wasConnected && isDisconnected) {\n                    whenDisconnected();\n                }\n            };\n        })(nativeAudioNode.disconnect);\n        return nativeAudioNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/monitor-connections.js.map","export const createNativeAudioBufferConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('AudioBuffer')) {\n        return window.AudioBuffer;\n    }\n    return null;\n};\n//# sourceMappingURL=/build/es2019/factories/native-audio-buffer-constructor.js.map","export const createNativeAudioContextConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('AudioContext')) {\n        return window.AudioContext;\n    }\n    return (window.hasOwnProperty('webkitAudioContext')) ? window.webkitAudioContext : null;\n};\n//# sourceMappingURL=/build/es2019/factories/native-audio-context-constructor.js.map","export const createNativeAudioDestinationNodeFactory = (createNativeGainNode, overwriteAccessors) => {\n    return (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {\n        const nativeAudioDestinationNode = nativeContext.destination;\n        // Bug #132: Edge & Safari do not have the correct channelCount.\n        if (nativeAudioDestinationNode.channelCount !== channelCount) {\n            try {\n                nativeAudioDestinationNode.channelCount = channelCount;\n            }\n            catch {\n                // Bug #169: Safari throws an error on each attempt to change the channelCount.\n            }\n        }\n        // Bug #83: Edge & Safari do not have the correct channelCountMode.\n        if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== 'explicit') {\n            nativeAudioDestinationNode.channelCountMode = 'explicit';\n        }\n        // Bug #47: The AudioDestinationNode in Edge and Safari does not initialize the maxChannelCount property correctly.\n        if (nativeAudioDestinationNode.maxChannelCount === 0) {\n            Object.defineProperty(nativeAudioDestinationNode, 'maxChannelCount', {\n                value: channelCount\n            });\n        }\n        // Bug #168: No browser does yet have an AudioDestinationNode with an output.\n        const gainNode = createNativeGainNode(nativeContext, {\n            channelCount,\n            channelCountMode: nativeAudioDestinationNode.channelCountMode,\n            channelInterpretation: nativeAudioDestinationNode.channelInterpretation,\n            gain: 1\n        });\n        overwriteAccessors(gainNode, 'channelCount', (get) => () => get.call(gainNode), (set) => (value) => {\n            set.call(gainNode, value);\n            try {\n                nativeAudioDestinationNode.channelCount = value;\n            }\n            catch (err) {\n                // Bug #169: Safari throws an error on each attempt to change the channelCount.\n                if (value > nativeAudioDestinationNode.maxChannelCount) {\n                    throw err;\n                }\n            }\n        });\n        overwriteAccessors(gainNode, 'channelCountMode', (get) => () => get.call(gainNode), (set) => (value) => {\n            set.call(gainNode, value);\n            nativeAudioDestinationNode.channelCountMode = value;\n        });\n        overwriteAccessors(gainNode, 'channelInterpretation', (get) => () => get.call(gainNode), (set) => (value) => {\n            set.call(gainNode, value);\n            nativeAudioDestinationNode.channelInterpretation = value;\n        });\n        Object.defineProperty(gainNode, 'maxChannelCount', {\n            get: () => nativeAudioDestinationNode.maxChannelCount\n        });\n        // @todo This should be disconnected when the context is closed.\n        gainNode.connect(nativeAudioDestinationNode);\n        return gainNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-audio-destination-node.js.map","export const createNativeAudioNodeFactory = (getBackupNativeContext) => {\n    return (nativeContext, factoryFunction) => {\n        // Bug #50: Only Edge does currently not allow to create AudioNodes on a closed context yet.\n        const backupNativeContext = getBackupNativeContext(nativeContext);\n        if (backupNativeContext !== null) {\n            return factoryFunction(backupNativeContext);\n        }\n        return factoryFunction(nativeContext);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-audio-node-factory.js.map","export const createNativeAudioWorkletNodeConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    return (window.hasOwnProperty('AudioWorkletNode')) ? window.AudioWorkletNode : null;\n};\n//# sourceMappingURL=/build/es2019/factories/native-audio-worklet-node-constructor.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeBiquadFilterNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeBiquadFilterNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBiquadFilter());\n        assignNativeAudioNodeOptions(nativeBiquadFilterNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'Q');\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'detune');\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'frequency');\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'gain');\n        assignNativeAudioNodeOption(nativeBiquadFilterNode, options, 'type');\n        return nativeBiquadFilterNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-biquad-filter-node-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeChannelMergerNodeFactory = (createNativeAudioNode, wrapChannelMergerNode) => {\n    return (nativeContext, options) => {\n        const nativeChannelMergerNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createChannelMerger(options.numberOfInputs);\n        });\n        // Bug #15: Safari does not return the default properties.\n        if (nativeChannelMergerNode.channelCount !== 1 &&\n            nativeChannelMergerNode.channelCountMode !== 'explicit') {\n            wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n        }\n        assignNativeAudioNodeOptions(nativeChannelMergerNode, options);\n        return nativeChannelMergerNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-channel-merger-node-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeConstantSourceNodeFactory = (addSilentConnection, cacheTestResult, createNativeAudioNode, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport) => {\n    return (nativeContext, options) => {\n        // Bug #62: Edge & Safari do not support ConstantSourceNodes.\n        if (nativeContext.createConstantSource === undefined) {\n            return createNativeConstantSourceNodeFaker(nativeContext, options);\n        }\n        const nativeConstantSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createConstantSource();\n        });\n        assignNativeAudioNodeOptions(nativeConstantSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, 'offset');\n        // Bug #44: Only Chrome, Firefox & Opera throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the ConstantSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeConstantSourceNode);\n        return nativeConstantSourceNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-constant-source-node-factory.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeConstantSourceNodeFakerFactory = (addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections) => {\n    return (nativeContext, { offset, ...audioNodeOptions }) => {\n        const audioBuffer = nativeContext.createBuffer(1, 2, nativeContext.sampleRate);\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext);\n        const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: offset });\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        const channelData = audioBuffer.getChannelData(0);\n        // Bug #95: Safari does not play or loop one sample buffers.\n        channelData[0] = 1;\n        channelData[1] = 1;\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.loop = true;\n        const nativeConstantSourceNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return gainNode.channelCount;\n            },\n            set channelCount(value) {\n                gainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return gainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                gainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return gainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                gainNode.channelInterpretation = value;\n            },\n            get context() {\n                return gainNode.context;\n            },\n            get inputs() {\n                return [];\n            },\n            get numberOfInputs() {\n                return audioBufferSourceNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return gainNode.numberOfOutputs;\n            },\n            get offset() {\n                return gainNode.gain;\n            },\n            get onended() {\n                return audioBufferSourceNode.onended;\n            },\n            set onended(value) {\n                audioBufferSourceNode.onended = value;\n            },\n            addEventListener(...args) {\n                return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return audioBufferSourceNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n            },\n            start(when = 0) {\n                audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n            },\n            stop(when = 0) {\n                audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n            }\n        };\n        const whenConnected = () => audioBufferSourceNode.connect(gainNode);\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode);\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, audioBufferSourceNode);\n        return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-constant-source-node-faker-factory.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeConvolverNodeFactory = (createNativeAudioNode, createNativeConvolverNodeFaker, createNotSupportedError, overwriteAccessors) => {\n    return (nativeContext, options) => {\n        const nativeConvolverNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createConvolver());\n        try {\n            // Bug #166: Opera does not allow yet to set the channelCount to 1.\n            nativeConvolverNode.channelCount = 1;\n        }\n        catch (err) {\n            return createNativeConvolverNodeFaker(nativeContext, options);\n        }\n        assignNativeAudioNodeOptions(nativeConvolverNode, options);\n        // The normalize property needs to be set before setting the buffer.\n        if (options.disableNormalization === nativeConvolverNode.normalize) {\n            nativeConvolverNode.normalize = !options.disableNormalization;\n        }\n        assignNativeAudioNodeOption(nativeConvolverNode, options, 'buffer');\n        // Bug #113: Edge & Safari allow to set the channelCount to a value larger than 2.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n        overwriteAccessors(nativeConvolverNode, 'channelCount', (get) => () => get.call(nativeConvolverNode), (set) => (value) => {\n            if (value > 2) {\n                throw createNotSupportedError();\n            }\n            return set.call(nativeConvolverNode, value);\n        });\n        // Bug #114: Edge & Safari allow to set the channelCountMode to 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        overwriteAccessors(nativeConvolverNode, 'channelCountMode', (get) => () => get.call(nativeConvolverNode), (set) => (value) => {\n            if (value === 'max') {\n                throw createNotSupportedError();\n            }\n            return set.call(nativeConvolverNode, value);\n        });\n        return nativeConvolverNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-convolver-node-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeConvolverNodeFakerFactory = (createNativeAudioNode, createNativeGainNode, monitorConnections) => {\n    return (nativeContext, { buffer, channelCount, channelCountMode, channelInterpretation, disableNormalization }) => {\n        const convolverNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createConvolver());\n        assignNativeAudioNodeOptions(convolverNode, {\n            // Bug #166: Opera does not allow yet to set the channelCount to 1.\n            channelCount: Math.max(channelCount, 2),\n            // Bug #167: Opera does not allow yet to set the channelCountMode to 'explicit'.\n            channelCountMode: (channelCountMode === 'max') ? channelCountMode : 'clamped-max',\n            channelInterpretation\n        });\n        const gainNode = createNativeGainNode(nativeContext, { channelCount, channelCountMode, channelInterpretation, gain: 1 });\n        const nativeConvolverNodeFaker = {\n            get buffer() {\n                return convolverNode.buffer;\n            },\n            set buffer(value) {\n                convolverNode.buffer = value;\n            },\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return gainNode.channelCount;\n            },\n            set channelCount(value) {\n                // Bug #166: Opera does not allow yet to set the channelCount to 1.\n                if (value > 2) {\n                    convolverNode.channelCount = value;\n                }\n                gainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return gainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                // Bug #167: Opera does not allow yet to set the channelCountMode to 'explicit'.\n                if (value === 'max') {\n                    convolverNode.channelCountMode = value;\n                }\n                gainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return convolverNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                convolverNode.channelInterpretation = value;\n                gainNode.channelInterpretation = value;\n            },\n            get context() {\n                return convolverNode.context;\n            },\n            get inputs() {\n                return [convolverNode];\n            },\n            get numberOfInputs() {\n                return convolverNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return convolverNode.numberOfOutputs;\n            },\n            get normalize() {\n                return convolverNode.normalize;\n            },\n            set normalize(value) {\n                convolverNode.normalize = value;\n            },\n            addEventListener(...args) {\n                return convolverNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return convolverNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return convolverNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        // The normalize property needs to be set before setting the buffer.\n        if (disableNormalization === nativeConvolverNodeFaker.normalize) {\n            nativeConvolverNodeFaker.normalize = !disableNormalization;\n        }\n        if (buffer !== nativeConvolverNodeFaker.buffer) {\n            nativeConvolverNodeFaker.buffer = buffer;\n        }\n        const whenConnected = () => convolverNode.connect(gainNode);\n        const whenDisconnected = () => convolverNode.disconnect(gainNode);\n        return monitorConnections(interceptConnections(nativeConvolverNodeFaker, gainNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-convolver-node-faker-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeDelayNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeDelayNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createDelay(options.maxDelayTime));\n        assignNativeAudioNodeOptions(nativeDelayNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeDelayNode, options, 'delayTime');\n        return nativeDelayNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-delay-node-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeDynamicsCompressorNodeFactory = (createNativeAudioNode, createNotSupportedError) => {\n    return (nativeContext, options) => {\n        const nativeDynamicsCompressorNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createDynamicsCompressor());\n        assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options);\n        // Bug #108: Only Chrome, Firefox and Opera disallow a channelCount of three and above yet.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n        // Bug #109: Only Chrome, Firefox and Opera disallow a channelCountMode of 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'attack');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'knee');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'ratio');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'release');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'threshold');\n        return nativeDynamicsCompressorNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-dynamics-compressor-node-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeGainNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeGainNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createGain());\n        assignNativeAudioNodeOptions(nativeGainNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeGainNode, options, 'gain');\n        return nativeGainNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-gain-node-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeIIRFilterNodeFactory = (createNativeAudioNode, createNativeIIRFilterNodeFaker) => {\n    return (nativeContext, baseLatency, options) => {\n        // Bug #9: Safari does not support IIRFilterNodes.\n        if (nativeContext.createIIRFilter === undefined) {\n            return createNativeIIRFilterNodeFaker(nativeContext, baseLatency, options);\n        }\n        const nativeIIRFilterNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createIIRFilter(options.feedforward, options.feedback);\n        });\n        assignNativeAudioNodeOptions(nativeIIRFilterNode, options);\n        return nativeIIRFilterNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-iir-filter-node-factory.js.map","import { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { filterBuffer } from '../helpers/filter-buffer';\nimport { interceptConnections } from '../helpers/intercept-connections';\nfunction divide(a, b) {\n    const denominator = (b[0] * b[0]) + (b[1] * b[1]);\n    return [(((a[0] * b[0]) + (a[1] * b[1])) / denominator), (((a[1] * b[0]) - (a[0] * b[1])) / denominator)];\n}\nfunction multiply(a, b) {\n    return [((a[0] * b[0]) - (a[1] * b[1])), ((a[0] * b[1]) + (a[1] * b[0]))];\n}\nfunction evaluatePolynomial(coefficient, z) {\n    let result = [0, 0];\n    for (let i = coefficient.length - 1; i >= 0; i -= 1) {\n        result = multiply(result, z);\n        result[0] += coefficient[i];\n    }\n    return result;\n}\nexport const createNativeIIRFilterNodeFakerFactory = (createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError) => {\n    return (nativeContext, baseLatency, { channelCount, channelCountMode, channelInterpretation, feedback, feedforward }) => {\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const feedbackLength = feedback.length;\n        const feedforwardLength = feedforward.length;\n        const minLength = Math.min(feedbackLength, feedforwardLength);\n        if (feedback.length === 0 || feedback.length > 20) {\n            throw createNotSupportedError();\n        }\n        if (feedback[0] === 0) {\n            throw createInvalidStateError();\n        }\n        if (feedforward.length === 0 || feedforward.length > 20) {\n            throw createNotSupportedError();\n        }\n        if (feedforward[0] === 0) {\n            throw createInvalidStateError();\n        }\n        if (feedback[0] !== 1) {\n            for (let i = 0; i < feedforwardLength; i += 1) {\n                feedforward[i] /= feedback[0];\n            }\n            for (let i = 1; i < feedbackLength; i += 1) {\n                feedback[i] /= feedback[0];\n            }\n        }\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, channelCount, channelCount);\n        scriptProcessorNode.channelCount = channelCount;\n        scriptProcessorNode.channelCountMode = channelCountMode;\n        scriptProcessorNode.channelInterpretation = channelInterpretation;\n        const bufferLength = 32;\n        const bufferIndexes = [];\n        const xBuffers = [];\n        const yBuffers = [];\n        for (let i = 0; i < channelCount; i += 1) {\n            bufferIndexes.push(0);\n            const xBuffer = new Float32Array(bufferLength);\n            const yBuffer = new Float32Array(bufferLength);\n            xBuffer.fill(0);\n            yBuffer.fill(0);\n            xBuffers.push(xBuffer);\n            yBuffers.push(yBuffer);\n        }\n        scriptProcessorNode.onaudioprocess = (event) => {\n            const inputBuffer = event.inputBuffer;\n            const outputBuffer = event.outputBuffer;\n            const numberOfChannels = inputBuffer.numberOfChannels;\n            for (let i = 0; i < numberOfChannels; i += 1) {\n                const input = inputBuffer.getChannelData(i);\n                const output = outputBuffer.getChannelData(i);\n                bufferIndexes[i] = filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffers[i], yBuffers[i], bufferIndexes[i], bufferLength, input, output);\n            }\n        };\n        const nyquist = nativeContext.sampleRate / 2;\n        const nativeIIRFilterNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return scriptProcessorNode.channelCount;\n            },\n            set channelCount(value) {\n                scriptProcessorNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return scriptProcessorNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                scriptProcessorNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return scriptProcessorNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                scriptProcessorNode.channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return [scriptProcessorNode];\n            },\n            get numberOfInputs() {\n                return scriptProcessorNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return scriptProcessorNode.numberOfOutputs;\n            },\n            addEventListener(...args) {\n                // @todo Dissallow adding an audioprocess listener.\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n                if ((frequencyHz.length !== magResponse.length) || (magResponse.length !== phaseResponse.length)) {\n                    throw createInvalidAccessError();\n                }\n                const length = frequencyHz.length;\n                for (let i = 0; i < length; i += 1) {\n                    const omega = -Math.PI * (frequencyHz[i] / nyquist);\n                    const z = [Math.cos(omega), Math.sin(omega)];\n                    const numerator = evaluatePolynomial(feedforward, z);\n                    const denominator = evaluatePolynomial(feedback, z);\n                    const response = divide(numerator, denominator);\n                    magResponse[i] = Math.sqrt((response[0] * response[0]) + (response[1] * response[1]));\n                    phaseResponse[i] = Math.atan2(response[1], response[0]);\n                }\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-iir-filter-node-faker-factory.js.map","export const createNativeMediaElementAudioSourceNodeFactory = (createNativeAudioNode) => {\n    return (nativeAudioContext, options) => createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => {\n        return ntvDCntxt.createMediaElementSource(options.mediaElement);\n    });\n};\n//# sourceMappingURL=/build/es2019/factories/native-media-element-audio-source-node-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeMediaStreamAudioDestinationNodeFactory = (createNativeAudioNode, createNotSupportedError) => {\n    return (nativeAudioContext, options) => {\n        // Bug #64: Edge does not support MediaStreamAudioDestinationNodes.\n        if (nativeAudioContext.createMediaStreamDestination === undefined) {\n            throw createNotSupportedError();\n        }\n        const nativeMediaStreamAudioDestinationNode = createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => {\n            return ntvDCntxt.createMediaStreamDestination();\n        });\n        assignNativeAudioNodeOptions(nativeMediaStreamAudioDestinationNode, options);\n        // Bug #174: Safari does expose a wrong numberOfOutputs.\n        if (nativeMediaStreamAudioDestinationNode.numberOfOutputs === 1) {\n            Object.defineProperty(nativeMediaStreamAudioDestinationNode, 'numberOfOutputs', { get: () => 0 });\n        }\n        return nativeMediaStreamAudioDestinationNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-media-stream-audio-destination-node-factory.js.map","export const createNativeMediaStreamAudioSourceNodeFactory = (createNativeAudioNode) => {\n    return (nativeAudioContext, { mediaStream }) => {\n        const audioStreamTracks = mediaStream.getAudioTracks();\n        const nativeMediaStreamAudioSourceNode = createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => {\n            /*\n             * Bug #151: Safari does not use the audio track as input anymore if it gets removed from the mediaStream after construction.\n             * Bug #159: Safari picks the first audio track if the MediaStream has more than one audio track.\n             */\n            const filteredAudioStreamTracks = audioStreamTracks\n                .sort((a, b) => ((a.id < b.id) ? -1 : (a.id > b.id) ? 1 : 0))\n                .slice(0, 1);\n            return ntvDCntxt.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));\n        });\n        // Bug #63: Edge does not expose the mediaStream yet.\n        Object.defineProperty(nativeMediaStreamAudioSourceNode, 'mediaStream', { value: mediaStream });\n        return nativeMediaStreamAudioSourceNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-media-stream-audio-source-node-factory.js.map","export const createNativeMediaStreamTrackAudioSourceNodeFactory = (createInvalidStateError, createNativeAudioNode, isNativeOfflineAudioContext) => {\n    return (nativeAudioContext, { mediaStreamTrack }) => {\n        if (typeof nativeAudioContext.createMediaStreamTrackSource === 'function') {\n            return createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => ntvDCntxt.createMediaStreamTrackSource(mediaStreamTrack));\n        }\n        // Bug #121: Only Firefox does yet support the MediaStreamTrackAudioSourceNode.\n        return createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => {\n            const mediaStream = new MediaStream([mediaStreamTrack]);\n            const nativeMediaStreamAudioSourceNode = ntvDCntxt.createMediaStreamSource(mediaStream);\n            // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.\n            if (mediaStreamTrack.kind !== 'audio') {\n                throw createInvalidStateError();\n            }\n            // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(ntvDCntxt)) {\n                throw new TypeError();\n            }\n            return nativeMediaStreamAudioSourceNode;\n        });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-media-stream-track-audio-source-node-factory.js.map","export const createNativeOfflineAudioContextConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('OfflineAudioContext')) {\n        return window.OfflineAudioContext;\n    }\n    return (window.hasOwnProperty('webkitOfflineAudioContext')) ? window.webkitOfflineAudioContext : null;\n};\n//# sourceMappingURL=/build/es2019/factories/native-offline-audio-context-constructor.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeOscillatorNodeFactory = (addSilentConnection, cacheTestResult, createNativeAudioNode, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n    return (nativeContext, options) => {\n        const nativeOscillatorNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createOscillator());\n        assignNativeAudioNodeOptions(nativeOscillatorNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'detune');\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'frequency');\n        if (options.periodicWave !== undefined) {\n            nativeOscillatorNode.setPeriodicWave(options.periodicWave);\n        }\n        else {\n            assignNativeAudioNodeOption(nativeOscillatorNode, options, 'type');\n        }\n        // Bug #44: Only Chrome & Opera throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeOscillatorNode, nativeContext);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the OscillatorNode is unconnected.\n        addSilentConnection(nativeContext, nativeOscillatorNode);\n        return nativeOscillatorNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-oscillator-node-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativePannerNodeFactory = (createNativeAudioNode, createNativePannerNodeFaker) => {\n    return (nativeContext, options) => {\n        const nativePannerNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createPanner());\n        // Bug #124: Edge & Safari do not support modifying the orientation and the position with AudioParams.\n        if (nativePannerNode.orientationX === undefined) {\n            return createNativePannerNodeFaker(nativeContext, options);\n        }\n        assignNativeAudioNodeOptions(nativePannerNode, options);\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationZ');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionZ');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneInnerAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterGain');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'distanceModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'maxDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'panningModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'refDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'rolloffFactor');\n        return nativePannerNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-panner-node-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativePannerNodeFakerFactory = (connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeAudioNode, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, monitorConnections) => {\n    return (nativeContext, { coneInnerAngle, coneOuterAngle, coneOuterGain, distanceModel, maxDistance, orientationX, orientationY, orientationZ, panningModel, positionX, positionY, positionZ, refDistance, rolloffFactor, ...audioNodeOptions }) => {\n        const pannerNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createPanner());\n        // Bug #125: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n        // Bug #126: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);\n        const SINGLE_CHANNEL_OPTIONS = {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete'\n        };\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, channelInterpretation: 'speakers', numberOfInputs: 6 });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const orientationXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 1 });\n        const orientationYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const orientationZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 6, 1);\n        const waveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, curve: new Float32Array([1, 1]), oversample: 'none' });\n        let lastOrientation = [orientationX, orientationY, orientationZ];\n        let lastPosition = [positionX, positionY, positionZ];\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n            const orientation = [\n                inputBuffer.getChannelData(0)[0],\n                inputBuffer.getChannelData(1)[0],\n                inputBuffer.getChannelData(2)[0]\n            ];\n            if (orientation.some((value, index) => (value !== lastOrientation[index]))) {\n                pannerNode.setOrientation(...orientation); // tslint:disable-line:deprecation\n                lastOrientation = orientation;\n            }\n            const positon = [\n                inputBuffer.getChannelData(3)[0],\n                inputBuffer.getChannelData(4)[0],\n                inputBuffer.getChannelData(5)[0]\n            ];\n            if (positon.some((value, index) => (value !== lastPosition[index]))) {\n                pannerNode.setPosition(...positon); // tslint:disable-line:deprecation\n                lastPosition = positon;\n            }\n        };\n        Object.defineProperty(orientationYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(orientationZGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionXGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionZGainNode.gain, 'defaultValue', { get: () => 0 });\n        const nativePannerNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return pannerNode.channelCount;\n            },\n            set channelCount(value) {\n                // Bug #125: Safari does not throw an error yet.\n                if (value > 2) {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCount = value;\n                pannerNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return pannerNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                // Bug #126: Safari does not throw an error yet.\n                if (value === 'max') {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCountMode = value;\n                pannerNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return pannerNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                pannerNode.channelInterpretation = value;\n            },\n            get coneInnerAngle() {\n                return pannerNode.coneInnerAngle;\n            },\n            set coneInnerAngle(value) {\n                pannerNode.coneInnerAngle = value;\n            },\n            get coneOuterAngle() {\n                return pannerNode.coneOuterAngle;\n            },\n            set coneOuterAngle(value) {\n                pannerNode.coneOuterAngle = value;\n            },\n            get coneOuterGain() {\n                return pannerNode.coneOuterGain;\n            },\n            set coneOuterGain(value) {\n                // Bug #127: Edge & Safari do not throw an InvalidStateError yet.\n                if (value < 0 || value > 1) {\n                    throw createInvalidStateError();\n                }\n                pannerNode.coneOuterGain = value;\n            },\n            get context() {\n                return pannerNode.context;\n            },\n            get distanceModel() {\n                return pannerNode.distanceModel;\n            },\n            set distanceModel(value) {\n                pannerNode.distanceModel = value;\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get maxDistance() {\n                return pannerNode.maxDistance;\n            },\n            set maxDistance(value) {\n                // Bug #128: Edge & Safari do not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.maxDistance = value;\n            },\n            get numberOfInputs() {\n                return pannerNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return pannerNode.numberOfOutputs;\n            },\n            get orientationX() {\n                return orientationXGainNode.gain;\n            },\n            get orientationY() {\n                return orientationYGainNode.gain;\n            },\n            get orientationZ() {\n                return orientationZGainNode.gain;\n            },\n            get panningModel() {\n                return pannerNode.panningModel;\n            },\n            set panningModel(value) {\n                pannerNode.panningModel = value;\n                // Bug #123: Edge does not support HRTF as panningModel.\n                if (pannerNode.panningModel !== value && value === 'HRTF') {\n                    throw createNotSupportedError();\n                }\n            },\n            get positionX() {\n                return positionXGainNode.gain;\n            },\n            get positionY() {\n                return positionYGainNode.gain;\n            },\n            get positionZ() {\n                return positionZGainNode.gain;\n            },\n            get refDistance() {\n                return pannerNode.refDistance;\n            },\n            set refDistance(value) {\n                // Bug #129: Edge & Safari do not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.refDistance = value;\n            },\n            get rolloffFactor() {\n                return pannerNode.rolloffFactor;\n            },\n            set rolloffFactor(value) {\n                // Bug #130: Edge & Safari do not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.rolloffFactor = value;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {\n            nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;\n        }\n        if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {\n            nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;\n        }\n        if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {\n            nativePannerNodeFaker.coneOuterGain = coneOuterGain;\n        }\n        if (distanceModel !== nativePannerNodeFaker.distanceModel) {\n            nativePannerNodeFaker.distanceModel = distanceModel;\n        }\n        if (maxDistance !== nativePannerNodeFaker.maxDistance) {\n            nativePannerNodeFaker.maxDistance = maxDistance;\n        }\n        if (orientationX !== nativePannerNodeFaker.orientationX.value) {\n            nativePannerNodeFaker.orientationX.value = orientationX;\n        }\n        if (orientationY !== nativePannerNodeFaker.orientationY.value) {\n            nativePannerNodeFaker.orientationY.value = orientationY;\n        }\n        if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {\n            nativePannerNodeFaker.orientationZ.value = orientationZ;\n        }\n        if (panningModel !== nativePannerNodeFaker.panningModel) {\n            nativePannerNodeFaker.panningModel = panningModel;\n        }\n        if (positionX !== nativePannerNodeFaker.positionX.value) {\n            nativePannerNodeFaker.positionX.value = positionX;\n        }\n        if (positionY !== nativePannerNodeFaker.positionY.value) {\n            nativePannerNodeFaker.positionY.value = positionY;\n        }\n        if (positionZ !== nativePannerNodeFaker.positionZ.value) {\n            nativePannerNodeFaker.positionZ.value = positionZ;\n        }\n        if (refDistance !== nativePannerNodeFaker.refDistance) {\n            nativePannerNodeFaker.refDistance = refDistance;\n        }\n        if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {\n            nativePannerNodeFaker.rolloffFactor = rolloffFactor;\n        }\n        if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {\n            pannerNode.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n        }\n        if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {\n            pannerNode.setPosition(...lastPosition); // tslint:disable-line:deprecation\n        }\n        const whenConnected = () => {\n            inputGainNode.connect(pannerNode);\n            // Bug #119: Safari does not fully support the WaveShaperNode.\n            connectNativeAudioNodeToNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n            waveShaperNode\n                .connect(orientationXGainNode)\n                .connect(channelMergerNode, 0, 0);\n            waveShaperNode\n                .connect(orientationYGainNode)\n                .connect(channelMergerNode, 0, 1);\n            waveShaperNode\n                .connect(orientationZGainNode)\n                .connect(channelMergerNode, 0, 2);\n            waveShaperNode\n                .connect(positionXGainNode)\n                .connect(channelMergerNode, 0, 3);\n            waveShaperNode\n                .connect(positionYGainNode)\n                .connect(channelMergerNode, 0, 4);\n            waveShaperNode\n                .connect(positionZGainNode)\n                .connect(channelMergerNode, 0, 5);\n            channelMergerNode\n                .connect(scriptProcessorNode)\n                .connect(nativeContext.destination);\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(pannerNode);\n            // Bug #119: Safari does not fully support the WaveShaperNode.\n            disconnectNativeAudioNodeFromNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n            waveShaperNode.disconnect(orientationXGainNode);\n            orientationXGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(orientationYGainNode);\n            orientationYGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(orientationZGainNode);\n            orientationZGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionXGainNode);\n            positionXGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionYGainNode);\n            positionYGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionZGainNode);\n            positionZGainNode.disconnect(channelMergerNode);\n            channelMergerNode.disconnect(scriptProcessorNode);\n            scriptProcessorNode.disconnect(nativeContext.destination);\n        };\n        return monitorConnections(interceptConnections(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-panner-node-faker-factory.js.map","export const createNativePeriodicWaveFactory = (getBackupNativeContext) => {\n    return (nativeContext, { disableNormalization, imag, real }) => {\n        // Bug #50: Only Edge does currently not allow to create AudioNodes (and other objects) on a closed context yet.\n        const backupNativeContext = getBackupNativeContext(nativeContext);\n        // @todo Edge, Firefox & Safari do only accept Float32Arrays.\n        const wrappedImag = new Float32Array(imag);\n        const wrappedReal = new Float32Array(real);\n        if (backupNativeContext !== null) {\n            return backupNativeContext.createPeriodicWave(wrappedReal, wrappedImag, { disableNormalization });\n        }\n        return nativeContext.createPeriodicWave(wrappedReal, wrappedImag, { disableNormalization });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-periodic-wave-factory.js.map","export const createNativeScriptProcessorNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) => {\n        return createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels);\n        });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-script-processor-node-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeStereoPannerNodeFactory = (createNativeAudioNode, createNativeStereoPannerNodeFaker, createNotSupportedError) => {\n    return (nativeContext, options) => createNativeAudioNode(nativeContext, (ntvCntxt) => {\n        const channelCountMode = options.channelCountMode;\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        if (channelCountMode === 'clamped-max') {\n            throw createNotSupportedError();\n        }\n        // Bug #105: Safari does not support the StereoPannerNode.\n        if (nativeContext.createStereoPanner === undefined) {\n            return createNativeStereoPannerNodeFaker(nativeContext, options);\n        }\n        const nativeStereoPannerNode = ntvCntxt.createStereoPanner();\n        assignNativeAudioNodeOptions(nativeStereoPannerNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options, 'pan');\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        Object.defineProperty(nativeStereoPannerNode, 'channelCountMode', {\n            get: () => channelCountMode,\n            set: (value) => {\n                if (value !== channelCountMode) {\n                    throw createNotSupportedError();\n                }\n            }\n        });\n        return nativeStereoPannerNode;\n    });\n};\n//# sourceMappingURL=/build/es2019/factories/native-stereo-panner-node-factory.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeStereoPannerNodeFakerFactory = (createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections) => {\n    // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n    const CURVE_SIZE = 16385;\n    const DC_CURVE = new Float32Array([1, 1]);\n    const HALF_PI = Math.PI / 2;\n    const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete' };\n    const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS, oversample: 'none' };\n    const buildInternalGraphForMono = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n        const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            const x = (i / (CURVE_SIZE - 1)) * HALF_PI;\n            leftWaveShaperCurve[i] = Math.cos(x);\n            rightWaveShaperCurve[i] = Math.sin(x);\n        }\n        const leftGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftWaveShaperCurve });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE });\n        const rightGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightWaveShaperCurve });\n        return {\n            connectGraph() {\n                inputGainNode.connect(leftGainNode);\n                inputGainNode.connect(panWaveShaperNode.inputs[0]);\n                inputGainNode.connect(rightGainNode);\n                panWaveShaperNode.connect(panGainNode);\n                panGainNode.connect(leftWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightWaveShaperNode.inputs[0]);\n                leftWaveShaperNode.connect(leftGainNode.gain);\n                rightWaveShaperNode.connect(rightGainNode.gain);\n                leftGainNode.connect(channelMergerNode, 0, 0);\n                rightGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph() {\n                inputGainNode.disconnect(leftGainNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs[0]);\n                inputGainNode.disconnect(rightGainNode);\n                panWaveShaperNode.disconnect(panGainNode);\n                panGainNode.disconnect(leftWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightWaveShaperNode.inputs[0]);\n                leftWaveShaperNode.disconnect(leftGainNode.gain);\n                rightWaveShaperNode.disconnect(rightGainNode.gain);\n                leftGainNode.disconnect(channelMergerNode, 0, 0);\n                rightGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n    const buildInternalGraphForStereo = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n        const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const centerIndex = Math.floor(CURVE_SIZE / 2);\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            if (i > centerIndex) {\n                const x = ((i - centerIndex) / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n                leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n                rightInputForLeftOutputWaveShaperCurve[i] = 0;\n                rightInputForRightOutputWaveShaperCurve[i] = 1;\n            }\n            else {\n                const x = (i / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n                leftInputForLeftOutputWaveShaperCurve[i] = 1;\n                leftInputForRightOutputWaveShaperCurve[i] = 0;\n                rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n            }\n        }\n        const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: 2,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: 2\n        });\n        const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftInputForLeftOutputWaveShaperCurve });\n        const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftInputForRightOutputWaveShaperCurve });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE });\n        const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightInputForLeftOutputWaveShaperCurve });\n        const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightInputForRightOutputWaveShaperCurve });\n        return {\n            connectGraph() {\n                inputGainNode.connect(channelSplitterNode);\n                inputGainNode.connect(panWaveShaperNode.inputs[0]);\n                channelSplitterNode.connect(leftInputForLeftOutputGainNode, 1);\n                channelSplitterNode.connect(leftInputForRightOutputGainNode, 1);\n                channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n                panWaveShaperNode.connect(panGainNode);\n                panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs[0]);\n                leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n                leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n                leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph() {\n                inputGainNode.disconnect(channelSplitterNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs[0]);\n                channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 1);\n                channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 1);\n                channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);\n                panWaveShaperNode.disconnect(panGainNode);\n                panGainNode.disconnect(leftInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(leftInputForRightOutputWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightInputForRightOutputWaveShaperNode.inputs[0]);\n                leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);\n                leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n                leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n    const buildInternalGraph = (nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) => {\n        if (channelCount === 1) {\n            return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        if (channelCount === 2) {\n            return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        throw createNotSupportedError();\n    };\n    return (nativeContext, { channelCount, channelCountMode, pan, ...audioNodeOptions }) => {\n        if (channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...audioNodeOptions,\n            channelCount: 1,\n            channelCountMode,\n            numberOfInputs: 2\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, channelCount, channelCountMode, gain: 1 });\n        const panGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: pan\n        });\n        let { connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode);\n        Object.defineProperty(panGainNode.gain, 'defaultValue', { get: () => 0 });\n        const nativeStereoPannerNodeFakerFactory = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return inputGainNode.channelCount;\n            },\n            set channelCount(value) {\n                if (inputGainNode.channelCount !== value) {\n                    if (isConnected) {\n                        disconnectGraph();\n                    }\n                    ({ connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode));\n                    if (isConnected) {\n                        connectGraph();\n                    }\n                }\n                inputGainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return inputGainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                if (value === 'clamped-max' || value === 'max') {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return inputGainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n            },\n            get context() {\n                return inputGainNode.context;\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get numberOfInputs() {\n                return inputGainNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return inputGainNode.numberOfOutputs;\n            },\n            get pan() {\n                return panGainNode.gain;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        let isConnected = false;\n        const whenConnected = () => {\n            connectGraph();\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            disconnectGraph();\n            isConnected = false;\n        };\n        return monitorConnections(interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-stereo-panner-node-faker-factory.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeWaveShaperNodeFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, overwriteAccessors) => {\n    return (nativeContext, options) => {\n        const nativeWaveShaperNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createWaveShaper());\n        try {\n            // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n            // Bug #119: Safari does not correctly map the values. Bug #102 is only used to detect Safari in this case.\n            nativeWaveShaperNode.curve = new Float32Array([1]);\n            return createNativeWaveShaperNodeFaker(nativeContext, options);\n        }\n        catch { /* Ignore errors. */ }\n        assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n        const curve = options.curve;\n        // Bug #104: Chrome will throw an InvalidAccessError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n            throw createInvalidStateError();\n        }\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'curve');\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n        let disconnectNativeAudioBufferSourceNode = null;\n        let isConnected = false;\n        overwriteAccessors(nativeWaveShaperNode, 'curve', (get) => () => get.call(nativeWaveShaperNode), (set) => (value) => {\n            set.call(nativeWaveShaperNode, value);\n            if (isConnected) {\n                if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n                    disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n                }\n                else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n                    disconnectNativeAudioBufferSourceNode();\n                    disconnectNativeAudioBufferSourceNode = null;\n                }\n            }\n            return value;\n        });\n        const whenConnected = () => {\n            isConnected = true;\n            if (isDCCurve(nativeWaveShaperNode.curve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n            }\n        };\n        const whenDisconnected = () => {\n            isConnected = false;\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n        return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-wave-shaper-node-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeWaveShaperNodeFakerFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeGainNode, isDCCurve, monitorConnections) => {\n    return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {\n        const negativeWaveShaperNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createWaveShaper());\n        const positiveWaveShaperNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createWaveShaper());\n        assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n        assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        let disconnectNativeAudioBufferSourceNode = null;\n        let isConnected = false;\n        let unmodifiedCurve = null;\n        const nativeWaveShaperNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return negativeWaveShaperNode.channelCount;\n            },\n            set channelCount(value) {\n                inputGainNode.channelCount = value;\n                invertGainNode.channelCount = value;\n                negativeWaveShaperNode.channelCount = value;\n                outputGainNode.channelCount = value;\n                positiveWaveShaperNode.channelCount = value;\n                revertGainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return negativeWaveShaperNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                inputGainNode.channelCountMode = value;\n                invertGainNode.channelCountMode = value;\n                negativeWaveShaperNode.channelCountMode = value;\n                outputGainNode.channelCountMode = value;\n                positiveWaveShaperNode.channelCountMode = value;\n                revertGainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return negativeWaveShaperNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                invertGainNode.channelInterpretation = value;\n                negativeWaveShaperNode.channelInterpretation = value;\n                outputGainNode.channelInterpretation = value;\n                positiveWaveShaperNode.channelInterpretation = value;\n                revertGainNode.channelInterpretation = value;\n            },\n            get context() {\n                return negativeWaveShaperNode.context;\n            },\n            get curve() {\n                return unmodifiedCurve;\n            },\n            set curve(value) {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                if (curve !== null && curve.length < 2) {\n                    throw createInvalidStateError();\n                }\n                if (value === null) {\n                    negativeWaveShaperNode.curve = value;\n                    positiveWaveShaperNode.curve = value;\n                }\n                else {\n                    const curveLength = value.length;\n                    const negativeCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    const positiveCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    negativeCurve[0] = value[0];\n                    positiveCurve[0] = -value[curveLength - 1];\n                    const length = Math.ceil((curveLength + 1) / 2);\n                    const centerIndex = ((curveLength + 1) / 2) - 1;\n                    for (let i = 1; i < length; i += 1) {\n                        const theoreticIndex = (i / length) * centerIndex;\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        negativeCurve[i] = (lowerIndex === upperIndex)\n                            ? value[lowerIndex]\n                            : ((1 - (theoreticIndex - lowerIndex)) * value[lowerIndex])\n                                + ((1 - (upperIndex - theoreticIndex)) * value[upperIndex]);\n                        positiveCurve[i] = (lowerIndex === upperIndex)\n                            ? -value[curveLength - 1 - lowerIndex]\n                            : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex])\n                                - ((1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex]);\n                    }\n                    negativeCurve[length] = (curveLength % 2 === 1) ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n                    negativeWaveShaperNode.curve = negativeCurve;\n                    positiveWaveShaperNode.curve = positiveCurve;\n                }\n                unmodifiedCurve = value;\n                if (isConnected) {\n                    if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n                        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n                    }\n                    else if (disconnectNativeAudioBufferSourceNode !== null) {\n                        disconnectNativeAudioBufferSourceNode();\n                        disconnectNativeAudioBufferSourceNode = null;\n                    }\n                }\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get numberOfInputs() {\n                return negativeWaveShaperNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return negativeWaveShaperNode.numberOfOutputs;\n            },\n            get oversample() {\n                return negativeWaveShaperNode.oversample;\n            },\n            set oversample(value) {\n                negativeWaveShaperNode.oversample = value;\n                positiveWaveShaperNode.oversample = value;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        if (curve !== nativeWaveShaperNodeFaker.curve) {\n            nativeWaveShaperNodeFaker.curve = curve;\n        }\n        if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n            nativeWaveShaperNodeFaker.oversample = oversample;\n        }\n        const whenConnected = () => {\n            inputGainNode\n                .connect(negativeWaveShaperNode)\n                .connect(outputGainNode);\n            inputGainNode\n                .connect(invertGainNode)\n                .connect(positiveWaveShaperNode)\n                .connect(revertGainNode)\n                .connect(outputGainNode);\n            isConnected = true;\n            if (isDCCurve(unmodifiedCurve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n            }\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(negativeWaveShaperNode);\n            negativeWaveShaperNode.disconnect(outputGainNode);\n            inputGainNode.disconnect(invertGainNode);\n            invertGainNode.disconnect(positiveWaveShaperNode);\n            positiveWaveShaperNode.disconnect(revertGainNode);\n            revertGainNode.disconnect(outputGainNode);\n            isConnected = false;\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n        return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-wave-shaper-node-faker-factory.js.map","import { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createOfflineAudioContextConstructor = (baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering) => {\n    return class OfflineAudioContext extends baseAudioContextConstructor {\n        constructor(a, b, c) {\n            let options;\n            if (typeof a === 'number' && b !== undefined && c !== undefined) {\n                options = { length: b, numberOfChannels: a, sampleRate: c };\n            }\n            else if (typeof a === 'object') {\n                options = a;\n            }\n            else {\n                throw new Error('The given parameters are not valid.');\n            }\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener('statechange', (() => {\n                    let i = 0;\n                    const delayStateChangeEvent = (event) => {\n                        if (this._state === 'running') {\n                            if (i > 0) {\n                                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                event.stopImmediatePropagation();\n                                this._waitForThePromiseToSettle(event);\n                            }\n                            else {\n                                i += 1;\n                            }\n                        }\n                    };\n                    return delayStateChangeEvent;\n                })());\n            }\n            super(nativeOfflineAudioContext, numberOfChannels);\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n        get length() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n        }\n        get state() {\n            return (this._state === null) ? this._nativeOfflineAudioContext.state : this._state;\n        }\n        startRendering() {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return startRendering(this.destination, this._nativeOfflineAudioContext)\n                .then((audioBuffer) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                return audioBuffer;\n            })\n                // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n                .catch((err) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                throw err;\n            });\n        }\n        _waitForThePromiseToSettle(event) {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            }\n            else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/offline-audio-context-constructor.js.map","import { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    detune: 0,\n    frequency: 440,\n    type: 'sine'\n};\nexport const createOscillatorNodeConstructor = (audioNodeConstructor, createAudioParam, createInvalidStateError, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n    return class OscillatorNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOscillatorNode = createNativeOscillatorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const oscillatorNodeRenderer = ((isOffline) ? createOscillatorNodeRenderer() : null);\n            const nyquist = context.sampleRate / 2;\n            super(context, false, nativeOscillatorNode, oscillatorNodeRenderer);\n            // Bug #81: Edge, Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(this, isOffline, nativeOscillatorNode.detune, 153600, -153600);\n            // Bug #76: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);\n            this._nativeOscillatorNode = nativeOscillatorNode;\n            this._onended = null;\n            this._oscillatorNodeRenderer = oscillatorNodeRenderer;\n            if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== undefined) {\n                this._oscillatorNodeRenderer.periodicWave =\n                    mergedOptions.periodicWave;\n            }\n        }\n        get detune() {\n            return this._detune;\n        }\n        get frequency() {\n            return this._frequency;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = (typeof value === 'function') ? wrapEventListener(this, value) : null;\n            this._nativeOscillatorNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeOscillatorNode.onended;\n            this._onended = (nativeOnEnded !== null && nativeOnEnded === wrappedListener)\n                ? value\n                : nativeOnEnded;\n        }\n        get type() {\n            return this._nativeOscillatorNode.type;\n        }\n        set type(value) {\n            this._nativeOscillatorNode.type = value;\n            // Bug #57: Edge will not throw an error when assigning the type to 'custom'. But it still will change the value.\n            if (value === 'custom') {\n                throw createInvalidStateError();\n            }\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = null;\n            }\n        }\n        setPeriodicWave(periodicWave) {\n            this._nativeOscillatorNode.setPeriodicWave(periodicWave);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = periodicWave;\n            }\n        }\n        start(when = 0) {\n            this._nativeOscillatorNode.start(when);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.start = when;\n            }\n            else {\n                setInternalStateToActive(this);\n                const resetInternalStateToPassive = () => {\n                    this._nativeOscillatorNode.removeEventListener('ended', resetInternalStateToPassive);\n                    // @todo Determine a meaningful delay instead of just using one second.\n                    setTimeout(() => setInternalStateToPassive(this), 1000);\n                };\n                this._nativeOscillatorNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeOscillatorNode.stop(when);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/oscillator-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createOscillatorNodeRendererFactory = (connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeOscillatorNodes = new WeakMap();\n        let periodicWave = null;\n        let start = null;\n        let stop = null;\n        const createOscillatorNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeOscillatorNode = getNativeAudioNode(proxy);\n            // If the initially used nativeOscillatorNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeOscillatorNode.channelCount,\n                    channelCountMode: nativeOscillatorNode.channelCountMode,\n                    channelInterpretation: nativeOscillatorNode.channelInterpretation,\n                    detune: nativeOscillatorNode.detune.value,\n                    frequency: nativeOscillatorNode.frequency.value,\n                    periodicWave: (periodicWave === null) ? undefined : periodicWave,\n                    type: nativeOscillatorNode.type\n                };\n                nativeOscillatorNode = createNativeOscillatorNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeOscillatorNode.start(start);\n                }\n                if (stop !== null) {\n                    nativeOscillatorNode.stop(stop);\n                }\n            }\n            renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeOscillatorNode, trace);\n            return nativeOscillatorNode;\n        };\n        return {\n            set periodicWave(value) {\n                periodicWave = value;\n            },\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeOscillatorNode !== undefined) {\n                    return Promise.resolve(renderedNativeOscillatorNode);\n                }\n                return createOscillatorNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/oscillator-node-renderer-factory.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    coneInnerAngle: 360,\n    coneOuterAngle: 360,\n    coneOuterGain: 0,\n    distanceModel: 'inverse',\n    maxDistance: 10000,\n    orientationX: 1,\n    orientationY: 0,\n    orientationZ: 0,\n    panningModel: 'equalpower',\n    positionX: 0,\n    positionY: 0,\n    positionZ: 0,\n    refDistance: 1,\n    rolloffFactor: 1\n};\nexport const createPannerNodeConstructor = (audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext) => {\n    return class PannerNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativePannerNode = createNativePannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const pannerNodeRenderer = ((isOffline) ? createPannerNodeRenderer() : null);\n            super(context, false, nativePannerNode, pannerNodeRenderer);\n            this._nativePannerNode = nativePannerNode;\n            // Bug #74: Edge & Safari do not export the correct values for maxValue and minValue for GainNodes.\n            this._orientationX = createAudioParam(this, isOffline, nativePannerNode.orientationX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._orientationY = createAudioParam(this, isOffline, nativePannerNode.orientationY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._orientationZ = createAudioParam(this, isOffline, nativePannerNode.orientationZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionX = createAudioParam(this, isOffline, nativePannerNode.positionX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionY = createAudioParam(this, isOffline, nativePannerNode.positionY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionZ = createAudioParam(this, isOffline, nativePannerNode.positionZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get coneInnerAngle() {\n            return this._nativePannerNode.coneInnerAngle;\n        }\n        set coneInnerAngle(value) {\n            this._nativePannerNode.coneInnerAngle = value;\n        }\n        get coneOuterAngle() {\n            return this._nativePannerNode.coneOuterAngle;\n        }\n        set coneOuterAngle(value) {\n            this._nativePannerNode.coneOuterAngle = value;\n        }\n        get coneOuterGain() {\n            return this._nativePannerNode.coneOuterGain;\n        }\n        set coneOuterGain(value) {\n            this._nativePannerNode.coneOuterGain = value;\n        }\n        get distanceModel() {\n            return this._nativePannerNode.distanceModel;\n        }\n        set distanceModel(value) {\n            this._nativePannerNode.distanceModel = value;\n        }\n        get maxDistance() {\n            return this._nativePannerNode.maxDistance;\n        }\n        set maxDistance(value) {\n            this._nativePannerNode.maxDistance = value;\n        }\n        get orientationX() {\n            return this._orientationX;\n        }\n        get orientationY() {\n            return this._orientationY;\n        }\n        get orientationZ() {\n            return this._orientationZ;\n        }\n        get panningModel() {\n            return this._nativePannerNode.panningModel;\n        }\n        set panningModel(value) {\n            this._nativePannerNode.panningModel = value;\n        }\n        get positionX() {\n            return this._positionX;\n        }\n        get positionY() {\n            return this._positionY;\n        }\n        get positionZ() {\n            return this._positionZ;\n        }\n        get refDistance() {\n            return this._nativePannerNode.refDistance;\n        }\n        set refDistance(value) {\n            this._nativePannerNode.refDistance = value;\n        }\n        get rolloffFactor() {\n            return this._nativePannerNode.rolloffFactor;\n        }\n        set rolloffFactor(value) {\n            this._nativePannerNode.rolloffFactor = value;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/panner-node-constructor.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createPannerNodeRendererFactory = (connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return () => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let renderedBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeGainNode = null;\n            let nativePannerNode = getNativeAudioNode(proxy);\n            const commonAudioNodeOptions = {\n                channelCount: nativePannerNode.channelCount,\n                channelCountMode: nativePannerNode.channelCountMode,\n                channelInterpretation: nativePannerNode.channelInterpretation\n            };\n            const commonNativePannerNodeOptions = {\n                ...commonAudioNodeOptions,\n                coneInnerAngle: nativePannerNode.coneInnerAngle,\n                coneOuterAngle: nativePannerNode.coneOuterAngle,\n                coneOuterGain: nativePannerNode.coneOuterGain,\n                distanceModel: nativePannerNode.distanceModel,\n                maxDistance: nativePannerNode.maxDistance,\n                panningModel: nativePannerNode.panningModel,\n                refDistance: nativePannerNode.refDistance,\n                rolloffFactor: nativePannerNode.rolloffFactor\n            };\n            // If the initially used nativePannerNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext);\n            // Bug #124: Edge & Safari do not support modifying the orientation and the position with AudioParams.\n            if ('bufferSize' in nativePannerNode) {\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n            }\n            else if (!nativePannerNodeIsOwnedByContext) {\n                const options = {\n                    ...commonNativePannerNodeOptions,\n                    orientationX: nativePannerNode.orientationX.value,\n                    orientationY: nativePannerNode.orientationY.value,\n                    orientationZ: nativePannerNode.orientationZ.value,\n                    positionX: nativePannerNode.positionX.value,\n                    positionY: nativePannerNode.positionY.value,\n                    positionZ: nativePannerNode.positionZ.value\n                };\n                nativePannerNode = createNativePannerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, (nativeGainNode === null) ? nativePannerNode : nativeGainNode);\n            if (nativeGainNode !== null) {\n                if (renderedBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(6, \n                    // Bug #17: Safari does not yet expose the length.\n                    proxy.context.length, nativeOfflineAudioContext.sampleRate);\n                    const nativeChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: 6\n                    });\n                    nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                    renderedBufferPromise = (async () => {\n                        const nativeConstantSourceNodes = await Promise\n                            .all([\n                            proxy.orientationX,\n                            proxy.orientationY,\n                            proxy.orientationZ,\n                            proxy.positionX,\n                            proxy.positionY,\n                            proxy.positionZ\n                        ]\n                            .map(async (audioParam, index) => {\n                            const nativeConstantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                channelCount: 1,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                offset: (index === 0) ? 1 : 0\n                            });\n                            await renderAutomation(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset, trace);\n                            return nativeConstantSourceNode;\n                        }));\n                        for (let i = 0; i < 6; i += 1) {\n                            nativeConstantSourceNodes[i].connect(nativeChannelMergerNode, 0, i);\n                            nativeConstantSourceNodes[i].start(0);\n                        }\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    })();\n                }\n                const renderedBuffer = await renderedBufferPromise;\n                const inputGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, inputGainNode, trace);\n                const channelDatas = [];\n                for (let i = 0; i < renderedBuffer.numberOfChannels; i += 1) {\n                    channelDatas.push(renderedBuffer.getChannelData(i));\n                }\n                let lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];\n                let lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];\n                let gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n                let partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, {\n                    ...commonNativePannerNodeOptions,\n                    orientationX: lastOrientation[0],\n                    orientationY: lastOrientation[1],\n                    orientationZ: lastOrientation[2],\n                    positionX: lastPosition[0],\n                    positionY: lastPosition[1],\n                    positionZ: lastPosition[2]\n                });\n                inputGainNode\n                    .connect(gateGainNode)\n                    .connect(partialPannerNode.inputs[0]);\n                partialPannerNode.connect(nativeGainNode);\n                for (let i = 128; i < renderedBuffer.length; i += 128) {\n                    const orientation = [channelDatas[0][i], channelDatas[1][i], channelDatas[2][i]];\n                    const positon = [channelDatas[3][i], channelDatas[4][i], channelDatas[5][i]];\n                    if (orientation.some((value, index) => (value !== lastOrientation[index]))\n                        || positon.some((value, index) => (value !== lastPosition[index]))) {\n                        lastOrientation = orientation;\n                        lastPosition = positon;\n                        const currentTime = i / nativeOfflineAudioContext.sampleRate;\n                        gateGainNode.gain.setValueAtTime(0, currentTime);\n                        gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 0 });\n                        partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, {\n                            ...commonNativePannerNodeOptions,\n                            orientationX: lastOrientation[0],\n                            orientationY: lastOrientation[1],\n                            orientationZ: lastOrientation[2],\n                            positionX: lastPosition[0],\n                            positionY: lastPosition[1],\n                            positionZ: lastPosition[2]\n                        });\n                        gateGainNode.gain.setValueAtTime(1, currentTime);\n                        inputGainNode\n                            .connect(gateGainNode)\n                            .connect(partialPannerNode.inputs[0]);\n                        partialPannerNode.connect(nativeGainNode);\n                    }\n                }\n                return nativeGainNode;\n            }\n            if (!nativePannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ, trace);\n            }\n            if (isNativeAudioNodeFaker(nativePannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0], trace);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode, trace);\n            }\n            return nativePannerNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeGainNodeOrNativePannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/panner-node-renderer-factory.js.map","const DEFAULT_OPTIONS = {\n    disableNormalization: false\n};\nexport const createPeriodicWaveConstructor = (createNativePeriodicWave, getNativeContext, periodicWaveStore) => {\n    return class PeriodicWave {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const periodicWave = createNativePeriodicWave(nativeContext, mergedOptions);\n            periodicWaveStore.add(periodicWave);\n            // This does violate all good pratices but it is used here to simplify the handling of periodic waves.\n            return periodicWave;\n        }\n        static [Symbol.hasInstance](instance) {\n            return (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === PeriodicWave.prototype)\n                || (periodicWaveStore.has(instance));\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/periodic-wave-constructor.js.map","export const createRenderAutomation = (getAudioParamRenderer, renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam, trace) => {\n        const audioParamRenderer = getAudioParamRenderer(audioParam);\n        audioParamRenderer.replay(nativeAudioParam);\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam, trace);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/render-automation.js.map","export const createRenderInputsOfAudioNode = (getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) => {\n    return async (audioNode, nativeOfflineAudioContext, nativeAudioNode, trace) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n        const nextTrace = [...trace, audioNode];\n        await Promise\n            .all(audioNodeConnections.activeInputs\n            .map((connections, input) => Array\n            .from(connections)\n            .filter(([source]) => !nextTrace.includes(source))\n            .map(async ([source, output]) => {\n            const audioNodeRenderer = getAudioNodeRenderer(source);\n            const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext, nextTrace);\n            const destination = audioNode.context.destination;\n            if (!isPartOfACycle(source) && ((audioNode !== destination) || !isPartOfACycle(audioNode))) {\n                renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n            }\n        }))\n            .reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/render-inputs-of-audio-node.js.map","export const createRenderInputsOfAudioParam = (getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle) => {\n    return async (audioParam, nativeOfflineAudioContext, nativeAudioParam, trace) => {\n        const audioParamConnections = getAudioParamConnections(audioParam);\n        await Promise\n            .all(Array\n            .from(audioParamConnections.activeInputs)\n            .map(async ([source, output]) => {\n            const audioNodeRenderer = getAudioNodeRenderer(source);\n            const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext, trace);\n            if (!isPartOfACycle(source)) {\n                renderedNativeAudioNode.connect(nativeAudioParam, output);\n            }\n        }));\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/render-inputs-of-audio-param.js.map","import { testPromiseSupport } from '../helpers/test-promise-support';\nexport const createRenderNativeOfflineAudioContext = (cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, testOfflineAudioContextCurrentTimeSupport) => {\n    return (nativeOfflineAudioContext) => {\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n            // Bug #158: Edge does not advance currentTime if it is not accessed while rendering the audio.\n            return Promise\n                .resolve(cacheTestResult(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport))\n                .then((isOfflineAudioContextCurrentTimeSupported) => {\n                if (!isOfflineAudioContextCurrentTimeSupported) {\n                    const scriptProcessorNode = createNativeScriptProcessorNode(nativeOfflineAudioContext, 512, 0, 1);\n                    nativeOfflineAudioContext.oncomplete = () => {\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        scriptProcessorNode.disconnect();\n                    };\n                    scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime; // tslint:disable-line:deprecation\n                    scriptProcessorNode.connect(nativeOfflineAudioContext.destination);\n                }\n                return nativeOfflineAudioContext.startRendering();\n            });\n        }\n        return new Promise((resolve) => {\n            // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n            const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                gain: 0\n            });\n            nativeOfflineAudioContext.oncomplete = (event) => {\n                gainNode.disconnect();\n                resolve(event.renderedBuffer);\n            };\n            gainNode.connect(nativeOfflineAudioContext.destination);\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/render-native-offline-audio-context.js.map","import { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createStartRendering = (audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    const trace = [];\n    return (destination, nativeOfflineAudioContext) => getAudioNodeRenderer(destination)\n        .render(destination, nativeOfflineAudioContext, trace)\n        /*\n         * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to the\n         * destination.\n         */\n        .then(() => Promise\n        .all(Array\n        .from(getUnrenderedAudioWorkletNodes(nativeOfflineAudioContext))\n        .map((audioWorkletNode) => getAudioNodeRenderer(audioWorkletNode)\n        .render(audioWorkletNode, nativeOfflineAudioContext, trace))))\n        .then(() => renderNativeOfflineAudioContext(nativeOfflineAudioContext))\n        .then((audioBuffer) => {\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n        if (typeof audioBuffer.copyFromChannel !== 'function') {\n            wrapAudioBufferCopyChannelMethods(audioBuffer);\n            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n            // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n        }\n        else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n            wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n        }\n        audioBufferStore.add(audioBuffer);\n        return audioBuffer;\n    });\n};\n//# sourceMappingURL=/build/es2019/factories/start-rendering.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    /*\n     * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent\n     * behavior.\n     */\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    pan: 0\n};\nexport const createStereoPannerNodeConstructor = (audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext) => {\n    return class StereoPannerNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeStereoPannerNode = createNativeStereoPannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const stereoPannerNodeRenderer = ((isOffline) ? createStereoPannerNodeRenderer() : null);\n            super(context, false, nativeStereoPannerNode, stereoPannerNodeRenderer);\n            // Bug #106: Edge does not export a maxValue and minValue property.\n            this._pan = createAudioParam(this, isOffline, nativeStereoPannerNode.pan, 1, -1);\n        }\n        get pan() {\n            return this._pan;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/stereo-panner-node-constructor.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createStereoPannerNodeRendererFactory = (connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeStereoPannerNodes = new WeakMap();\n        const createStereoPannerNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeStereoPannerNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeStereoPannerNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeStereoPannerNode.channelCount,\n                    channelCountMode: nativeStereoPannerNode.channelCountMode,\n                    channelInterpretation: nativeStereoPannerNode.channelInterpretation,\n                    pan: nativeStereoPannerNode.pan.value\n                };\n                nativeStereoPannerNode = createNativeStereoPannerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan, trace);\n            }\n            if (isNativeAudioNodeFaker(nativeStereoPannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0], trace);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode, trace);\n            }\n            return nativeStereoPannerNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeStereoPannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeStereoPannerNode);\n                }\n                return createStereoPannerNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/stereo-panner-node-renderer-factory.js.map","// Bug #33: Edge & Safari expose an AudioBuffer but it can't be used as a constructor.\nexport const createTestAudioBufferConstructorSupport = (nativeAudioBufferConstructor) => {\n    return () => {\n        if (nativeAudioBufferConstructor === null) {\n            return false;\n        }\n        try {\n            new nativeAudioBufferConstructor({ length: 1, sampleRate: 44100 }); // tslint:disable-line:no-unused-expression\n        }\n        catch {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-buffer-constructor-support.js.map","/*\n * Firefox up to version 67 didn't fully support the copyFromChannel() and copyToChannel() methods. Therefore testing one of those methods\n * is enough to know if the other one is supported as well.\n */\nexport const createTestAudioBufferCopyChannelMethodsSubarraySupport = (nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const nativeAudioBuffer = nativeOfflineAudioContext.createBuffer(1, 1, 44100);\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        if (nativeAudioBuffer.copyToChannel === undefined) {\n            return true;\n        }\n        const source = new Float32Array(2);\n        try {\n            nativeAudioBuffer.copyFromChannel(source, 0, 0);\n        }\n        catch {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-buffer-copy-channel-methods-subarray-support.js.map","export const createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        nativeAudioBufferSourceNode.start();\n        try {\n            nativeAudioBufferSourceNode.start();\n        }\n        catch {\n            return true;\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-buffer-source-node-start-method-consecutive-calls-support.js.map","// Bug #92: Edge does not respect the duration parameter yet.\nexport const createTestAudioBufferSourceNodeStartMethodDurationParameterSupport = (nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const audioBuffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n        const audioBufferSourceNode = offlineAudioContext.createBufferSource();\n        audioBuffer.getChannelData(0)[0] = 1;\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.start(0, 0, 0);\n        audioBufferSourceNode.connect(offlineAudioContext.destination);\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            offlineAudioContext.oncomplete = ({ renderedBuffer }) => {\n                // Bug #5: Safari does not support copyFromChannel().\n                resolve(renderedBuffer.getChannelData(0)[0] === 0);\n            };\n            offlineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-buffer-source-node-start-method-duration-parameter-support.js.map","export const createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        try {\n            nativeAudioBufferSourceNode.start(0, 1);\n        }\n        catch {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-buffer-source-node-start-method-offset-clamping-support.js.map","export const createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        nativeAudioBufferSourceNode.start();\n        try {\n            nativeAudioBufferSourceNode.stop();\n        }\n        catch {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-buffer-source-node-stop-method-nullified-buffer-support.js.map","export const createTestAudioContextCloseMethodSupport = (nativeAudioContextConstructor) => {\n    return () => {\n        if (nativeAudioContextConstructor === null) {\n            return false;\n        }\n        // Try to check the prototype before constructing the AudioContext.\n        if (nativeAudioContextConstructor.prototype !== undefined &&\n            nativeAudioContextConstructor.prototype.close !== undefined) {\n            return true;\n        }\n        const audioContext = new nativeAudioContextConstructor();\n        const isAudioContextClosable = (audioContext.close !== undefined);\n        try {\n            audioContext.close();\n        }\n        catch {\n            // Ignore errors.\n        }\n        return isAudioContextClosable;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-context-close-method-support.js.map","/**\n * Edge up to version 14, Firefox up to version 52, Safari up to version 9 and maybe other browsers\n * did not refuse to decode invalid parameters with a TypeError.\n */\nexport const createTestAudioContextDecodeAudioDataMethodTypeErrorSupport = (nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            let isPending = true;\n            const resolvePromise = (err) => {\n                if (isPending) {\n                    isPending = false;\n                    offlineAudioContext.startRendering();\n                    resolve(err instanceof TypeError);\n                }\n            };\n            let promise;\n            // Bug #26: Safari throws a synchronous error.\n            try {\n                promise = offlineAudioContext\n                    // Bug #1: Safari requires a successCallback.\n                    .decodeAudioData(null, () => {\n                    // Ignore the success callback.\n                }, resolvePromise);\n            }\n            catch (err) {\n                resolvePromise(err);\n            }\n            // Bug #21: Safari does not support promises yet.\n            if (promise !== undefined) {\n                // Bug #6 Chrome does not call the errorCallback\n                promise.catch(resolvePromise);\n            }\n        });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-context-decode-audio-data-method-type-error-support.js.map","export const createTestAudioContextOptionsSupport = (nativeAudioContextConstructor) => {\n    return () => {\n        if (nativeAudioContextConstructor === null) {\n            return false;\n        }\n        let audioContext;\n        try {\n            audioContext = new nativeAudioContextConstructor({ latencyHint: 'balanced' });\n        }\n        catch {\n            return false;\n        }\n        audioContext.close();\n        return true;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-context-options-support.js.map","// Safari up to version 12.0 (but not v12.1) didn't return the destination in case it was an AudioNode.\nexport const createTestAudioNodeConnectMethodSupport = (nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const nativeGainNode = nativeOfflineAudioContext.createGain();\n        const isSupported = (nativeGainNode.connect(nativeGainNode) === nativeGainNode);\n        nativeGainNode.disconnect(nativeGainNode);\n        return isSupported;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-node-connect-method-support.js.map","export const createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createOscillator());\n        try {\n            nativeAudioBufferSourceNode.start(-1);\n        }\n        catch (err) {\n            return (err instanceof RangeError);\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-scheduled-source-node-start-method-negative-parameters-support.js.map","export const createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        nativeAudioBufferSourceNode.start();\n        nativeAudioBufferSourceNode.stop();\n        try {\n            nativeAudioBufferSourceNode.stop();\n            return true;\n        }\n        catch {\n            return false;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js.map","export const createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createOscillator());\n        try {\n            nativeAudioBufferSourceNode.stop(-1);\n        }\n        catch (err) {\n            return (err instanceof RangeError);\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js.map","/**\n * Chrome version 66 and 67 did not call the process() function of an AudioWorkletProcessor if it had no outputs. AudioWorklet support was\n * enabled by default in version 66.\n */\nexport const createTestAudioWorkletProcessorNoOutputsSupport = (nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor) => {\n    return async () => {\n        // Bug #61: If there is no native AudioWorkletNode it gets faked and therefore it is no problem if the it doesn't exist.\n        if (nativeAudioWorkletNodeConstructor === null) {\n            return true;\n        }\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n        const blob = new Blob(['class A extends AudioWorkletProcessor{process(){this.port.postMessage(0)}}registerProcessor(\"a\",A)'], { type: 'application/javascript; charset=utf-8' });\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 3200);\n        const url = URL.createObjectURL(blob);\n        let isCallingProcess = false;\n        try {\n            await offlineAudioContext.audioWorklet.addModule(url);\n            const gainNode = offlineAudioContext.createGain();\n            const audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', { numberOfOutputs: 0 });\n            audioWorkletNode.port.onmessage = () => isCallingProcess = true;\n            gainNode.connect(audioWorkletNode);\n            await offlineAudioContext.startRendering();\n        }\n        catch {\n            // Ignore errors.\n        }\n        finally {\n            URL.revokeObjectURL(url);\n        }\n        return isCallingProcess;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-worklet-processor-no-outputs-support.js.map","/**\n * Firefox up to version 69 did not throw an error when setting a different channelCount or channelCountMode.\n */\nexport const createTestChannelMergerNodeChannelCountSupport = (createNativeAudioNode, nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const nativeChannelMergerNode = createNativeAudioNode(offlineAudioContext, (ntvCntxt) => ntvCntxt.createChannelMerger());\n        try {\n            nativeChannelMergerNode.channelCount = 2;\n        }\n        catch {\n            return true;\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-channel-merger-node-channel-count-support.js.map","export const createTestConstantSourceNodeAccurateSchedulingSupport = (createNativeAudioNode, nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        // Bug #62: Edge & Safari do not support ConstantSourceNodes.\n        if (nativeOfflineAudioContext.createConstantSource === undefined) {\n            return true;\n        }\n        const nativeConstantSourceNode = createNativeAudioNode(nativeOfflineAudioContext, (ntvCntxt) => ntvCntxt.createConstantSource());\n        /*\n         * @todo This is using bug #75 to detect bug #70. That works because both bugs were unique to\n         * the implementation of Firefox right now, but it could probably be done in a better way.\n         */\n        return (nativeConstantSourceNode.offset.maxValue !== Number.POSITIVE_INFINITY);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-constant-source-node-accurate-scheduling-support.js.map","// Opera up to version 57 did not allow to reassign the buffer of a ConvolverNode.\nexport const createTestConvolverNodeBufferReassignabilitySupport = (nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const nativeConvolverNode = offlineAudioContext.createConvolver();\n        nativeConvolverNode.buffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n        try {\n            nativeConvolverNode.buffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n        }\n        catch {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-convolver-node-buffer-reassignability-support.js.map","export const createTestIsSecureContextSupport = (window) => {\n    return () => (window !== null && window.hasOwnProperty('isSecureContext'));\n};\n//# sourceMappingURL=/build/es2019/factories/test-is-secure-context-support.js.map","// Firefox up to version 68 did not throw an error when creating a MediaStreamAudioSourceNode with a mediaStream that had no audio track.\nexport const createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport = (nativeAudioContextConstructor) => {\n    return () => {\n        if (nativeAudioContextConstructor === null) {\n            return false;\n        }\n        const audioContext = new nativeAudioContextConstructor();\n        try {\n            audioContext.createMediaStreamSource(new MediaStream());\n            return false;\n        }\n        catch (err) {\n            return true;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support.js.map","export const createTestOfflineAudioContextCurrentTimeSupport = (createNativeGainNode, nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n        const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            nativeOfflineAudioContext.oncomplete = () => {\n                gainNode.disconnect();\n                resolve(nativeOfflineAudioContext.currentTime !== 0);\n            };\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-offline-audio-context-current-time-support.js.map","/**\n * Firefox up to version 62 did not kick off the processing of the StereoPannerNode if the value of pan was zero.\n */\nexport const createTestStereoPannerNodeDefaultValueSupport = (nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        /*\n         * Bug #105: Safari does not support the StereoPannerNode. Therefore the returned value should normally be false but the faker does\n         * support the tested behaviour.\n         */\n        if (nativeOfflineAudioContext.createStereoPanner === undefined) {\n            return Promise.resolve(true);\n        }\n        // Bug #62: Edge & Safari do not support ConstantSourceNodes.\n        if (nativeOfflineAudioContext.createConstantSource === undefined) {\n            return Promise.resolve(true);\n        }\n        const constantSourceNode = nativeOfflineAudioContext.createConstantSource();\n        const stereoPanner = nativeOfflineAudioContext.createStereoPanner();\n        constantSourceNode.channelCount = 1;\n        constantSourceNode.offset.value = 1;\n        stereoPanner.channelCount = 1;\n        constantSourceNode.start();\n        constantSourceNode\n            .connect(stereoPanner)\n            .connect(nativeOfflineAudioContext.destination);\n        return nativeOfflineAudioContext\n            .startRendering()\n            .then((buffer) => buffer.getChannelData(0)[0] !== 1);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-stereo-panner-node-default-value-support.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    curve: null,\n    oversample: 'none'\n};\nexport const createWaveShaperNodeConstructor = (audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext) => {\n    return class WaveShaperNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeWaveShaperNode = createNativeWaveShaperNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const waveShaperNodeRenderer = ((isOffline) ? createWaveShaperNodeRenderer() : null);\n            // @todo Add a mechanism to only switch a WaveShaperNode to active while it is connected.\n            super(context, true, nativeWaveShaperNode, waveShaperNodeRenderer);\n            this._isCurveNullified = false;\n            this._nativeWaveShaperNode = nativeWaveShaperNode;\n        }\n        get curve() {\n            if (this._isCurveNullified) {\n                return null;\n            }\n            return this._nativeWaveShaperNode.curve;\n        }\n        set curve(value) {\n            // Bug #103: Safari does not allow to set the curve to null.\n            if (value === null) {\n                this._isCurveNullified = true;\n                this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);\n            }\n            else {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                // Bug #104: Chrome will throw an InvalidAccessError when the curve has less than two samples.\n                if (value.length < 2) {\n                    throw createInvalidStateError();\n                }\n                this._isCurveNullified = false;\n                this._nativeWaveShaperNode.curve = value;\n            }\n        }\n        get oversample() {\n            return this._nativeWaveShaperNode.oversample;\n        }\n        set oversample(value) {\n            this._nativeWaveShaperNode.oversample = value;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/wave-shaper-node-constructor.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createWaveShaperNodeRendererFactory = (createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeWaveShaperNodes = new WeakMap();\n        const createWaveShaperNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeWaveShaperNode = getNativeAudioNode(proxy);\n            // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n            if (!nativeWaveShaperNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeWaveShaperNode.channelCount,\n                    channelCountMode: nativeWaveShaperNode.channelCountMode,\n                    channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n                    curve: nativeWaveShaperNode.curve,\n                    oversample: nativeWaveShaperNode.oversample\n                };\n                nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n            if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0], trace);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode, trace);\n            }\n            return nativeWaveShaperNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeWaveShaperNode !== undefined) {\n                    return Promise.resolve(renderedNativeWaveShaperNode);\n                }\n                return createWaveShaperNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/wave-shaper-node-renderer-factory.js.map","export const createWindow = () => (typeof window === 'undefined') ? null : window;\n//# sourceMappingURL=/build/es2019/factories/window.js.map","export const createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong, createIndexSizeError) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const destinationLength = destination.length;\n            for (let i = (bufferOffset < 0) ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n                destination[i] = channelData[i + bufferOffset];\n            }\n        };\n        audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const sourceLength = source.length;\n            for (let i = (bufferOffset < 0) ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n                channelData[i + bufferOffset] = source[i];\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/wrap-audio-buffer-copy-channel-methods.js.map","export const createWrapAudioBufferCopyChannelMethodsOutOfBounds = (convertNumberToUnsignedLong) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = ((copyFromChannel) => {\n            return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyFromChannel);\n        audioBuffer.copyToChannel = ((copyToChannel) => {\n            return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyToChannel);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js.map","export const createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer = (overwriteAccessors) => {\n    return (nativeAudioBufferSourceNode, nativeContext) => {\n        const nullifiedBuffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);\n        if (nativeAudioBufferSourceNode.buffer === null) {\n            nativeAudioBufferSourceNode.buffer = nullifiedBuffer;\n        }\n        overwriteAccessors(nativeAudioBufferSourceNode, 'buffer', (get) => () => {\n            const value = get.call(nativeAudioBufferSourceNode);\n            return (value === nullifiedBuffer) ? null : value;\n        }, (set) => (value) => {\n            return set.call(nativeAudioBufferSourceNode, (value === null) ? nullifiedBuffer : value);\n        });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = (createNativeAudioNode) => {\n    return (nativeAudioScheduledSourceNode, nativeContext) => {\n        const nativeGainNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createGain());\n        nativeAudioScheduledSourceNode.connect(nativeGainNode);\n        const disconnectGainNode = ((disconnect) => {\n            return () => {\n                // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n                disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n                nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n            };\n        })(nativeAudioScheduledSourceNode.disconnect);\n        nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n        interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n        nativeAudioScheduledSourceNode.stop = ((stop) => {\n            let isStopped = false;\n            return (when = 0) => {\n                if (isStopped) {\n                    try {\n                        stop.call(nativeAudioScheduledSourceNode, when);\n                    }\n                    catch {\n                        nativeGainNode.gain.setValueAtTime(0, when);\n                    }\n                }\n                else {\n                    stop.call(nativeAudioScheduledSourceNode, when);\n                    isStopped = true;\n                }\n            };\n        })(nativeAudioScheduledSourceNode.stop);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js.map","export const createWrapChannelMergerNode = (createInvalidStateError, createNativeAudioNode, monitorConnectionsFunction) => {\n    return (nativeContext, channelMergerNode) => {\n        channelMergerNode.channelCount = 1;\n        channelMergerNode.channelCountMode = 'explicit';\n        Object.defineProperty(channelMergerNode, 'channelCount', {\n            get: () => 1,\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n        Object.defineProperty(channelMergerNode, 'channelCountMode', {\n            get: () => 'explicit',\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n        // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n        const audioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        const whenConnected = () => {\n            const length = channelMergerNode.numberOfInputs;\n            for (let i = 0; i < length; i += 1) {\n                audioBufferSourceNode.connect(channelMergerNode, 0, i);\n            }\n        };\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(channelMergerNode);\n        monitorConnectionsFunction(channelMergerNode, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/wrap-channel-merger-node.js.map","// Safari at version 11 did not support transferables.\nexport const testTransferablesSupport = () => new Promise((resolve) => {\n    const arrayBuffer = new ArrayBuffer(0);\n    const { port1, port2 } = new MessageChannel();\n    port1.onmessage = ({ data }) => resolve(data !== null);\n    port2.postMessage(arrayBuffer, [arrayBuffer]);\n});\n//# sourceMappingURL=/build/es2019/helpers/test-transferables-support.js.map","export const wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode) => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration) => {\n            const buffer = nativeAudioBufferSourceNode.buffer;\n            // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.\n            const clampedOffset = (buffer === null) ? offset : Math.min(buffer.duration, offset);\n            // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.\n            if (buffer !== null && clampedOffset > buffer.duration - (0.5 / nativeAudioBufferSourceNode.context.sampleRate)) {\n                start.call(nativeAudioBufferSourceNode, when, 0, 0);\n            }\n            else {\n                start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n            }\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js.map","export const isAudioWorkletNode = (audioNode) => {\n    return 'port' in audioNode;\n};\n//# sourceMappingURL=/build/es2019/guards/audio-worklet-node.js.map","import { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const deleteEventListenerOfAudioNode = (audioNode, eventListener) => {\n    const eventListeners = getEventListenersOfAudioNode(audioNode);\n    if (!eventListeners.delete(eventListener)) {\n        throw new Error('Missing the expected event listener.');\n    }\n};\n//# sourceMappingURL=/build/es2019/helpers/delete-event-listeners-of-audio-node.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isPassiveAudioNode = (audioNode) => {\n    return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n};\n//# sourceMappingURL=/build/es2019/helpers/is-passive-audio-node.js.map","export const pickElementFromSet = (set, predicate) => {\n    const matchingElements = Array\n        .from(set)\n        .filter(predicate);\n    if (matchingElements.length > 1) {\n        throw Error('More than one element was found.');\n    }\n    if (matchingElements.length === 0) {\n        throw Error('No element was found.');\n    }\n    const [matchingElement] = matchingElements;\n    set.delete(matchingElement);\n    return matchingElement;\n};\n//# sourceMappingURL=/build/es2019/helpers/pick-element-from-set.js.map","import { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive';\n// Set the internalState of the audioNode to 'passive' if it is not an AudioWorkletNode and if it has no 'active' input connections.\nexport const setInternalStateToPassiveWhenNecessary = (audioNode, activeInputs) => {\n    if (!isAudioWorkletNode(audioNode) && activeInputs.every((connections) => (connections.size === 0))) {\n        setInternalStateToPassive(audioNode);\n    }\n};\n//# sourceMappingURL=/build/es2019/helpers/set-internal-state-to-passive-when-necessary.js.map","export const testAudioNodeDisconnectMethodSupport = (nativeAudioContext) => {\n    return new Promise((resolve) => {\n        const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1);\n        const dummy = nativeAudioContext.createGain();\n        // Bug #95: Safari does not play one sample buffers.\n        const ones = nativeAudioContext.createBuffer(1, 2, 44100);\n        const channelData = ones.getChannelData(0);\n        channelData[0] = 1;\n        channelData[1] = 1;\n        const source = nativeAudioContext.createBufferSource();\n        source.buffer = ones;\n        source.loop = true;\n        source\n            .connect(analyzer)\n            .connect(nativeAudioContext.destination);\n        source.connect(dummy);\n        source.disconnect(dummy);\n        analyzer.onaudioprocess = (event) => {\n            const chnnlDt = event.inputBuffer.getChannelData(0);\n            if (Array.prototype.some.call(chnnlDt, (sample) => sample === 1)) {\n                resolve(true);\n            }\n            else {\n                resolve(false);\n            }\n            source.stop();\n            analyzer.onaudioprocess = null; // tslint:disable-line:deprecation\n            source.disconnect(analyzer);\n            analyzer.disconnect(nativeAudioContext.destination);\n        };\n        source.start();\n    });\n};\n//# sourceMappingURL=/build/es2019/helpers/test-audio-node-disconnect-method-support.js.map","export const visitEachAudioNodeOnce = (cycles, visitor) => {\n    const counts = new Map();\n    for (const cycle of cycles) {\n        for (const audioNode of cycle) {\n            const count = counts.get(audioNode);\n            counts.set(audioNode, (count === undefined) ? 1 : count + 1);\n        }\n    }\n    counts.forEach((count, audioNode) => visitor(audioNode, count));\n};\n//# sourceMappingURL=/build/es2019/helpers/visit-each-audio-node-once.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const wrapAudioNodeDisconnectMethod = (nativeAudioNode) => {\n    const connections = new Map();\n    nativeAudioNode.connect = ((connect) => {\n        return (destination, output = 0, input = 0) => {\n            const returnValue = (isNativeAudioNode(destination))\n                ? connect(destination, output, input)\n                : connect(destination, output);\n            // Save the new connection only if the calls to connect above didn't throw an error.\n            const connectionsToDestination = connections.get(destination);\n            if (connectionsToDestination === undefined) {\n                connections.set(destination, [{ input, output }]);\n            }\n            else {\n                if (connectionsToDestination.every((connection) => (connection.input !== input || connection.output !== output))) {\n                    connectionsToDestination.push({ input, output });\n                }\n            }\n            return returnValue;\n        };\n    })(nativeAudioNode.connect.bind(nativeAudioNode));\n    nativeAudioNode.disconnect = ((disconnect) => {\n        return (destinationOrOutput, output, input) => {\n            disconnect.apply(nativeAudioNode);\n            if (destinationOrOutput === undefined) {\n                connections.clear();\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                for (const [destination, connectionsToDestination] of connections) {\n                    const filteredConnections = connectionsToDestination\n                        .filter((connection) => (connection.output !== destinationOrOutput));\n                    if (filteredConnections.length === 0) {\n                        connections.delete(destination);\n                    }\n                    else {\n                        connections.set(destination, filteredConnections);\n                    }\n                }\n            }\n            else if (connections.has(destinationOrOutput)) {\n                if (output === undefined) {\n                    connections.delete(destinationOrOutput);\n                }\n                else {\n                    const connectionsToDestination = connections.get(destinationOrOutput);\n                    if (connectionsToDestination !== undefined) {\n                        const filteredConnections = connectionsToDestination\n                            .filter((connection) => (connection.output !== output && (connection.input !== input || input === undefined)));\n                        if (filteredConnections.length === 0) {\n                            connections.delete(destinationOrOutput);\n                        }\n                        else {\n                            connections.set(destinationOrOutput, filteredConnections);\n                        }\n                    }\n                }\n            }\n            for (const [destination, connectionsToDestination] of connections) {\n                connectionsToDestination\n                    .forEach((connection) => {\n                    if (isNativeAudioNode(destination)) {\n                        nativeAudioNode.connect(destination, connection.output, connection.input);\n                    }\n                    else {\n                        nativeAudioNode.connect(destination, connection.output);\n                    }\n                });\n            }\n        };\n    })(nativeAudioNode.disconnect);\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-audio-node-disconnect-method.js.map","import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { getValueForKey } from '../helpers/get-value-for-key';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { pickElementFromSet } from '../helpers/pick-element-from-set';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nconst addActiveInputConnectionToAudioNode = (activeInputs, source, [output, input, eventListener], ignoreDuplicates) => {\n    insertElementInSet(activeInputs[input], [source, output, eventListener], (activeInputConnection) => (activeInputConnection[0] === source && activeInputConnection[1] === output), ignoreDuplicates);\n};\nconst addActiveInputConnectionToAudioParam = (activeInputs, source, [output, eventListener], ignoreDuplicates) => {\n    insertElementInSet(activeInputs, [source, output, eventListener], (activeInputConnection) => (activeInputConnection[0] === source && activeInputConnection[1] === output), ignoreDuplicates);\n};\nconst deleteActiveInputConnectionToAudioNode = (activeInputs, source, output, input) => {\n    return pickElementFromSet(activeInputs[input], (activeInputConnection) => (activeInputConnection[0] === source && activeInputConnection[1] === output));\n};\nconst deleteActiveInputConnectionToAudioParam = (activeInputs, source, output) => {\n    return pickElementFromSet(activeInputs, (activeInputConnection) => (activeInputConnection[0] === source && activeInputConnection[1] === output));\n};\nconst addPassiveInputConnectionToAudioNode = (passiveInputs, input, [source, output, eventListener], ignoreDuplicates) => {\n    const passiveInputConnections = passiveInputs.get(source);\n    if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, input, eventListener]]));\n    }\n    else {\n        insertElementInSet(passiveInputConnections, [output, input, eventListener], (passiveInputConnection) => (passiveInputConnection[0] === output && passiveInputConnection[1] === input), ignoreDuplicates);\n    }\n};\nconst addPassiveInputConnectionToAudioParam = (passiveInputs, [source, output, eventListener], ignoreDuplicates) => {\n    const passiveInputConnections = passiveInputs.get(source);\n    if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, eventListener]]));\n    }\n    else {\n        insertElementInSet(passiveInputConnections, [output, eventListener], (passiveInputConnection) => (passiveInputConnection[0] === output), ignoreDuplicates);\n    }\n};\nconst deletePassiveInputConnectionToAudioNode = (passiveInputs, source, output, input) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => (passiveInputConnection[0] === output && passiveInputConnection[1] === input));\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n    return matchingConnection;\n};\nconst deletePassiveInputConnectionToAudioParam = (passiveInputs, source, output) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => (passiveInputConnection[0] === output));\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n    return matchingConnection;\n};\nconst addConnectionToAudioNodeOfAudioContext = (source, destination, output, input) => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n    const eventListener = ((isActive) => {\n        const nativeDestinationAudioNode = getNativeAudioNode(destination);\n        const nativeSourceAudioNode = getNativeAudioNode(source);\n        if (isActive) {\n            const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n            addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);\n            if (!isPartOfACycle(source)) {\n                connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n            }\n            if (isPassiveAudioNode(destination)) {\n                setInternalStateToActive(destination);\n            }\n        }\n        else {\n            const partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);\n            addPassiveInputConnectionToAudioNode(passiveInputs, input, partialConnection, false);\n            if (!isPartOfACycle(source)) {\n                disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n            }\n            if (isActiveAudioNode(destination)) {\n                setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n            }\n        }\n    });\n    if (insertElementInSet(outputs, [destination, output, input], (outputConnection) => (outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input), true)) {\n        eventListeners.add(eventListener);\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);\n        }\n        else {\n            addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);\n        }\n        return true;\n    }\n    return false;\n};\nconst addConnectionToAudioNodeOfOfflineAudioContext = (source, destination, output, input) => {\n    const { outputs } = getAudioNodeConnections(source);\n    if (insertElementInSet(outputs, [destination, output, input], (outputConnection) => (outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input), true)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n        addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, null], true);\n        return true;\n    }\n    return false;\n};\nconst addConnectionToAudioParamOfAudioContext = (source, destination, output) => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n    const eventListener = ((isActive) => {\n        const nativeAudioNode = getNativeAudioNode(source);\n        const nativeAudioParam = getNativeAudioParam(destination);\n        if (isActive) {\n            const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n            addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n            if (!isPartOfACycle(source)) {\n                nativeAudioNode.connect(nativeAudioParam, output);\n            }\n        }\n        else {\n            const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n            addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n            if (!isPartOfACycle(source)) {\n                nativeAudioNode.disconnect(nativeAudioParam, output);\n            }\n        }\n    });\n    if (insertElementInSet(outputs, [destination, output], (outputConnection) => (outputConnection[0] === destination && outputConnection[1] === output), true)) {\n        eventListeners.add(eventListener);\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        }\n        else {\n            addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n        return true;\n    }\n    return false;\n};\nconst addConnectionToAudioParamOfOfflineAudioContext = (source, destination, output) => {\n    const { outputs } = getAudioNodeConnections(source);\n    if (insertElementInSet(outputs, [destination, output], (outputConnection) => (outputConnection[0] === destination && outputConnection[1] === output), true)) {\n        const { activeInputs } = getAudioParamConnections(destination);\n        addActiveInputConnectionToAudioParam(activeInputs, source, [output, null], true);\n        return true;\n    }\n    return false;\n};\nconst deleteActiveInputConnection = (activeInputConnections, source, output) => {\n    for (const activeInputConnection of activeInputConnections) {\n        if (activeInputConnection[0] === source && activeInputConnection[1] === output) {\n            activeInputConnections.delete(activeInputConnection);\n            return activeInputConnection;\n        }\n    }\n    return null;\n};\nconst deleteInputConnectionOfAudioNode = (source, destination, output, input) => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n    const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n        return [passiveInputConnection[2], false];\n    }\n    return [activeInputConnection[2], true];\n};\nconst deleteInputConnectionOfAudioParam = (source, destination, output) => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections(destination);\n    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n        return [passiveInputConnection[1], false];\n    }\n    return [activeInputConnection[2], true];\n};\nconst deleteInputsOfAudioNode = (source, destination, output, input) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (isActive && !isPartOfACycle(source)) {\n            disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n    }\n    if (isActiveAudioNode(destination)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n    }\n};\nconst deleteInputsOfAudioParam = (source, destination, output) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (isActive && !isPartOfACycle(source)) {\n            getNativeAudioNode(source)\n                .disconnect(getNativeAudioParam(destination), output);\n        }\n    }\n};\nconst deleteAnyConnection = (source) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, ...outputConnection);\n        }\n        else {\n            deleteInputsOfAudioParam(source, ...outputConnection);\n        }\n        destinations.push(outputConnection[0]);\n    }\n    audioNodeConnectionsOfSource.outputs.clear();\n    return destinations;\n};\nconst deleteConnectionAtOutput = (source, output) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, ...outputConnection);\n            }\n            else {\n                deleteInputsOfAudioParam(source, ...outputConnection);\n            }\n            destinations.push(outputConnection[0]);\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        }\n    }\n    return destinations;\n};\nconst deleteConnectionToDestination = (source, destination, output, input) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    return Array\n        .from(audioNodeConnectionsOfSource.outputs)\n        .filter((outputConnection) => (outputConnection[0] === destination\n        && (output === undefined || outputConnection[1] === output)\n        && (input === undefined || outputConnection[2] === input)))\n        .map((outputConnection) => {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, ...outputConnection);\n        }\n        else {\n            deleteInputsOfAudioParam(source, ...outputConnection);\n        }\n        audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        return outputConnection[0];\n    });\n};\nexport const createAudioNodeConstructor = (addAudioNodeConnections, auxiliaryGainNodeStore, cacheTestResult, createIncrementCycleCounter, createIndexSizeError, createInvalidAccessError, createNotSupportedError, decrementCycleCounter, detectCycles, eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext) => {\n    return class AudioNode extends eventTargetConstructor {\n        constructor(context, isActive, nativeAudioNode, audioNodeRenderer) {\n            super(nativeAudioNode);\n            this._context = context;\n            this._nativeAudioNode = nativeAudioNode;\n            const nativeContext = getNativeContext(context);\n            // Bug #12: Safari does not support to disconnect a specific destination.\n            if (isNativeAudioContext(nativeContext) && true !== cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n                return testAudioNodeDisconnectMethodSupport(nativeContext);\n            })) {\n                wrapAudioNodeDisconnectMethod(nativeAudioNode);\n            }\n            AUDIO_NODE_STORE.set(this, nativeAudioNode);\n            EVENT_LISTENERS.set(this, new Set());\n            if (isActive) {\n                setInternalStateToActive(this);\n            }\n            addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n        }\n        get channelCount() {\n            return this._nativeAudioNode.channelCount;\n        }\n        set channelCount(value) {\n            this._nativeAudioNode.channelCount = value;\n        }\n        get channelCountMode() {\n            return this._nativeAudioNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            this._nativeAudioNode.channelCountMode = value;\n        }\n        get channelInterpretation() {\n            return this._nativeAudioNode.channelInterpretation;\n        }\n        set channelInterpretation(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n        }\n        get context() {\n            return this._context;\n        }\n        get numberOfInputs() {\n            return this._nativeAudioNode.numberOfInputs;\n        }\n        get numberOfOutputs() {\n            return this._nativeAudioNode.numberOfOutputs;\n        }\n        connect(destination, output = 0, input = 0) {\n            // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n            if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n                throw createInvalidAccessError();\n            }\n            if (isAudioNode(destination)) {\n                const nativeDestinationAudioNode = getNativeAudioNode(destination);\n                try {\n                    const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n                    if (isOffline || isPassiveAudioNode(this)) {\n                        this._nativeAudioNode.disconnect(...connection);\n                    }\n                    else if (isPassiveAudioNode(destination)) {\n                        setInternalStateToActive(destination);\n                    }\n                    // An AudioWorklet needs a connection because it otherwise may truncate the input array.\n                    // @todo Count the number of connections which depend on this auxiliary GainNode to know when it can be removed again.\n                    if (isAudioWorkletNode(destination)) {\n                        const auxiliaryGainNodes = auxiliaryGainNodeStore.get(nativeDestinationAudioNode);\n                        if (auxiliaryGainNodes === undefined) {\n                            const nativeGainNode = nativeContext.createGain();\n                            nativeGainNode.connect(connection[0], 0, connection[2]);\n                            auxiliaryGainNodeStore.set(nativeDestinationAudioNode, new Map([[input, nativeGainNode]]));\n                        }\n                        else if (auxiliaryGainNodes.get(input) === undefined) {\n                            const nativeGainNode = nativeContext.createGain();\n                            nativeGainNode.connect(connection[0], 0, connection[2]);\n                            auxiliaryGainNodes.set(input, nativeGainNode);\n                        }\n                    }\n                }\n                catch (err) {\n                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.\n                    if (err.code === 12) {\n                        throw createInvalidAccessError();\n                    }\n                    throw err;\n                }\n                const isNewConnectionToAudioNode = isOffline\n                    ? addConnectionToAudioNodeOfOfflineAudioContext(this, destination, output, input)\n                    : addConnectionToAudioNodeOfAudioContext(this, destination, output, input);\n                // Bug #164: Only Firefox detects cycles so far.\n                if (isNewConnectionToAudioNode) {\n                    const cycles = detectCycles([this], destination);\n                    visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n                }\n                return destination;\n            }\n            const nativeAudioParam = getNativeAudioParam(destination);\n            /*\n             * Bug #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari.\n             */\n            if (nativeAudioParam.name === 'playbackRate') {\n                throw createNotSupportedError();\n            }\n            try {\n                this._nativeAudioNode.connect(nativeAudioParam, output);\n                if (isOffline || isPassiveAudioNode(this)) {\n                    this._nativeAudioNode.disconnect(nativeAudioParam, output);\n                }\n            }\n            catch (err) {\n                // Bug #58: Only Firefox does throw an InvalidStateError yet.\n                if (err.code === 12) {\n                    throw createInvalidAccessError();\n                }\n                throw err;\n            }\n            const isNewConnectionToAudioParam = isOffline\n                ? addConnectionToAudioParamOfOfflineAudioContext(this, destination, output)\n                : addConnectionToAudioParamOfAudioContext(this, destination, output);\n            // Bug #164: Only Firefox detects cycles so far.\n            if (isNewConnectionToAudioParam) {\n                const cycles = detectCycles([this], destination);\n                visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n            }\n        }\n        disconnect(destinationOrOutput, output, input) {\n            let destinations;\n            if (destinationOrOutput === undefined) {\n                destinations = deleteAnyConnection(this);\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                    throw createIndexSizeError();\n                }\n                destinations = deleteConnectionAtOutput(this, destinationOrOutput);\n            }\n            else {\n                if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                    throw createIndexSizeError();\n                }\n                if (isAudioNode(destinationOrOutput)\n                    && input !== undefined\n                    && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                    throw createIndexSizeError();\n                }\n                destinations = deleteConnectionToDestination(this, destinationOrOutput, output, input);\n                if (destinations.length === 0) {\n                    throw createInvalidAccessError();\n                }\n            }\n            // Bug #164: Only Firefox detects cycles so far.\n            for (const destination of destinations) {\n                const cycles = detectCycles([this], destination);\n                visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-node-constructor.js.map","export const cloneAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {\n    return new Promise((resolve, reject) => {\n        const { port1, port2 } = new MessageChannel();\n        port1.onmessage = ({ data }) => {\n            port1.close();\n            port2.close();\n            resolve(data);\n        };\n        port1.onmessageerror = ({ data }) => {\n            port1.close();\n            port2.close();\n            reject(data);\n        };\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port2.postMessage(audioWorkletNodeOptions);\n    });\n};\n//# sourceMappingURL=/build/es2019/helpers/clone-audio-worklet-node-options.js.map","import { cloneAudioWorkletNodeOptions } from './clone-audio-worklet-node-options';\nexport const createAudioWorkletProcessorPromise = async (processorConstructor, audioWorkletNodeOptions) => {\n    const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);\n    return new processorConstructor(clonedAudioWorkletNodeOptions);\n};\n//# sourceMappingURL=/build/es2019/helpers/create-audio-worklet-processor-promise.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport const createNativeAudioWorkletNodeFakerFactory = (auxiliaryGainNodeStore, connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, monitorConnections) => {\n    return (nativeContext, baseLatency, processorConstructor, options) => {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n            throw createNotSupportedError();\n        }\n        if (options.outputChannelCount !== undefined) {\n            // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n            if (options.outputChannelCount.some((channelCount) => (channelCount < 1))) {\n                throw createNotSupportedError();\n            }\n            if (options.outputChannelCount.length !== options.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n        }\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n            throw createNotSupportedError();\n        }\n        const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const numberOfParameters = (processorConstructor.parameterDescriptors === undefined)\n            ? 0\n            : processorConstructor.parameterDescriptors.length;\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n            throw createNotSupportedError();\n        }\n        const messageChannel = new MessageChannel();\n        const gainNodes = [];\n        const inputChannelSplitterNodes = [];\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes.push(createNativeGainNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n            }));\n            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n            }));\n        }\n        const constantSourceNodes = [];\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: (options.parameterData[name] !== undefined)\n                        ? options.parameterData[name]\n                        : (defaultValue === undefined)\n                            ? 0\n                            : defaultValue\n                });\n                Object.defineProperties(constantSourceNode.offset, {\n                    defaultValue: {\n                        get: () => (defaultValue === undefined) ? 0 : defaultValue\n                    },\n                    maxValue: {\n                        get: () => (maxValue === undefined) ? MOST_POSITIVE_SINGLE_FLOAT : maxValue\n                    },\n                    minValue: {\n                        get: () => (minValue === undefined) ? MOST_NEGATIVE_SINGLE_FLOAT : minValue\n                    }\n                });\n                constantSourceNodes.push(constantSourceNode);\n            }\n        }\n        const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, \n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        Math.max(1, numberOfOutputChannels));\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n        for (let i = 0; i < options.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: options.outputChannelCount[i]\n            }));\n        }\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n            for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, (i * options.channelCount) + j);\n            }\n        }\n        const parameterMap = new ReadOnlyMap((processorConstructor.parameterDescriptors === undefined)\n            ? []\n            : processorConstructor.parameterDescriptors\n                .map(({ name }, index) => {\n                const constantSourceNode = constantSourceNodes[index];\n                constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                constantSourceNode.start(0);\n                return [name, constantSourceNode.offset];\n            }));\n        inputChannelMergerNode.connect(scriptProcessorNode);\n        let channelInterpretation = options.channelInterpretation;\n        let onprocessorerror = null;\n        // Bug #87: Expose at least one output to make this node connectable.\n        const outputAudioNodes = (options.numberOfOutputs === 0) ? [scriptProcessorNode] : outputChannelMergerNodes;\n        const nativeAudioWorkletNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return options.channelCount;\n            },\n            set channelCount(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelCountMode() {\n                return options.channelCountMode;\n            },\n            set channelCountMode(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelInterpretation() {\n                return channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                for (const gainNode of gainNodes) {\n                    gainNode.channelInterpretation = value;\n                }\n                channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return gainNodes;\n            },\n            get numberOfInputs() {\n                return options.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return options.numberOfOutputs;\n            },\n            get onprocessorerror() {\n                return onprocessorerror;\n            },\n            set onprocessorerror(value) {\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n                }\n                onprocessorerror = (typeof value === 'function') ? value : null;\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n                }\n            },\n            get parameters() {\n                return parameterMap;\n            },\n            get port() {\n                return messageChannel.port2;\n            },\n            addEventListener(...args) {\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n            disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        const patchedEventListeners = new Map(); // tslint:disable-line:max-line-length\n        messageChannel.port1.addEventListener = ((addEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const unpatchedEventListener = (typeof args[1] === 'function')\n                        ? args[1]\n                        : (typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function')\n                            ? args[1].handleEvent\n                            : null;\n                    if (unpatchedEventListener !== null) {\n                        const patchedEventListener = patchedEventListeners.get(args[1]);\n                        if (patchedEventListener !== undefined) {\n                            args[1] = patchedEventListener;\n                        }\n                        else {\n                            args[1] = (event) => {\n                                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));\n                            };\n                            patchedEventListeners.set(unpatchedEventListener, args[1]);\n                        }\n                    }\n                }\n                return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.addEventListener);\n        messageChannel.port1.removeEventListener = ((removeEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const patchedEventListener = patchedEventListeners.get(args[1]);\n                    if (patchedEventListener !== undefined) {\n                        patchedEventListeners.delete(args[1]);\n                        args[1] = patchedEventListener;\n                    }\n                }\n                return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.removeEventListener);\n        let onmessage = null;\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n            get: () => onmessage,\n            set: (value) => {\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.removeEventListener('message', onmessage);\n                }\n                onmessage = (typeof value === 'function') ? value : null;\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.addEventListener('message', onmessage);\n                    messageChannel.port1.start();\n                }\n            }\n        });\n        processorConstructor.prototype.port = messageChannel.port1;\n        let audioWorkletProcessor = null;\n        const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n        audioWorkletProcessorPromise\n            .then((dWrkltPrcssr) => audioWorkletProcessor = dWrkltPrcssr);\n        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n        const parameters = (processorConstructor.parameterDescriptors === undefined) ?\n            [] :\n            processorConstructor.parameterDescriptors\n                .reduce((prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n        let isActive = true;\n        const disconnectOutputsGraph = () => {\n            if (options.numberOfOutputs > 0) {\n                scriptProcessorNode.disconnect(outputChannelSplitterNode);\n            }\n            for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                const outputChannelMergerNode = outputChannelMergerNodes[i];\n                for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                    outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                }\n                outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n            }\n        };\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }) => {\n            if (audioWorkletProcessor !== null) {\n                for (let i = 0; i < bufferSize; i += 128) {\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(inputBuffer, inputs[j], k, k, i);\n                        }\n                    }\n                    if (processorConstructor.parameterDescriptors !== undefined) {\n                        processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                            copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                    }\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                            // The byteLength will be 0 when the ArrayBuffer was transferred.\n                            if (outputs[j][k].byteLength === 0) {\n                                outputs[j][k] = new Float32Array(128);\n                            }\n                        }\n                    }\n                    try {\n                        const potentiallyEmptyInputs = inputs\n                            .map((input, index) => {\n                            const auxiliaryGainNodes = auxiliaryGainNodeStore.get(nativeAudioWorkletNodeFaker);\n                            if (auxiliaryGainNodes === undefined || auxiliaryGainNodes.get(index) === undefined) {\n                                return [];\n                            }\n                            return input;\n                        });\n                        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + (i / nativeContext.sampleRate), nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n                        isActive = activeSourceFlag;\n                        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                            }\n                            outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n                        }\n                    }\n                    catch (error) {\n                        isActive = false;\n                        nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', { error }));\n                    }\n                    if (!isActive) {\n                        for (let j = 0; j < options.numberOfInputs; j += 1) {\n                            gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n                            for (let k = 0; k < options.channelCount; k += 1) {\n                                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, (j * options.channelCount) + k);\n                            }\n                        }\n                        if (processorConstructor.parameterDescriptors !== undefined) {\n                            const length = processorConstructor.parameterDescriptors.length;\n                            for (let j = 0; j < length; j += 1) {\n                                const constantSourceNode = constantSourceNodes[j];\n                                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                                constantSourceNode.stop();\n                            }\n                        }\n                        inputChannelMergerNode.disconnect(scriptProcessorNode);\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        if (isConnected) {\n                            disconnectOutputsGraph();\n                        }\n                        else {\n                            disconnectFakeGraph();\n                        }\n                        break;\n                    }\n                }\n            }\n        };\n        let isConnected = false;\n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        const nativeGainNode = createNativeGainNode(nativeContext, { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete', gain: 0 });\n        const connectFakeGraph = () => scriptProcessorNode\n            .connect(nativeGainNode)\n            /*\n             * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is used here\n             * to make sure to connect the right destination.\n             */\n            .connect(nativeGainNode.context.destination);\n        const disconnectFakeGraph = () => {\n            scriptProcessorNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n        const whenConnected = () => {\n            if (isActive) {\n                disconnectFakeGraph();\n                if (options.numberOfOutputs > 0) {\n                    scriptProcessorNode.connect(outputChannelSplitterNode);\n                }\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n                }\n            }\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            if (isActive) {\n                connectFakeGraph();\n                disconnectOutputsGraph();\n            }\n            isConnected = false;\n        };\n        connectFakeGraph();\n        return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-audio-worklet-node-faker-factory.js.map","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { createAudioWorkletProcessorPromise } from './create-audio-worklet-processor-promise';\nexport const createAudioWorkletProcessor = (nativeContext, nativeAudioWorkletNode, processorConstructor, audioWorkletNodeOptions) => {\n    let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);\n    if (nodeToProcessorMap === undefined) {\n        nodeToProcessorMap = new WeakMap();\n        NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);\n    }\n    const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);\n    nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);\n    return audioWorkletProcessorPromise;\n};\n//# sourceMappingURL=/build/es2019/helpers/create-audio-worklet-processor.js.map","const handler = {\n    construct() {\n        return handler;\n    }\n};\nexport const isConstructible = (constructible) => {\n    try {\n        const proxy = new Proxy(constructible, handler);\n        new proxy(); // tslint:disable-line:no-unused-expression\n    }\n    catch {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=/build/es2019/helpers/is-constructible.js.map","/*\n * This massive regex tries to cover all the following cases.\n *\n * import './path';\n * import defaultImport from './path';\n * import { namedImport } from './path';\n * import { namedImport as renamendImport } from './path';\n * import * as namespaceImport from './path';\n * import defaultImport, { namedImport } from './path';\n * import defaultImport, { namedImport as renamendImport } from './path';\n * import defaultImport, * as namespaceImport from './path';\n */\nconst IMPORT_STATEMENT_REGEX = /^import(?:(?:[\\s]+[\\w]+|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\{[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?(?:[\\s]*,[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?)*[\\s]*}|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\*[\\s]+as[\\s]+[\\w]+)[\\s]+from)?(?:[\\s]*)(\"([^\"\\\\]|\\\\.)+\"|'([^'\\\\]|\\\\.)+')(?:[\\s]*);?/; // tslint:disable-line:max-line-length\nexport const splitImportStatements = (source, url) => {\n    const importStatements = [];\n    let sourceWithoutImportStatements = source.replace(/^[\\s]+/, '');\n    let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    while (result !== null) {\n        const unresolvedUrl = result[1].slice(1, -1);\n        const importStatementWithResolvedUrl = result[0]\n            .replace(/([\\s]+)?;?$/, '')\n            .replace(unresolvedUrl, (new URL(unresolvedUrl, url)).toString());\n        importStatements.push(importStatementWithResolvedUrl);\n        sourceWithoutImportStatements = sourceWithoutImportStatements\n            .slice(result[0].length)\n            .replace(/^[\\s]+/, '');\n        result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    }\n    return [importStatements.join(';'), sourceWithoutImportStatements];\n};\n//# sourceMappingURL=/build/es2019/helpers/split-import-statements.js.map","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\nconst verifyParameterDescriptors = (parameterDescriptors) => {\n    if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n        throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n    }\n};\nconst verifyProcessorCtor = (processorCtor) => {\n    if (!isConstructible(processorCtor)) {\n        throw new TypeError('The given value for processorCtor should be a constructor.');\n    }\n    if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n        throw new TypeError('The given value for processorCtor should have a prototype.');\n    }\n};\nexport const createAddAudioWorkletModule = (createNotSupportedError, evaluateSource, exposeCurrentFrameAndCurrentTime, fetchSource, getBackupNativeContext, getNativeContext, ongoingRequests, resolvedRequests, window) => {\n    return (context, moduleURL, options = { credentials: 'omit' }) => {\n        const nativeContext = getNativeContext(context);\n        const absoluteUrl = (new URL(moduleURL, window.location.href)).toString();\n        // Bug #59: Only Chrome & Opera do implement the audioWorklet property.\n        if (nativeContext.audioWorklet !== undefined) {\n            return fetchSource(moduleURL)\n                .then((source) => {\n                const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n                /*\n                 * Bug #170: Chrome and Opera do call process() with an array with empty channelData for each input if no input is\n                 * connected.\n                 *\n                 * This is the unminified version of the code used below:\n                 *\n                 * ```js\n                 * `${ importStatements };\n                 * ((registerProcessor) => {${ sourceWithoutImportStatements }\n                 * })((name, processorCtor) => registerProcessor(name, class extends processorCtor {\n                 *\n                 *     process (inputs, outputs, parameters) {\n                 *         return super.process(\n                 *             (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n                 *             outputs,\n                 *             parameters\n                 *         );\n                 *     }\n                 *\n                 * }))`\n                 * ```\n                 */\n                const wrappedSource = `${importStatements};(registerProcessor=>{${sourceWithoutImportStatements}\n})((n,p)=>registerProcessor(n,class extends p{process(i,o,p){return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}))`; // tslint:disable-line:max-line-length\n                const blob = new Blob([wrappedSource], { type: 'application/javascript; charset=utf-8' });\n                const url = URL.createObjectURL(blob);\n                const backupNativeContext = getBackupNativeContext(nativeContext);\n                const nativeContextOrBackupNativeContext = (backupNativeContext !== null) ? backupNativeContext : nativeContext;\n                return nativeContextOrBackupNativeContext.audioWorklet\n                    .addModule(url, options)\n                    .then(() => URL.revokeObjectURL(url))\n                    // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n                    .catch((err) => {\n                    URL.revokeObjectURL(url);\n                    if (err.code === undefined || err.name === 'SyntaxError') {\n                        err.code = 12;\n                    }\n                    throw err;\n                });\n            });\n        }\n        const resolvedRequestsOfContext = resolvedRequests.get(context);\n        if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n            return Promise.resolve();\n        }\n        const ongoingRequestsOfContext = ongoingRequests.get(context);\n        if (ongoingRequestsOfContext !== undefined) {\n            const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n            if (promiseOfOngoingRequest !== undefined) {\n                return promiseOfOngoingRequest;\n            }\n        }\n        const promise = fetchSource(moduleURL)\n            .then((source) => {\n            const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n            /*\n             * This is the unminified version of the code used below:\n             *\n             * ```js\n             * ${ importStatements };\n             * ((a, b) => {\n             *     (a[b] = a[b] || [ ]).push(\n             *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n             *             ${ sourceWithoutImportStatements }\n             *         }\n             *     );\n             * })(window, '_AWGS');\n             * ```\n             */\n            // tslint:disable-next-line:max-line-length\n            const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`;\n            // @todo Evaluating the given source code is a possible security problem.\n            return evaluateSource(wrappedSource);\n        })\n            .then(() => {\n            const evaluateAudioWorkletGlobalScope = window._AWGS.pop();\n            if (evaluateAudioWorkletGlobalScope === undefined) {\n                throw new SyntaxError();\n            }\n            exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {\n            }, undefined, (name, processorCtor) => {\n                if (name.trim() === '') {\n                    throw createNotSupportedError();\n                }\n                const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n                if (nodeNameToProcessorConstructorMap !== undefined) {\n                    if (nodeNameToProcessorConstructorMap.has(name)) {\n                        throw createNotSupportedError();\n                    }\n                    verifyProcessorCtor(processorCtor);\n                    verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                    nodeNameToProcessorConstructorMap.set(name, processorCtor);\n                }\n                else {\n                    verifyProcessorCtor(processorCtor);\n                    verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                    NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n                }\n            }, nativeContext.sampleRate, undefined, undefined));\n        })\n            .catch((err) => {\n            if (err.code === undefined || err.name === 'SyntaxError') {\n                err.code = 12;\n            }\n            throw err;\n        });\n        if (ongoingRequestsOfContext === undefined) {\n            ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n        }\n        else {\n            ongoingRequestsOfContext.set(moduleURL, promise);\n        }\n        promise\n            .then(() => {\n            const rslvdRqstsFCntxt = resolvedRequests.get(context);\n            if (rslvdRqstsFCntxt === undefined) {\n                resolvedRequests.set(context, new Set([moduleURL]));\n            }\n            else {\n                rslvdRqstsFCntxt.add(moduleURL);\n            }\n        })\n            .catch(() => { }) // tslint:disable-line:no-empty\n            // @todo Use finally when it becomes available in all supported browsers.\n            .then(() => {\n            const ngngRqstsFCntxt = ongoingRequests.get(context);\n            if (ngngRqstsFCntxt !== undefined) {\n                ngngRqstsFCntxt.delete(moduleURL);\n            }\n        });\n        return promise;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/add-audio-worklet-module.js.map","export const testAnalyserNodeGetFloatTimeDomainDataMethodSupport = (nativeAnalyserNode) => {\n    return typeof nativeAnalyserNode.getFloatTimeDomainData === 'function';\n};\n//# sourceMappingURL=/build/es2019/helpers/test-analyser-node-get-float-time-domain-data-method-support.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { testAnalyserNodeGetFloatTimeDomainDataMethodSupport } from '../helpers/test-analyser-node-get-float-time-domain-data-method-support';\nimport { wrapAnalyserNodeGetFloatTimeDomainDataMethod } from '../helpers/wrap-analyser-node-get-float-time-domain-data-method';\nexport const createNativeAnalyserNodeFactory = (cacheTestResult, createIndexSizeError, createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeAnalyserNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createAnalyser());\n        // Bug #37: Firefox does not create an AnalyserNode with the default properties.\n        assignNativeAudioNodeOptions(nativeAnalyserNode, options);\n        // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n        if (!(options.maxDecibels > options.minDecibels)) {\n            throw createIndexSizeError();\n        }\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'fftSize');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'maxDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'minDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'smoothingTimeConstant');\n        // Bug #36: Safari does not support getFloatTimeDomainData() yet.\n        if (!cacheTestResult(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () => testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode))) {\n            wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);\n        }\n        return nativeAnalyserNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-analyser-node-factory.js.map","export const wrapAnalyserNodeGetFloatTimeDomainDataMethod = (nativeAnalyserNode) => {\n    nativeAnalyserNode.getFloatTimeDomainData = (array) => {\n        const byteTimeDomainData = new Uint8Array(array.length);\n        nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);\n        const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);\n        for (let i = 0; i < length; i += 1) {\n            array[i] = (byteTimeDomainData[i] - 128) * 0.0078125;\n        }\n        return array;\n    };\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-analyser-node-get-float-time-domain-data-method.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioBufferSourceNodeStartMethodConsecutiveCalls } from '../helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls';\nimport { wrapAudioBufferSourceNodeStartMethodDurationParameter } from '../helpers/wrap-audio-buffer-source-node-start-method-duration-parameter';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeAudioBufferSourceNodeFactory = (addSilentConnection, cacheTestResult, createNativeAudioNode, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodDurationParameterSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n    return (nativeContext, options = {}) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate');\n        // Bug #71: Edge does not allow to set the buffer to null.\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer');\n        // Bug #149: Safari does not yet support the detune AudioParam.\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart');\n        // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, () => testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n        }\n        // Bug #92: Chrome & Edge do not respect the duration parameter yet.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodDurationParameterSupport, testAudioBufferSourceNodeStartMethodDurationParameterSupport)) {\n            wrapAudioBufferSourceNodeStartMethodDurationParameter(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, () => testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n        }\n        // Bug #162: Safari does throw an error when stop() is called on an AudioBufferSourceNode which has no buffer assigned to it.\n        if (!cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, () => testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Only Chrome, Firefox & Opera throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeAudioBufferSourceNode);\n        return nativeAudioBufferSourceNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-audio-buffer-source-node-factory.js.map","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = (nativeAudioBufferSourceNode) => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        let isScheduled = false;\n        return (when = 0, offset = 0, duration) => {\n            if (isScheduled) {\n                throw createInvalidStateError();\n            }\n            start.call(nativeAudioBufferSourceNode, when, offset, duration);\n            isScheduled = true;\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js.map","export const wrapAudioBufferSourceNodeStartMethodDurationParameter = (nativeAudioScheduledSourceNode, nativeContext) => {\n    let endTime = Number.POSITIVE_INFINITY;\n    let stopTime = Number.POSITIVE_INFINITY;\n    nativeAudioScheduledSourceNode.start = ((start, stop) => {\n        return (when = 0, offset = 0, duration = Number.POSITIVE_INFINITY) => {\n            start.call(nativeAudioScheduledSourceNode, when, offset);\n            if (duration >= 0 && duration < Number.POSITIVE_INFINITY) {\n                const actualStartTime = Math.max(when, nativeContext.currentTime);\n                // @todo The playbackRate could of course also have been automated and is not always fixed.\n                const durationInBufferTime = (duration / nativeAudioScheduledSourceNode.playbackRate.value);\n                endTime = actualStartTime + durationInBufferTime;\n                stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n            }\n        };\n    })(nativeAudioScheduledSourceNode.start, nativeAudioScheduledSourceNode.stop);\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            stopTime = Math.max(when, nativeContext.currentTime);\n            stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-duration-parameter.js.map","import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = (renderedBuffer === null) ? (Math.ceil(proxy.context.length / 128) * 128) : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer = (numberOfOutputChannels === 0) ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n    const parameters = Array\n        .from(proxy.parameters.keys())\n        .reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n        try {\n            const potentiallyEmptyInputs = inputs\n                .map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [];\n                }\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n                }\n            }\n            if (!activeSourceFlag) {\n                break;\n            }\n        }\n        catch (error) {\n            proxy.dispatchEvent(new ErrorEvent('processorerror', { error }));\n            break;\n        }\n    }\n    return processedBuffer;\n};\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (name, options, processorConstructor) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let processedBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n            let nativeOutputNodes = null;\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes = [];\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: options.outputChannelCount[i]\n                    }));\n                }\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n                outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            }\n            else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, (nativeOutputNodes === null) ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters = (processorConstructor.parameterDescriptors === undefined)\n                        ? 0\n                        : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, \n                        // Ceil the length to the next full render quantum.\n                        // Bug #17: Safari does not yet expose the length.\n                        Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                        const gainNodes = [];\n                        const inputChannelSplitterNodes = [];\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: options.channelCountMode,\n                                channelInterpretation: options.channelInterpretation,\n                                gain: 1\n                            }));\n                            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                numberOfOutputs: options.channelCount\n                            }));\n                        }\n                        const constantSourceNodes = await Promise\n                            .all(Array\n                            .from(proxy.parameters.values())\n                            .map(async (audioParam) => {\n                            const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                channelCount: 1,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                offset: audioParam.value\n                            });\n                            await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace);\n                            return constantSourceNode;\n                        }));\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, (i * options.channelCount) + j);\n                            }\n                        }\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                        await Promise\n                            .all(gainNodes\n                            .map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace)));\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n                    processedBufferPromise = processBuffer(proxy, (numberOfChannels === 0) ? null : await renderBuffer(), nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime);\n                }\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n                }\n                return outputGainNode;\n            }\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace);\n            return nativeAudioWorkletNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-worklet-node-renderer-factory.js.map","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { getNativeAudioNode } from './get-native-audio-node';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioWorkletProcessor = (nativeOfflineAudioContext, proxy) => {\n    const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);\n    const nativeAudioWorkletNode = getNativeAudioNode(proxy);\n    return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);\n};\n//# sourceMappingURL=/build/es2019/helpers/get-audio-worklet-processor.js.map","import { detachArrayBuffer } from '../helpers/detach-array-buffer';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createDecodeAudioData = (audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, detachedArrayBuffers, getNativeContext, isNativeContext, isNativeOfflineAudioContext, nativeOfflineAudioContextConstructor, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    return (anyContext, audioData) => {\n        const nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext);\n        // Bug #43: Only Chrome and Opera do throw a DataCloneError.\n        if (detachedArrayBuffers.has(audioData)) {\n            const err = createDataCloneError();\n            return Promise.reject(err);\n        }\n        // The audioData parameter maybe of a type which can't be added to a WeakSet.\n        try {\n            detachedArrayBuffers.add(audioData);\n        }\n        catch {\n            // Ignore errors.\n        }\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeContext))) {\n            // Bug #101: Edge does not decode something on a closed OfflineAudioContext.\n            const nativeContextOrBackupNativeContext = (nativeContext.state === 'closed' &&\n                nativeOfflineAudioContextConstructor !== null &&\n                isNativeOfflineAudioContext(nativeContext)) ?\n                new nativeOfflineAudioContextConstructor(1, 1, nativeContext.sampleRate) :\n                nativeContext;\n            const promise = nativeContextOrBackupNativeContext\n                .decodeAudioData(audioData)\n                .catch((err) => {\n                // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.\n                if (err instanceof DOMException && err.name === 'NotSupportedError') {\n                    throw new TypeError();\n                }\n                throw err;\n            });\n            return promise\n                .then((audioBuffer) => {\n                // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n                if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                }\n                audioBufferStore.add(audioBuffer);\n                return audioBuffer;\n            });\n        }\n        // Bug #21: Safari does not return a Promise yet.\n        return new Promise((resolve, reject) => {\n            const complete = () => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                try {\n                    detachArrayBuffer(audioData);\n                }\n                catch { /* Ignore errors. */ }\n            };\n            const fail = (err) => {\n                reject(err);\n                complete();\n            };\n            // Bug #26: Safari throws a synchronous error.\n            try {\n                // Bug #1: Safari requires a successCallback.\n                nativeContext.decodeAudioData(audioData, (audioBuffer) => {\n                    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n                    // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n                    if (typeof audioBuffer.copyFromChannel !== 'function') {\n                        wrapAudioBufferCopyChannelMethods(audioBuffer);\n                        wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                    }\n                    audioBufferStore.add(audioBuffer);\n                    complete();\n                    resolve(audioBuffer);\n                }, (err) => {\n                    // Bug #4: Safari returns null instead of an error.\n                    if (err === null) {\n                        fail(createEncodingError());\n                    }\n                    else {\n                        fail(err);\n                    }\n                });\n            }\n            catch (err) {\n                fail(err);\n            }\n        });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/decode-audio-data.js.map","export const detachArrayBuffer = (arrayBuffer) => {\n    const { port1 } = new MessageChannel();\n    port1.postMessage(arrayBuffer, [arrayBuffer]);\n};\n//# sourceMappingURL=/build/es2019/helpers/detach-array-buffer.js.map","export const isDelayNode = (audioNode) => {\n    return 'delayTime' in audioNode;\n};\n//# sourceMappingURL=/build/es2019/guards/delay-node.js.map","import { isAudioNode } from '../guards/audio-node';\nimport { isDelayNode } from '../guards/delay-node';\nexport const createDetectCycles = (audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) => {\n    return function detectCycles(chain, nextLink) {\n        const audioNode = (isAudioNode(nextLink))\n            ? nextLink\n            : getValueForKey(audioParamAudioNodeStore, nextLink);\n        if (isDelayNode(audioNode)) {\n            return [];\n        }\n        if (chain[0] === audioNode) {\n            return [chain];\n        }\n        if (chain.includes(audioNode)) {\n            return [];\n        }\n        const { outputs } = getAudioNodeConnections(audioNode);\n        return Array\n            .from(outputs)\n            .map((outputConnection) => detectCycles([...chain, audioNode], outputConnection[0]))\n            .reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/detect-cycles.js.map","import { createInvalidAccessError } from '../factories/invalid-access-error';\nexport const wrapIIRFilterNodeGetFrequencyResponseMethod = (nativeIIRFilterNode) => {\n    nativeIIRFilterNode.getFrequencyResponse = ((getFrequencyResponse) => {\n        return (frequencyHz, magResponse, phaseResponse) => {\n            if ((frequencyHz.length !== magResponse.length) || (magResponse.length !== phaseResponse.length)) {\n                throw createInvalidAccessError();\n            }\n            return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);\n        };\n    })(nativeIIRFilterNode.getFrequencyResponse);\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-iir-filter-node-get-frequency-response-method.js.map","import { wrapIIRFilterNodeGetFrequencyResponseMethod } from '../helpers/wrap-iir-filter-node-get-frequency-response-method';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers'\n};\nexport const createIIRFilterNodeConstructor = (audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext) => {\n    return class IIRFilterNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeIIRFilterNode = createNativeIIRFilterNode(nativeContext, isOffline ? null : context.baseLatency, mergedOptions);\n            const iirFilterNodeRenderer = ((isOffline)\n                ? createIIRFilterNodeRenderer(mergedOptions.feedback, mergedOptions.feedforward)\n                : null);\n            super(context, false, nativeIIRFilterNode, iirFilterNodeRenderer);\n            // Bug #23 & #24: FirefoxDeveloper does not throw an InvalidAccessError.\n            // @todo Write a test which allows other browsers to remain unpatched.\n            wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);\n            this._nativeIIRFilterNode = nativeIIRFilterNode;\n        }\n        getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/iir-filter-node-constructor.js.map","export const testClonabilityOfAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {\n    const { port1 } = new MessageChannel();\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    }\n    finally {\n        port1.close();\n    }\n};\n//# sourceMappingURL=/build/es2019/helpers/test-clonability-of-audio-worklet-node-options.js.map","import { testClonabilityOfAudioWorkletNodeOptions } from '../helpers/test-clonability-of-audio-worklet-node-options';\nexport const createNativeAudioWorkletNodeFactory = (createInvalidStateError, createNativeAudioNode, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections) => {\n    return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) => {\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            try {\n                const nativeAudioWorkletNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n                    return new nativeAudioWorkletNodeConstructor(ntvCntxt, name, options);\n                });\n                const patchedEventListeners = new Map(); // tslint:disable-line:max-line-length\n                let onprocessorerror = null;\n                Object.defineProperties(nativeAudioWorkletNode, {\n                    /*\n                     * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n                     * browsers have no native implementation to achieve a consistent behavior.\n                     */\n                    channelCount: {\n                        get: () => options.channelCount,\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    channelCountMode: {\n                        get: () => 'explicit',\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    // Bug #156: Chrome & Opera do not yet fire an ErrorEvent.\n                    onprocessorerror: {\n                        get: () => onprocessorerror,\n                        set: (value) => {\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n                            }\n                            onprocessorerror = (typeof value === 'function') ? value : null;\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n                            }\n                        }\n                    }\n                });\n                nativeAudioWorkletNode.addEventListener = ((addEventListener) => {\n                    return (...args) => {\n                        if (args[0] === 'processorerror') {\n                            const unpatchedEventListener = (typeof args[1] === 'function')\n                                ? args[1]\n                                : (typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function')\n                                    ? args[1].handleEvent\n                                    : null;\n                            if (unpatchedEventListener !== null) {\n                                const patchedEventListener = patchedEventListeners.get(args[1]);\n                                if (patchedEventListener !== undefined) {\n                                    args[1] = patchedEventListener;\n                                }\n                                else {\n                                    args[1] = (event) => {\n                                        unpatchedEventListener(new ErrorEvent(args[0], { ...event, error: new Error( /* @todo */) }));\n                                    };\n                                    patchedEventListeners.set(unpatchedEventListener, args[1]);\n                                }\n                            }\n                        }\n                        return addEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.addEventListener);\n                nativeAudioWorkletNode.removeEventListener = ((removeEventListener) => {\n                    return (...args) => {\n                        if (args[0] === 'processorerror') {\n                            const patchedEventListener = patchedEventListeners.get(args[1]);\n                            if (patchedEventListener !== undefined) {\n                                patchedEventListeners.delete(args[1]);\n                                args[1] = patchedEventListener;\n                            }\n                        }\n                        return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.removeEventListener);\n                /*\n                 * Bug #86: Chrome & Opera do not invoke the process() function if the corresponding AudioWorkletNode is unconnected but has\n                 * an output.\n                 */\n                if (options.numberOfOutputs !== 0) {\n                    const nativeGainNode = createNativeGainNode(nativeContext, { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete', gain: 0 });\n                    nativeAudioWorkletNode\n                        .connect(nativeGainNode)\n                        /*\n                         * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is\n                         * used here to make sure to connect the right destination.\n                         */\n                        .connect(nativeGainNode.context.destination);\n                    const whenConnected = () => nativeGainNode.disconnect();\n                    /*\n                     * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is\n                     * used here to make sure to connect the right destination.\n                     */\n                    const whenDisconnected = () => nativeGainNode.connect(nativeGainNode.context.destination);\n                    // @todo Disconnect the connection when the process() function of the AudioWorkletNode returns false.\n                    return monitorConnections(nativeAudioWorkletNode, whenConnected, whenDisconnected);\n                }\n                return nativeAudioWorkletNode;\n            }\n            catch (err) {\n                // Bug #60: Chrome & Opera throw an InvalidStateError instead of a NotSupportedError.\n                if (err.code === 11) {\n                    throw createNotSupportedError();\n                }\n                throw err;\n            }\n        }\n        // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n        if (processorConstructor === undefined) {\n            throw createNotSupportedError();\n        }\n        testClonabilityOfAudioWorkletNodeOptions(options);\n        return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-audio-worklet-node-factory.js.map","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapChannelSplitterNode = (channelSplitterNode) => {\n    const channelCount = channelSplitterNode.numberOfOutputs;\n    // Bug #97: Safari does not throw an error when attempting to change the channelCount to something other than its initial value.\n    Object.defineProperty(channelSplitterNode, 'channelCount', {\n        get: () => channelCount,\n        set: (value) => {\n            if (value !== channelCount) {\n                throw createInvalidStateError();\n            }\n        }\n    });\n    /*\n     * Bug #30: Only Chrome, Firefox & Opera throw an error when attempting to change the channelCountMode to something other than\n     * explicit.\n     */\n    Object.defineProperty(channelSplitterNode, 'channelCountMode', {\n        get: () => 'explicit',\n        set: (value) => {\n            if (value !== 'explicit') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n    /*\n     * Bug #32: Only Chrome, Firefox & Opera throws an error when attempting to change the channelInterpretation to something other than\n     * discrete.\n     */\n    Object.defineProperty(channelSplitterNode, 'channelInterpretation', {\n        get: () => 'discrete',\n        set: (value) => {\n            if (value !== 'discrete') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-channel-splitter-node.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapChannelSplitterNode } from '../helpers/wrap-channel-splitter-node';\nexport const createNativeChannelSplitterNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeChannelSplitterNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createChannelSplitter(options.numberOfOutputs);\n        });\n        // Bug #96: Safari does not have the correct channelCount.\n        // Bug #29: Edge & Safari do not have the correct channelCountMode.\n        // Bug #31: Edge & Safari do not have the correct channelInterpretation.\n        assignNativeAudioNodeOptions(nativeChannelSplitterNode, options);\n        // Bug #29, #30, #31, #32, #96 & #97: Only Chrome, Firefox & Opera partially support the spec yet.\n        wrapChannelSplitterNode(nativeChannelSplitterNode);\n        return nativeChannelSplitterNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-channel-splitter-node-factory.js.map","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","export const version: string = \"14.7.40\";\n","/**\n * Assert that the statement is true, otherwise invoke the error.\n * @param statement\n * @param error The message which is passed into an Error\n */\nexport function assert(statement: boolean, error: string): void {\n\tif (!statement) {\n\t\tthrow new Error(error);\n\t}\n}\n\n/**\n * Make sure that the given value is within the range\n */\nexport function assertRange(value: number, gte: number, lte = Infinity): void {\n\tif (!(gte <= value && value <= lte)) {\n\t\tthrow new RangeError(`Value must be within [${gte}, ${lte}], got: ${value}`);\n\t}\n}\n\n/**\n * Make sure that the given value is within the range\n */\nexport function assertContextRunning(context: import(\"../context/BaseContext\").BaseContext): void {\n\t// add a warning if the context is not started\n\tif (!context.isOffline && context.state !== \"running\") {\n\t\twarn(\"The AudioContext is \\\"suspended\\\". Invoke Tone.start() from a user action to start the audio.\");\n\t}\n}\n\n/**\n * A basic logging interface\n */\ninterface Logger {\n\tlog: (args?: any[]) => void;\n\twarn: (args?: any[]) => void;\n}\n\n/**\n * The default logger is the console\n */\nlet defaultLogger: Logger = console;\n\n/**\n * Set the logging interface\n */\nexport function setLogger(logger: Logger): void {\n\tdefaultLogger = logger;\n}\n\n/**\n * Log anything\n */\nexport function log(...args: any[]): void {\n\tdefaultLogger.log(...args);\n}\n\n/**\n * Warn anything\n */\nexport function warn(...args: any[]): void {\n\tdefaultLogger.warn(...args);\n}\n","import { Note } from \"../type/Units\";\n\n/**\n * Test if the arg is undefined\n */\nexport function isUndef(arg: any): arg is undefined {\n\treturn typeof arg === \"undefined\";\n}\n\n/**\n * Test if the arg is not undefined\n */\nexport function isDefined<T>(arg: T | undefined): arg is T {\n\treturn !isUndef(arg);\n}\n\n/**\n * Test if the arg is a function\n */\nexport function isFunction(arg: any): arg is (a: any) => any {\n\treturn typeof arg === \"function\";\n}\n\n/**\n * Test if the argument is a number.\n */\nexport function isNumber(arg: any): arg is number {\n\treturn (typeof arg === \"number\");\n}\n\n/**\n * Test if the given argument is an object literal (i.e. `{}`);\n */\nexport function isObject(arg: any): arg is object {\n\treturn (Object.prototype.toString.call(arg) === \"[object Object]\" && arg.constructor === Object);\n}\n\n/**\n * Test if the argument is a boolean.\n */\nexport function isBoolean(arg: any): arg is boolean {\n\treturn (typeof arg === \"boolean\");\n}\n\n/**\n * Test if the argument is an Array\n */\nexport function isArray(arg: any): arg is any[] {\n\treturn (Array.isArray(arg));\n}\n\n/**\n * Test if the argument is a string.\n */\nexport function isString(arg: any): arg is string {\n\treturn (typeof arg === \"string\");\n}\n\n/**\n * Test if the argument is in the form of a note in scientific pitch notation.\n * e.g. \"C4\"\n */\nexport function isNote(arg: any): arg is Note {\n\treturn isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);\n}\n","import {\n\tAudioContext as stdAudioContext,\n\tAudioWorkletNode as stdAudioWorkletNode,\n\tOfflineAudioContext as stdOfflineAudioContext\n} from \"standardized-audio-context\";\nimport { assert } from \"../util/Debug\";\nimport { isDefined } from \"../util/TypeCheck\";\n\n/**\n * Create a new AudioContext\n */\nexport function createAudioContext(options?: AudioContextOptions): AudioContext {\n\treturn new stdAudioContext(options) as unknown as AudioContext;\n}\n\n/**\n * Create a new OfflineAudioContext\n */\nexport function createOfflineAudioContext(channels: number, length: number, sampleRate: number): OfflineAudioContext {\n\treturn new stdOfflineAudioContext(channels, length, sampleRate) as unknown as OfflineAudioContext;\n}\n\n/**\n * Either the online or offline audio context\n */\nexport type AnyAudioContext = AudioContext | OfflineAudioContext;\n\n/**\n * Interface for things that Tone.js adds to the window\n */\ninterface ToneWindow extends Window {\n\tTONE_SILENCE_LOGGING?: boolean;\n\tTONE_DEBUG_CLASS?: string;\n}\n\n/**\n * A reference to the window object\n * @hidden\n */\nexport const theWindow: ToneWindow | null = typeof self === \"object\" ? self : null;\n\n/**\n * If the browser has a window object which has an AudioContext\n * @hidden\n */\nexport const hasAudioContext = theWindow &&\n\t(theWindow.hasOwnProperty(\"AudioContext\") || theWindow.hasOwnProperty(\"webkitAudioContext\"));\n\nexport function createAudioWorkletNode(context: AnyAudioContext, name: string, options?: Partial<AudioWorkletNodeOptions>): AudioWorkletNode {\n\tassert(isDefined(stdAudioWorkletNode), \"This node only works in a secure context (https or localhost)\");\n\t// @ts-ignore\n\treturn new stdAudioWorkletNode(context, name, options);\n}\n\n/**\n * This promise resolves to a boolean which indicates if the \n * functionality is supported within the currently used browse. \n * Taken from [standardized-audio-context](https://github.com/chrisguttandin/standardized-audio-context#issupported)\n */\nexport { isSupported as supported } from \"standardized-audio-context\";\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { Seconds } from \"../type/Units\";\n\nexport type TickerClockSource = \"worker\" | \"timeout\" | \"offline\";\n\n/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n\n\t/**\n\t * Either \"worker\" or \"timeout\" or \"offline\"\n\t */\n\tprivate _type: TickerClockSource;\n\n\t/**\n\t * The update interval of the worker\n\t */\n\tprivate _updateInterval: Seconds;\n\n\t/**\n\t * The callback to invoke at regular intervals\n\t */\n\tprivate _callback: () => void;\n\n\t/**\n\t * track the callback interval\n\t */\n\tprivate _timeout!: number;\n\n\t/**\n\t * private reference to the worker\n\t */\n\tprivate _worker!: Worker;\n\n\tconstructor(callback: () => void, type: TickerClockSource, updateInterval: Seconds) {\n\n\t\tthis._callback = callback;\n\t\tthis._type = type;\n\t\tthis._updateInterval = updateInterval;\n\n\t\t// create the clock source for the first time\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Generate a web worker\n\t */\n\tprivate _createWorker(): void {\n\n\t\tconst blob = new Blob([\n\t\t\t/* javascript */`\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`\n\t\t], { type: \"text/javascript\" });\n\t\tconst blobUrl = URL.createObjectURL(blob);\n\t\tconst worker = new Worker(blobUrl);\n\n\t\tworker.onmessage = this._callback.bind(this);\n\n\t\tthis._worker = worker;\n\t}\n\n\t/**\n\t * Create a timeout loop\n\t */\n\tprivate _createTimeout(): void {\n\t\tthis._timeout = setTimeout(() => {\n\t\t\tthis._createTimeout();\n\t\t\tthis._callback();\n\t\t}, this._updateInterval * 1000);\n\t}\n\n\t/**\n\t * Create the clock source.\n\t */\n\tprivate _createClock(): void {\n\t\tif (this._type === \"worker\") {\n\t\t\ttry {\n\t\t\t\tthis._createWorker();\n\t\t\t} catch (e) {\n\t\t\t\t// workers not supported, fallback to timeout\n\t\t\t\tthis._type = \"timeout\";\n\t\t\t\tthis._createClock();\n\t\t\t}\n\t\t} else if (this._type === \"timeout\") {\n\t\t\tthis._createTimeout();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up the current clock source\n\t */\n\tprivate _disposeClock(): void {\n\t\tif (this._timeout) {\n\t\t\tclearTimeout(this._timeout);\n\t\t\tthis._timeout = 0;\n\t\t}\n\t\tif (this._worker) {\n\t\t\tthis._worker.terminate();\n\t\t\tthis._worker.onmessage = null;\n\t\t}\n\t}\n\n\t/**\n\t * The rate in seconds the ticker will update\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._updateInterval = Math.max(interval, 128 / 44100);\n\t\tif (this._type === \"worker\") {\n\t\t\tthis._worker.postMessage(Math.max(interval * 1000, 1));\n\t\t}\n\t}\n\n\t/**\n\t * The type of the ticker, either a worker or a timeout\n\t */\n\tget type(): TickerClockSource {\n\t\treturn this._type;\n\t}\n\tset type(type: TickerClockSource) {\n\t\tthis._disposeClock();\n\t\tthis._type = type;\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): void {\n\t\tthis._disposeClock();\n\t}\n}\n","import {\n\tisAnyAudioContext, isAnyAudioNode,\n\tisAnyAudioParam, isAnyOfflineAudioContext,\n} from \"standardized-audio-context\";\n\n/**\n * Test if the given value is an instanceof AudioParam\n */\nexport function isAudioParam(arg: any): arg is AudioParam {\n\treturn isAnyAudioParam(arg);\n}\n\n/**\n * Test if the given value is an instanceof AudioNode\n */\nexport function isAudioNode(arg: any): arg is AudioNode {\n\treturn isAnyAudioNode(arg);\n}\n\n/**\n * Test if the arg is instanceof an OfflineAudioContext\n */\nexport function isOfflineAudioContext(arg: any): arg is OfflineAudioContext {\n\treturn isAnyOfflineAudioContext(arg);\n}\n\n/**\n * Test if the arg is an instanceof AudioContext\n */\nexport function isAudioContext(arg: any): arg is AudioContext {\n\treturn isAnyAudioContext(arg);\n}\n\n/**\n * Test if the arg is instanceof an AudioBuffer\n */\nexport function isAudioBuffer(arg: any): arg is AudioBuffer {\n\treturn arg instanceof AudioBuffer;\n}\n","import { isAudioBuffer, isAudioNode, isAudioParam } from \"./AdvancedTypeCheck\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n\ntype BaseToneOptions = import(\"../Tone\").BaseToneOptions;\n\n/**\n * Some objects should not be merged\n */\nfunction noCopy(key: string, arg: any): boolean {\n\treturn key === \"value\" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);\n}\n\n/**\n * Recursively merge an object\n * @param target the object to merge into\n * @param sources the source objects to merge\n */\nexport function deepMerge<T>(target: T): T;\nexport function deepMerge<T, U>(target: T, source1: U): T & U;\nexport function deepMerge<T, U, V>(target: T, source1: U, source2: V): T & U & V;\nexport function deepMerge<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport function deepMerge(target: any, ...sources: any[]): any {\n\tif (!sources.length) {\n\t\treturn target; \n\t}\n\tconst source = sources.shift();\n\n\tif (isObject(target) && isObject(source)) {\n\t\tfor (const key in source) {\n\t\t\tif (noCopy(key, source[key])) {\n\t\t\t\ttarget[key] = source[key];\n\t\t\t} else if (isObject(source[key])) {\n\t\t\t\tif (!target[key]) {\n\t\t\t\t\tObject.assign(target, { [key]: {} }); \n\t\t\t\t}\n\t\t\t\tdeepMerge(target[key], source[key] as any);\n\t\t\t} else {\n\t\t\t\tObject.assign(target, { [key]: source[key] as any });\n\t\t\t}\n\t\t}\n\t}\n\t// @ts-ignore\n\treturn deepMerge(target, ...sources);\n}\n\n/**\n * Returns true if the two arrays have the same value for each of the elements\n */\nexport function deepEquals(arrayA: number[] | string[], arrayB: number[] | string[]): boolean {\n\treturn arrayA.length === arrayB.length && arrayA.every((element, index) => arrayB[index] === element);\n}\n\n/**\n * Convert an args array into an object.\n */\nexport function optionsFromArguments<T extends object>(\n\tdefaults: T,\n\targsArray: IArguments,\n\tkeys: Array<keyof T> = [],\n\tobjKey?: keyof T,\n): T {\n\tconst opts: Partial<T> = {};\n\tconst args = Array.from(argsArray);\n\t// if the first argument is an object and has an object key\n\tif (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n\t\t// if it's not part of the defaults\n\t\tconst partOfDefaults = Object.keys(args[0]).some(key => Reflect.has(defaults, key));\n\t\tif (!partOfDefaults) {\n\t\t\t// merge that key\n\t\t\tdeepMerge(opts, { [objKey]: args[0] });\n\t\t\t// remove the obj key from the keys\n\t\t\tkeys.splice(keys.indexOf(objKey), 1);\n\t\t\t// shift the first argument off\n\t\t\targs.shift();\n\t\t}\n\t}\n\tif (args.length === 1 && isObject(args[0])) {\n\t\tdeepMerge(opts, args[0]);\n\t} else {\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tif (isDefined(args[i])) {\n\t\t\t\topts[keys[i]] = args[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn deepMerge(defaults, opts);\n}\n\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\nexport function getDefaultsFromInstance<T>(instance: T): BaseToneOptions {\n\ttype ToneClass = {\n\t\tconstructor: ToneClass;\n\t\tgetDefaults: () => BaseToneOptions;\n\t} & T;\n\n\treturn (instance as ToneClass).constructor.getDefaults();\n}\n\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\nexport function defaultArg<T>(given: T, fallback: T): T {\n\tif (isUndef(given)) {\n\t\treturn fallback;\n\t} else {\n\t\treturn given;\n\t}\n}\n\n/**\n * Remove all of the properties belonging to omit from obj.\n */\nexport function omitFromObject<T extends object, O extends string[]>(obj: T, omit: O): Omit<T, keyof O> {\n\tomit.forEach(prop => {\n\t\tif (Reflect.has(obj, prop)) {\n\t\t\tdelete obj[prop];\n\t\t}\n\t});\n\treturn obj;\n}\n","/**\n * Tone.js\n * @author Yotam Mann\n * @license http://opensource.org/licenses/MIT MIT License\n * @copyright 2014-2019 Yotam Mann\n */\nimport { version } from \"../version\";\nimport { theWindow } from \"./context/AudioContext\";\nimport { log } from \"./util/Debug\";\n\n//-------------------------------------\n// \tTONE\n//-------------------------------------\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface BaseToneOptions { }\n\n/**\n * @class  Tone is the base class of all other classes.\n * @constructor\n */\nexport abstract class Tone {\n\n\t/**\n\t * The version number semver\n\t */\n\tstatic version: string = version;\n\n\t/**\n\t * The name of the class\n\t */\n\tprotected abstract name: string;\n\n\t/**\n\t * Returns all of the default options belonging to the class.\n\t */\n\tstatic getDefaults(): BaseToneOptions {\n\t\treturn {};\n\t}\n\n\t//-------------------------------------\n\t// \tDEBUGGING\n\t//-------------------------------------\n\n\t/**\n\t * Set this debug flag to log all events that happen in this class.\n\t */\n\tdebug = false;\n\n\t/**\n\t * Prints the outputs to the console log for debugging purposes.\n\t * Prints the contents only if either the object has a property\n\t * called `debug` set to true, or a variable called TONE_DEBUG_CLASS\n\t * is set to the name of the class.\n\t * @example\n\t * const osc = new Tone.Oscillator();\n\t * // prints all logs originating from this oscillator\n\t * osc.debug = true;\n\t * // calls to start/stop will print in the console\n\t * osc.start();\n\t */\n\tprotected log(...args: any[]): void {\n\t\t// if the object is either set to debug = true\n\t\t// or if there is a string on the Tone.global.with the class name\n\t\tif (this.debug || (theWindow && this.toString() === theWindow.TONE_DEBUG_CLASS)) {\n\t\t\tlog(this, ...args);\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// \tDISPOSING\n\t//-------------------------------------\n\n\t/**\n\t * Indicates if the instance was disposed\n\t */\n\tprivate _wasDisposed = false;\n\n\t/**\n\t * disconnect and dispose.\n\t */\n\tdispose(): this {\n\t\tthis._wasDisposed = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Indicates if the instance was disposed. 'Disposing' an\n\t * instance means that all of the Web Audio nodes that were\n\t * created for the instance are disconnected and freed for garbage collection.\n\t */\n\tget disposed(): boolean {\n\t\treturn this._wasDisposed;\n\t}\n\n\t/**\n\t * Convert the class to a string\n\t * @example\n\t * const osc = new Tone.Oscillator();\n\t * console.log(osc.toString());\n\t */\n\ttoString(): string {\n\t\treturn this.name;\n\t}\n}\n","/**\n * The threshold for correctness for operators. Less than one sample even \n * at very high sampling rates (e.g. `1e-6 < 1 / 192000`).\n */\nconst EPSILON = 1e-6;\n\n/**\n * Test if A is greater than B\n */\nexport function GT(a: number, b: number): boolean {\n\treturn a > b + EPSILON;\n}\n\n/**\n * Test if A is greater than or equal to B\n */\nexport function GTE(a: number, b: number): boolean {\n\treturn GT(a, b) || EQ(a, b);\n}\n\n/**\n * Test if A is less than B\n */\nexport function LT(a: number, b: number): boolean {\n\treturn a + EPSILON < b;\n}\n\n/**\n * Test if A is less than B\n */\nexport function EQ(a: number, b: number): boolean {\n\treturn Math.abs(a - b) < EPSILON;\n}\n\n/**\n * Clamp the value within the given range\n */\nexport function clamp(value: number, min: number, max: number): number {\n\treturn Math.max(Math.min(value, max), min);\n}\n","import { Tone } from \"../Tone\";\nimport { Seconds } from \"../type/Units\";\nimport { optionsFromArguments } from \"./Defaults\";\nimport { assert } from \"./Debug\";\nimport { EQ, GT, GTE, LT } from \"./Math\";\n\ntype TimelineSearchParam = \"ticks\" | \"time\";\n\n/**\n * The options object for Timeline\n */\ninterface TimelineOptions {\n\tmemory: number;\n\tincreasing: boolean;\n}\n\n/**\n * An event must have a time number\n */\nexport interface TimelineEvent {\n\ttime: number;\n}\n\n/**\n * A Timeline class for scheduling and maintaining state\n * along a timeline. All events must have a \"time\" property.\n * Internally, events are stored in time order for fast\n * retrieval.\n */\nexport class Timeline<GenericEvent extends TimelineEvent> extends Tone {\n\n\treadonly name: string = \"Timeline\";\n\n\t/**\n\t * The memory of the timeline, i.e.\n\t * how many events in the past it will retain\n\t */\n\tmemory: number;\n\n\t/**\n\t * The array of scheduled timeline events\n\t */\n\tprotected _timeline: GenericEvent[] = [];\n\n\t/**\n\t * If the time value must always be greater than or equal to the last \n\t * element on the list. \n\t */\n\tincreasing: boolean;\n\n\t/**\n\t * @param memory The number of previous events that are retained.\n\t */\n\tconstructor(memory?: number);\n\tconstructor(options?: Partial<TimelineOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n\n\t\tthis.memory = options.memory;\n\t\tthis.increasing = options.increasing;\n\t}\n\n\tstatic getDefaults(): TimelineOptions {\n\t\treturn {\n\t\t\tmemory: Infinity,\n\t\t\tincreasing: false,\n\t\t};\n\t}\n\n\t/**\n\t * The number of items in the timeline.\n\t */\n\tget length(): number {\n\t\treturn this._timeline.length;\n\t}\n\n\t/**\n\t * Insert an event object onto the timeline. Events must have a \"time\" attribute.\n\t * @param event  The event object to insert into the timeline.\n\t */\n\tadd(event: GenericEvent): this {\n\t\t// the event needs to have a time attribute\n\t\tassert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n\t\tevent.time = event.time.valueOf();\n\t\tif (this.increasing && this.length) {\n\t\t\tconst lastValue = this._timeline[this.length - 1] as GenericEvent;\n\t\t\tassert(GTE(event.time, lastValue.time), \"The time must be greater than or equal to the last scheduled time\");\n\t\t\tthis._timeline.push(event);\n\t\t} else {\n\t\t\tconst index = this._search(event.time);\n\t\t\tthis._timeline.splice(index + 1, 0, event);\n\t\t}\n\t\t// if the length is more than the memory, remove the previous ones\n\t\tif (this.length > this.memory) {\n\t\t\tconst diff = this.length - this.memory;\n\t\t\tthis._timeline.splice(0, diff);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove an event from the timeline.\n\t * @param  {Object}  event  The event object to remove from the list.\n\t * @returns {Timeline} this\n\t */\n\tremove(event: GenericEvent): this {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index !== -1) {\n\t\t\tthis._timeline.splice(index, 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the nearest event whose time is less than or equal to the given time.\n\t * @param  time  The time to query.\n\t */\n\tget(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index !== -1) {\n\t\t\treturn this._timeline[index];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Return the first event in the timeline without removing it\n\t * @returns {Object} The first event object\n\t */\n\tpeek(): GenericEvent | undefined {\n\t\treturn this._timeline[0];\n\t}\n\n\t/**\n\t * Return the first event in the timeline and remove it\n\t */\n\tshift(): GenericEvent | undefined {\n\t\treturn this._timeline.shift();\n\t}\n\n\t/**\n\t * Get the event which is scheduled after the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetAfter(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index + 1 < this._timeline.length) {\n\t\t\treturn this._timeline[index + 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get the event before the event at the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetBefore(time: number): GenericEvent | null {\n\t\tconst len = this._timeline.length;\n\t\t// if it's after the last item, return the last item\n\t\tif (len > 0 && this._timeline[len - 1].time < time) {\n\t\t\treturn this._timeline[len - 1];\n\t\t}\n\t\tconst index = this._search(time);\n\t\tif (index - 1 >= 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel events at and after the given time\n\t * @param  after  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tif (this._timeline.length > 1) {\n\t\t\tlet index = this._search(after);\n\t\t\tif (index >= 0) {\n\t\t\t\tif (EQ(this._timeline[index].time, after)) {\n\t\t\t\t\t// get the first item with that time\n\t\t\t\t\tfor (let i = index; i >= 0; i--) {\n\t\t\t\t\t\tif (EQ(this._timeline[i].time, after)) {\n\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index);\n\t\t\t\t} else {\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t} else if (this._timeline.length === 1) {\n\t\t\t// the first item's time\n\t\t\tif (GTE(this._timeline[0].time, after)) {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel events before or equal to the given time.\n\t * @param  time  The time to cancel before.\n\t */\n\tcancelBefore(time: number): this {\n\t\tconst index = this._search(time);\n\t\tif (index >= 0) {\n\t\t\tthis._timeline = this._timeline.slice(index + 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the previous event if there is one. null otherwise\n\t * @param  event The event to find the previous one of\n\t * @return The event right before the given event\n\t */\n\tpreviousEvent(event: GenericEvent): GenericEvent | null {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index > 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Does a binary search on the timeline array and returns the\n\t * nearest event index whose time is after or equal to the given time.\n\t * If a time is searched before the first index in the timeline, -1 is returned.\n\t * If the time is after the end, the index of the last item is returned.\n\t */\n\tprotected _search(time: number, param: TimelineSearchParam = \"time\"): number {\n\t\tif (this._timeline.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet beginning = 0;\n\t\tconst len = this._timeline.length;\n\t\tlet end = len;\n\t\tif (len > 0 && this._timeline[len - 1][param] <= time) {\n\t\t\treturn len - 1;\n\t\t}\n\t\twhile (beginning < end) {\n\t\t\t// calculate the midpoint for roughly equal partition\n\t\t\tlet midPoint = Math.floor(beginning + (end - beginning) / 2);\n\t\t\tconst event = this._timeline[midPoint];\n\t\t\tconst nextEvent = this._timeline[midPoint + 1];\n\t\t\tif (EQ(event[param], time)) {\n\t\t\t\t// choose the last one that has the same time\n\t\t\t\tfor (let i = midPoint; i < this._timeline.length; i++) {\n\t\t\t\t\tconst testEvent = this._timeline[i];\n\t\t\t\t\tif (EQ(testEvent[param], time)) {\n\t\t\t\t\t\tmidPoint = i;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn midPoint;\n\t\t\t} else if (LT(event[param], time) && GT(nextEvent[param], time)) {\n\t\t\t\treturn midPoint;\n\t\t\t} else if (GT(event[param], time)) {\n\t\t\t\t// search lower\n\t\t\t\tend = midPoint;\n\t\t\t} else {\n\t\t\t\t// search upper\n\t\t\t\tbeginning = midPoint + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Internal iterator. Applies extra safety checks for\n\t * removing items from the array.\n\t */\n\tprivate _iterate(\n\t\tcallback: (event: GenericEvent) => void,\n\t\tlowerBound = 0, upperBound = this._timeline.length - 1,\n\t): void {\n\t\tthis._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n\t}\n\n\t/**\n\t * Iterate over everything in the array\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: (event: GenericEvent) => void): this {\n\t\tthis._iterate(callback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at or before the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachBefore(time: Seconds, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array after the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAfter(time: Seconds, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst lowerBound = this._search(time);\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array between the startTime and endTime.\n\t * The timerange is inclusive of the startTime, but exclusive of the endTime.\n\t * range = [startTime, endTime).\n\t * @param  startTime The time to check if items are before\n\t * @param  endTime The end of the test interval.\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachBetween(startTime: number, endTime: number, callback: (event: GenericEvent) => void): this {\n\t\tlet lowerBound = this._search(startTime);\n\t\tlet upperBound = this._search(endTime);\n\t\tif (lowerBound !== -1 && upperBound !== -1) {\n\t\t\tif (this._timeline[lowerBound].time !== startTime) {\n\t\t\t\tlowerBound += 1;\n\t\t\t}\n\t\t\t// exclusive of the end time\n\t\t\tif (this._timeline[upperBound].time === endTime) {\n\t\t\t\tupperBound -= 1;\n\t\t\t}\n\t\t\tthis._iterate(callback, lowerBound, upperBound);\n\t\t} else if (lowerBound === -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at or after the given time. Similar to\n\t * forEachAfter, but includes the item(s) at the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tlet lowerBound = this._search(time);\n\t\t// work backwards until the event time is less than time\n\t\twhile (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n\t\t\tlowerBound--;\n\t\t}\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at the given time\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1 && EQ(this._timeline[upperBound].time, time)) {\n\t\t\tlet lowerBound = upperBound;\n\t\t\tfor (let i = upperBound; i >= 0; i--) {\n\t\t\t\tif (EQ(this._timeline[i].time, time)) {\n\t\t\t\t\tlowerBound = i;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._iterate(event => {\n\t\t\t\tcallback(event);\n\t\t\t}, lowerBound, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._timeline = [];\n\t\treturn this;\n\t}\n}\n","//-------------------------------------\n// INITIALIZING NEW CONTEXT\n//-------------------------------------\n\ntype Context = import(\"./Context\").Context;\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyNewContext: Array<(ctx: Context) => void> = [];\n\n/**\n * Used internally to setup a new Context\n */\nexport function onContextInit(cb: (ctx: Context) => void): void {\n\tnotifyNewContext.push(cb);\n}\n\n/**\n * Invoke any classes which need to also be initialized when a new context is created.\n */\nexport function initializeContext(ctx: Context): void {\n\t// add any additional modules\n\tnotifyNewContext.forEach(cb => cb(ctx));\n}\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyCloseContext: Array<(ctx: Context) => void> = [];\n\n/**\n * Used internally to tear down a Context\n */\nexport function onContextClose(cb: (ctx: Context) => void): void {\n\tnotifyCloseContext.push(cb);\n}\n\nexport function closeContext(ctx: Context): void {\n\t// add any additional modules\n\tnotifyCloseContext.forEach(cb => cb(ctx));\n}\n","import { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n\nexport interface EmitterEventObject {\n\t[event: string]: Array<(...args: any[]) => void>;\n}\n\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n */\nexport class Emitter<EventType extends string = string> extends Tone {\n\n\treadonly name: string = \"Emitter\";\n\n\t/**\n\t * Private container for the events\n\t */\n\tprivate _events?: EmitterEventObject;\n\n\t/**\n\t * Bind a callback to a specific event.\n\t * @param  event     The name of the event to listen for.\n\t * @param  callback  The callback to invoke when the event is emitted\n\t */\n\ton(event: EventType, callback: (...args: any[]) => void): this {\n\t\t// split the event\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (!this._events.hasOwnProperty(eventName)) {\n\t\t\t\tthis._events[eventName] = [];\n\t\t\t}\n\t\t\tthis._events[eventName].push(callback);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Bind a callback which is only invoked once\n\t * @param  event     The name of the event to listen for.\n\t * @param  callback  The callback to invoke when the event is emitted\n\t */\n\tonce(event: EventType, callback: (...args: any[]) => void): this {\n\t\tconst boundCallback = (...args: any[]) => {\n\t\t\t// invoke the callback\n\t\t\tcallback(...args);\n\t\t\t// remove the event\n\t\t\tthis.off(event, boundCallback);\n\t\t};\n\t\tthis.on(event, boundCallback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove the event listener.\n\t * @param  event     The event to stop listening to.\n\t * @param  callback  The callback which was bound to the event with Emitter.on.\n\t *                   If no callback is given, all callbacks events are removed.\n\t */\n\toff(event: EventType, callback?: (...args: any[]) => void): this {\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tif (isUndef(callback)) {\n\t\t\t\t\tthis._events[event] = [];\n\t\t\t\t} else {\n\t\t\t\t\tconst eventList = this._events[event];\n\t\t\t\t\tfor (let i = 0; i < eventList.length; i++) {\n\t\t\t\t\t\tif (eventList[i] === callback) {\n\t\t\t\t\t\t\teventList.splice(i, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke all of the callbacks bound to the event\n\t * with any arguments passed in.\n\t * @param  event  The name of the event.\n\t * @param args The arguments to pass to the functions listening.\n\t */\n\temit(event, ...args: any[]): this {\n\t\tif (this._events) {\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tconst eventList = this._events[event].slice(0);\n\t\t\t\tfor (let i = 0, len = eventList.length; i < len; i++) {\n\t\t\t\t\teventList[i].apply(this, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add Emitter functions (on/off/emit) to the object\n\t */\n\tstatic mixin(constr: any): void {\n\t\t// instance._events = {};\n\t\t[\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n\t\t\tconst property = Object.getOwnPropertyDescriptor(Emitter.prototype, name) as PropertyDescriptor;\n\t\t\tObject.defineProperty(constr.prototype, name, property);\n\t\t});\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events = undefined;\n\t\treturn this;\n\t}\n}\n","import { Seconds } from \"../type/Units\";\nimport { Emitter } from \"../util/Emitter\";\nimport { AnyAudioContext } from \"./AudioContext\";\n\ntype Draw = import(\"../util/Draw\").Draw;\ntype Destination = import(\"./Destination\").Destination;\ntype Transport = import(\"../clock/Transport\").Transport;\ntype Listener = import(\"./Listener\").Listener;\ntype BaseAudioContextSubset = import(\"./Context\").BaseAudioContextSubset;\n\nexport type ContextLatencyHint = AudioContextLatencyCategory;\n\nexport abstract class BaseContext extends Emitter<\"statechange\" | \"tick\"> implements BaseAudioContextSubset {\n\n\t//---------------------------\n\t// BASE AUDIO CONTEXT METHODS\n\t//---------------------------\n\tabstract createAnalyser(): AnalyserNode\n\n\tabstract createOscillator(): OscillatorNode\n\n\tabstract createBufferSource(): AudioBufferSourceNode\n\n\tabstract createBiquadFilter(): BiquadFilterNode\n\n\tabstract createBuffer(_numberOfChannels: number, _length: number, _sampleRate: number): AudioBuffer\n\n\tabstract createChannelMerger(_numberOfInputs?: number | undefined): ChannelMergerNode\n\n\tabstract createChannelSplitter(_numberOfOutputs?: number | undefined): ChannelSplitterNode\n\n\tabstract createConstantSource(): ConstantSourceNode\n\n\tabstract createConvolver(): ConvolverNode\n\n\tabstract createDelay(_maxDelayTime?: number | undefined): DelayNode\n\n\tabstract createDynamicsCompressor(): DynamicsCompressorNode\n\n\tabstract createGain(): GainNode\n\n\tabstract createIIRFilter(_feedForward: number[] | Float32Array, _feedback: number[] | Float32Array): IIRFilterNode\n\n\tabstract createPanner(): PannerNode\n\n\tabstract createPeriodicWave(\n\t\t_real: number[] | Float32Array,\n\t\t_imag: number[] | Float32Array,\n\t\t_constraints?: PeriodicWaveConstraints | undefined,\n\t): PeriodicWave\n\n\tabstract createStereoPanner(): StereoPannerNode\n\n\tabstract createWaveShaper(): WaveShaperNode\n\n\tabstract createMediaStreamSource(_stream: MediaStream): MediaStreamAudioSourceNode\n\n\tabstract createMediaStreamDestination(): MediaStreamAudioDestinationNode\n\n\tabstract decodeAudioData(_audioData: ArrayBuffer): Promise<AudioBuffer>\n\n\t//---------------------------\n\t// TONE AUDIO CONTEXT METHODS\n\t//---------------------------\n\n\tabstract createAudioWorkletNode(\n\t\t_name: string,\n\t\t_options?: Partial<AudioWorkletNodeOptions>\n\t): AudioWorkletNode\n\n\tabstract get rawContext(): AnyAudioContext\n\n\tabstract async addAudioWorkletModule(_url: string, _name: string): Promise<void>\n\n\tabstract lookAhead: number;\n\n\tabstract latencyHint: ContextLatencyHint | Seconds;\n\n\tabstract resume(): Promise<void>\n\n\tabstract setTimeout(_fn: (...args: any[]) => void, _timeout: Seconds): number\n\n\tabstract clearTimeout(_id: number): this\n\n\tabstract setInterval(_fn: (...args: any[]) => void, _interval: Seconds): number\n\n\tabstract clearInterval(_id: number): this\n\n\tabstract getConstant(_val: number): AudioBufferSourceNode\n\n\tabstract get currentTime(): Seconds\n\n\tabstract get state(): AudioContextState\n\n\tabstract get sampleRate(): number\n\n\tabstract get listener(): Listener\n\n\tabstract get transport(): Transport\n\n\tabstract get draw(): Draw\n\n\tabstract get destination(): Destination\n\n\tabstract now(): Seconds\n\n\tabstract immediate(): Seconds\n\n\treadonly isOffline: boolean = false;\n}\n","import { Ticker, TickerClockSource } from \"../clock/Ticker\";\nimport { Seconds } from \"../type/Units\";\nimport { isAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Omit } from \"../util/Interface\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined, isString } from \"../util/TypeCheck\";\nimport { AnyAudioContext, createAudioContext, createAudioWorkletNode } from \"./AudioContext\";\nimport { closeContext, initializeContext } from \"./ContextInitialization\";\nimport { BaseContext, ContextLatencyHint } from \"./BaseContext\";\nimport { assert } from \"../util/Debug\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\ntype Destination = import(\"./Destination\").Destination;\ntype Listener = import(\"./Listener\").Listener;\ntype Draw = import(\"../util/Draw\").Draw;\n\n// these are either not used in Tone.js or deprecated and not implemented.\nexport type ExcludedFromBaseAudioContext = \"onstatechange\" | \"addEventListener\" | \"removeEventListener\" | \"listener\" | \"dispatchEvent\" | \"audioWorklet\" | \"destination\" | \"createScriptProcessor\";\n// \"createMediaStreamSource\" | \"createMediaElementSource\" | \"createMediaStreamTrackSource\" |\n// \"baseLatency\" | \"suspend\" |\n\n// the subset of the BaseAudioContext which Tone.Context implements.\nexport type BaseAudioContextSubset = Omit<BaseAudioContext, ExcludedFromBaseAudioContext>;\n\nexport interface ContextOptions {\n\tclockSource: TickerClockSource;\n\tlatencyHint: ContextLatencyHint;\n\tlookAhead: Seconds;\n\tupdateInterval: Seconds;\n\tcontext: AnyAudioContext;\n}\n\nexport interface ContextTimeoutEvent {\n\tcallback: (...args: any[]) => void;\n\tid: number;\n\ttime: Seconds;\n}\n\n/**\n * Wrapper around the native AudioContext.\n * @category Core\n */\nexport class Context extends BaseContext {\n\n\treadonly name: string = \"Context\";\n\n\t/**\n\t * The amount of time into the future events are scheduled. Giving Web Audio\n\t * a short amount of time into the future to schedule events can reduce clicks and\n\t * improve performance. This value can be set to 0 to get the lowest latency.\n\t */\n\tlookAhead: Seconds;\n\n\t/**\n\t * private reference to the BaseAudioContext\n\t */\n\tprotected readonly _context: AnyAudioContext;\n\n\t/**\n\t * A reliable callback method\n\t */\n\tprivate readonly _ticker: Ticker;\n\n\t/**\n\t * The default latency hint\n\t */\n\tprivate _latencyHint!: ContextLatencyHint | Seconds;\n\n\t/**\n\t * An object containing all of the constants AudioBufferSourceNodes\n\t */\n\tprivate _constants = new Map<number, AudioBufferSourceNode>();\n\n\t/**\n\t * All of the setTimeout events.\n\t */\n\tprivate _timeouts: Timeline<ContextTimeoutEvent> = new Timeline();\n\n\t/**\n\t * The timeout id counter\n\t */\n\tprivate _timeoutIds = 0;\n\n\t/**\n\t * A reference the Transport singleton belonging to this context\n\t */\n\tprivate _transport!: Transport;\n\n\t/**\n\t * A reference the Listener singleton belonging to this context\n\t */\n\tprivate _listener!: Listener;\n\n\t/**\n\t * A reference the Destination singleton belonging to this context\n\t */\n\tprivate _destination!: Destination;\n\n\t/**\n\t * A reference the Transport singleton belonging to this context\n\t */\n\tprivate _draw!: Draw;\n\n\t/**\n\t * Private indicator if the context has been initialized\n\t */\n\tprivate _initialized = false;\n\n\t/**\n\t * Indicates if the context is an OfflineAudioContext or an AudioContext\n\t */\n\treadonly isOffline: boolean = false;\n\n\tconstructor(context?: AnyAudioContext);\n\tconstructor(options?: Partial<ContextOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n\n\t\tif (options.context) {\n\t\t\tthis._context = options.context;\n\t\t} else {\n\t\t\tthis._context = createAudioContext({\n\t\t\t\tlatencyHint: options.latencyHint,\n\t\t\t});\n\t\t}\n\n\t\tthis._ticker = new Ticker(this.emit.bind(this, \"tick\"), options.clockSource, options.updateInterval);\n\t\tthis.on(\"tick\", this._timeoutLoop.bind(this));\n\n\t\t// fwd events from the context\n\t\tthis._context.onstatechange = () => {\n\t\t\tthis.emit(\"statechange\", this.state);\n\t\t};\n\n\t\tthis._setLatencyHint(options.latencyHint);\n\t\tthis.lookAhead = options.lookAhead;\n\t}\n\n\tstatic getDefaults(): ContextOptions {\n\t\treturn {\n\t\t\tclockSource: \"worker\",\n\t\t\tlatencyHint: \"interactive\",\n\t\t\tlookAhead: 0.1,\n\t\t\tupdateInterval: 0.05,\n\t\t} as ContextOptions;\n\t}\n\n\t/**\n\t * Finish setting up the context. **You usually do not need to do this manually.**\n\t */\n\tprivate initialize(): this {\n\t\tif (!this._initialized) {\n\t\t\t// add any additional modules\n\t\t\tinitializeContext(this);\n\t\t\tthis._initialized = true;\n\t\t}\n\t\treturn this;\n\t}\n\n\t//---------------------------\n\t// BASE AUDIO CONTEXT METHODS\n\t//---------------------------\n\n\tcreateAnalyser(): AnalyserNode {\n\t\treturn this._context.createAnalyser();\n\t}\n\tcreateOscillator(): OscillatorNode {\n\t\treturn this._context.createOscillator();\n\t}\n\tcreateBufferSource(): AudioBufferSourceNode {\n\t\treturn this._context.createBufferSource();\n\t}\n\tcreateBiquadFilter(): BiquadFilterNode {\n\t\treturn this._context.createBiquadFilter();\n\t}\n\tcreateBuffer(numberOfChannels: number, length: number, sampleRate: number): AudioBuffer {\n\t\treturn this._context.createBuffer(numberOfChannels, length, sampleRate);\n\t}\n\tcreateChannelMerger(numberOfInputs?: number | undefined): ChannelMergerNode {\n\t\treturn this._context.createChannelMerger(numberOfInputs);\n\t}\n\tcreateChannelSplitter(numberOfOutputs?: number | undefined): ChannelSplitterNode {\n\t\treturn this._context.createChannelSplitter(numberOfOutputs);\n\t}\n\tcreateConstantSource(): ConstantSourceNode {\n\t\treturn this._context.createConstantSource();\n\t}\n\tcreateConvolver(): ConvolverNode {\n\t\treturn this._context.createConvolver();\n\t}\n\tcreateDelay(maxDelayTime?: number | undefined): DelayNode {\n\t\treturn this._context.createDelay(maxDelayTime);\n\t}\n\tcreateDynamicsCompressor(): DynamicsCompressorNode {\n\t\treturn this._context.createDynamicsCompressor();\n\t}\n\tcreateGain(): GainNode {\n\t\treturn this._context.createGain();\n\t}\n\tcreateIIRFilter(feedForward: number[] | Float32Array, feedback: number[] | Float32Array): IIRFilterNode {\n\t\t// @ts-ignore\n\t\treturn this._context.createIIRFilter(feedForward, feedback);\n\t}\n\tcreatePanner(): PannerNode {\n\t\treturn this._context.createPanner();\n\t}\n\tcreatePeriodicWave(\n\t\treal: number[] | Float32Array,\n\t\timag: number[] | Float32Array,\n\t\tconstraints?: PeriodicWaveConstraints | undefined,\n\t): PeriodicWave {\n\t\treturn this._context.createPeriodicWave(real, imag, constraints);\n\t}\n\tcreateStereoPanner(): StereoPannerNode {\n\t\treturn this._context.createStereoPanner();\n\t}\n\tcreateWaveShaper(): WaveShaperNode {\n\t\treturn this._context.createWaveShaper();\n\t}\n\tcreateMediaStreamSource(stream: MediaStream): MediaStreamAudioSourceNode {\n\t\tassert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n\t\tconst context = this._context as AudioContext;\n\t\treturn context.createMediaStreamSource(stream);\n\t}\n\tcreateMediaStreamDestination(): MediaStreamAudioDestinationNode {\n\t\tassert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n\t\tconst context = this._context as AudioContext;\n\t\treturn context.createMediaStreamDestination();\n\t}\n\tdecodeAudioData(audioData: ArrayBuffer): Promise<AudioBuffer> {\n\t\treturn this._context.decodeAudioData(audioData);\n\t}\n\n\t/**\n\t * The current time in seconds of the AudioContext.\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._context.currentTime;\n\t}\n\t/**\n\t * The current time in seconds of the AudioContext.\n\t */\n\tget state(): AudioContextState {\n\t\treturn this._context.state;\n\t}\n\t/**\n\t * The current time in seconds of the AudioContext.\n\t */\n\tget sampleRate(): number {\n\t\treturn this._context.sampleRate;\n\t}\n\n\t/**\n\t * The listener\n\t */\n\tget listener(): Listener {\n\t\tthis.initialize();\n\t\treturn this._listener;\n\t}\n\tset listener(l) {\n\t\tassert(!this._initialized, \"The listener cannot be set after initialization.\");\n\t\tthis._listener = l;\n\t}\n\n\t/**\n\t * There is only one Transport per Context. It is created on initialization.\n\t */\n\tget transport(): Transport {\n\t\tthis.initialize();\n\t\treturn this._transport;\n\t}\n\tset transport(t: Transport) {\n\t\tassert(!this._initialized, \"The transport cannot be set after initialization.\");\n\t\tthis._transport = t;\n\t}\n\n\t/**\n\t * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.\n\t */\n\tget draw(): Draw {\n\t\tthis.initialize();\n\t\treturn this._draw;\n\t}\n\tset draw(d) {\n\t\tassert(!this._initialized, \"Draw cannot be set after initialization.\");\n\t\tthis._draw = d;\n\t}\n\n\t/**\n\t * A reference to the Context's destination node.\n\t */\n\tget destination(): Destination {\n\t\tthis.initialize();\n\t\treturn this._destination;\n\t}\n\tset destination(d: Destination) {\n\t\tassert(!this._initialized, \"The destination cannot be set after initialization.\");\n\t\tthis._destination = d;\n\t}\n\n\t//--------------------------------------------\n\t// AUDIO WORKLET\n\t//--------------------------------------------\n\n\t/**\n\t * Maps a module name to promise of the addModule method\n\t */\n\tprivate _workletModules: Map<string, Promise<void>> = new Map()\n\n\t/**\n\t * Create an audio worklet node from a name and options. The module\n\t * must first be loaded using [[addAudioWorkletModule]]. \n\t */\n\tcreateAudioWorkletNode(\n\t\tname: string,\n\t\toptions?: Partial<AudioWorkletNodeOptions>\n\t): AudioWorkletNode {\n\t\treturn createAudioWorkletNode(this.rawContext, name, options);\n\t}\n\n\t/**\n\t * Add an AudioWorkletProcessor module\n\t * @param url The url of the module\n\t * @param name The name of the module\n\t */\n\tasync addAudioWorkletModule(url: string, name: string): Promise<void> {\n\t\tassert(isDefined(this.rawContext.audioWorklet), \"AudioWorkletNode is only available in a secure context (https or localhost)\");\n\t\tif (!this._workletModules.has(name)) {\n\t\t\tthis._workletModules.set(name, this.rawContext.audioWorklet.addModule(url));\n\t\t}\n\t\tawait this._workletModules.get(name);\n\t}\n\n\t/**\n\t * Returns a promise which resolves when all of the worklets have been loaded on this context\n\t */\n\tprotected async workletsAreReady(): Promise<void> {\n\t\tconst promises: Promise<void>[] = [];\n\t\tthis._workletModules.forEach(promise => promises.push(promise));\n\t\tawait Promise.all(promises);\n\t}\n\n\t//---------------------------\n\t// TICKER\n\t//---------------------------\n\n\t/**\n\t * How often the interval callback is invoked.\n\t * This number corresponds to how responsive the scheduling\n\t * can be. context.updateInterval + context.lookAhead gives you the\n\t * total latency between scheduling an event and hearing it.\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._ticker.updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._ticker.updateInterval = interval;\n\t}\n\n\t/**\n\t * What the source of the clock is, either \"worker\" (default),\n\t * \"timeout\", or \"offline\" (none).\n\t */\n\tget clockSource(): TickerClockSource {\n\t\treturn this._ticker.type;\n\t}\n\tset clockSource(type: TickerClockSource) {\n\t\tthis._ticker.type = type;\n\t}\n\n\t/**\n\t * The type of playback, which affects tradeoffs between audio\n\t * output latency and responsiveness.\n\t * In addition to setting the value in seconds, the latencyHint also\n\t * accepts the strings \"interactive\" (prioritizes low latency),\n\t * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n\t * latency and performance).\n\t * @example\n\t * // prioritize sustained playback\n\t * const context = new Tone.Context({ latencyHint: \"playback\" });\n\t * // set this context as the global Context\n\t * Tone.setContext(context);\n\t */\n\tget latencyHint(): ContextLatencyHint | Seconds {\n\t\treturn this._latencyHint;\n\t}\n\n\t/**\n\t * Update the lookAhead and updateInterval based on the latencyHint\n\t */\n\tprivate _setLatencyHint(hint: ContextLatencyHint | Seconds): void {\n\t\tlet lookAheadValue = 0;\n\t\tthis._latencyHint = hint;\n\t\tif (isString(hint)) {\n\t\t\tswitch (hint) {\n\t\t\t\tcase \"interactive\":\n\t\t\t\t\tlookAheadValue = 0.1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"playback\":\n\t\t\t\t\tlookAheadValue = 0.5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"balanced\":\n\t\t\t\t\tlookAheadValue = 0.25;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.lookAhead = lookAheadValue;\n\t\tthis.updateInterval = lookAheadValue / 2;\n\t}\n\n\t/**\n\t * The unwrapped AudioContext or OfflineAudioContext\n\t */\n\tget rawContext(): AnyAudioContext {\n\t\treturn this._context;\n\t}\n\n\t/**\n\t * The current audio context time plus a short [[lookAhead]].\n\t */\n\tnow(): Seconds {\n\t\treturn this._context.currentTime + this.lookAhead;\n\t}\n\n\t/**\n\t * The current audio context time without the [[lookAhead]]. \n\t * In most cases it is better to use [[now]] instead of [[immediate]] since\n\t * with [[now]] the [[lookAhead]] is applied equally to _all_ components including internal components,\n\t * to making sure that everything is scheduled in sync. Mixing [[now]] and [[immediate]]\n\t * can cause some timing issues. If no lookAhead is desired, you can set the [[lookAhead]] to `0`.\n\t */\n\timmediate(): Seconds {\n\t\treturn this._context.currentTime;\n\t}\n\n\t/**\n\t * Starts the audio context from a suspended state. This is required\n\t * to initially start the AudioContext. See [[Tone.start]]\n\t */\n\tresume(): Promise<void> {\n\t\tif (this._context.state === \"suspended\" && isAudioContext(this._context)) {\n\t\t\treturn this._context.resume();\n\t\t} else {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\t/**\n\t * Close the context. Once closed, the context can no longer be used and\n\t * any AudioNodes created from the context will be silent. \n\t */\n\tasync close(): Promise<void> {\n\t\tif (isAudioContext(this._context)) {\n\t\t\tawait this._context.close();\n\t\t}\n\t\tif (this._initialized) {\n\t\t\tcloseContext(this);\n\t\t}\n\t}\n\n\t/**\n\t * **Internal** Generate a looped buffer at some constant value. \n\t */\n\tgetConstant(val: number): AudioBufferSourceNode {\n\t\tif (this._constants.has(val)) {\n\t\t\treturn this._constants.get(val) as AudioBufferSourceNode;\n\t\t} else {\n\t\t\tconst buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n\t\t\tconst arr = buffer.getChannelData(0);\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = val;\n\t\t\t}\n\t\t\tconst constant = this._context.createBufferSource();\n\t\t\tconstant.channelCount = 1;\n\t\t\tconstant.channelCountMode = \"explicit\";\n\t\t\tconstant.buffer = buffer;\n\t\t\tconstant.loop = true;\n\t\t\tconstant.start(0);\n\t\t\tthis._constants.set(val, constant);\n\t\t\treturn constant;\n\t\t}\n\t}\n\n\t/**\n\t * Clean up. Also closes the audio context.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._ticker.dispose();\n\t\tthis._timeouts.dispose();\n\t\tObject.keys(this._constants).map(val => this._constants[val].disconnect());\n\t\treturn this;\n\t}\n\n\t//---------------------------\n\t// TIMEOUTS\n\t//---------------------------\n\n\t/**\n\t * The private loop which keeps track of the context scheduled timeouts\n\t * Is invoked from the clock source\n\t */\n\tprivate _timeoutLoop(): void {\n\t\tconst now = this.now();\n\t\tlet firstEvent = this._timeouts.peek();\n\t\twhile (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n\t\t\t// invoke the callback\n\t\t\tfirstEvent.callback();\n\t\t\t// shift the first event off\n\t\t\tthis._timeouts.shift();\n\t\t\t// get the next one\n\t\t\tfirstEvent = this._timeouts.peek();\n\t\t}\n\t}\n\n\t/**\n\t * A setTimeout which is guaranteed by the clock source.\n\t * Also runs in the offline context.\n\t * @param  fn       The callback to invoke\n\t * @param  timeout  The timeout in seconds\n\t * @returns ID to use when invoking Context.clearTimeout\n\t */\n\tsetTimeout(fn: (...args: any[]) => void, timeout: Seconds): number {\n\t\tthis._timeoutIds++;\n\t\tconst now = this.now();\n\t\tthis._timeouts.add({\n\t\t\tcallback: fn,\n\t\t\tid: this._timeoutIds,\n\t\t\ttime: now + timeout,\n\t\t});\n\t\treturn this._timeoutIds;\n\t}\n\n\t/**\n\t * Clears a previously scheduled timeout with Tone.context.setTimeout\n\t * @param  id  The ID returned from setTimeout\n\t */\n\tclearTimeout(id: number): this {\n\t\tthis._timeouts.forEach(event => {\n\t\t\tif (event.id === id) {\n\t\t\t\tthis._timeouts.remove(event);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clear the function scheduled by [[setInterval]]\n\t */\n\tclearInterval(id: number): this {\n\t\treturn this.clearTimeout(id);\n\t}\n\n\t/**\n\t * Adds a repeating event to the context's callback clock\n\t */\n\tsetInterval(fn: (...args: any[]) => void, interval: Seconds): number {\n\t\tconst id = ++this._timeoutIds;\n\t\tconst intervalFn = () => {\n\t\t\tconst now = this.now();\n\t\t\tthis._timeouts.add({\n\t\t\t\tcallback: () => {\n\t\t\t\t\t// invoke the callback\n\t\t\t\t\tfn();\n\t\t\t\t\t// invoke the event to repeat it\n\t\t\t\t\tintervalFn();\n\t\t\t\t},\n\t\t\t\tid,\n\t\t\t\ttime: now + interval,\n\t\t\t});\n\t\t};\n\t\t// kick it off\n\t\tintervalFn();\n\t\treturn id;\n\t}\n}\n","import { isArray } from \"./TypeCheck\";\n\n// return an interface which excludes certain keys\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n/**\n * Make the property not writable using `defineProperty`. Internal use only.\n */\nexport function readOnly(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => readOnly(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\tenumerable: true,\n\t\t\twritable: false,\n\t\t});\n\t}\n}\n\n/**\n * Make an attribute writeable. Internal use only.\n */\nexport function writable(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => writable(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\twritable: true,\n\t\t});\n\t}\n}\n\nexport const noOp: (...args: any[]) => any = () => {\n\t// no operation here!\n};\n\n/**\n * Recursive Partial taken from here: https://stackoverflow.com/a/51365037\n */\nexport type RecursivePartial<T> = {\n\t[P in keyof T]?:\n\tT[P] extends Array<infer U> ? Array<RecursivePartial<U>> :\n\t\tT[P] extends object ? RecursivePartial<T[P]> :\n\t\t\tT[P];\n};\n","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { Samples, Seconds } from \"../type/Units\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\nimport { assert } from \"../util/Debug\";\n\ninterface ToneAudioBufferOptions {\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n\treverse: boolean;\n\tonload: (buffer?: ToneAudioBuffer) => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * Aside from load callbacks from individual buffers, ToneAudioBuffer\n * provides events which keep track of the loading progress\n * of _all_ of the buffers. These are ToneAudioBuffer.on(\"load\" / \"progress\" / \"error\")\n * @example\n * const buffer = new Tone.ToneAudioBuffer(\"https://tonejs.github.io/audio/casio/A1.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\nexport class ToneAudioBuffer extends Tone {\n\n\treadonly name: string = \"ToneAudioBuffer\";\n\n\t/**\n\t * stores the loaded AudioBuffer\n\t */\n\tprivate _buffer?: AudioBuffer;\n\n\t/**\n\t * indicates if the buffer should be reversed or not\n\t */\n\tprivate _reversed!: boolean;\n\n\t/**\n\t * Callback when the buffer is loaded.\n\t */\n\tonload: (buffer: ToneAudioBuffer) => void = noOp;\n\n\t/**\n\t *\n\t * @param url The url to load, or the audio buffer to set.\n\t * @param onload A callback which is invoked after the buffer is loaded.\n\t *                           It's recommended to use `ToneAudioBuffer.on('load', callback)` instead\n\t *                           since it will give you a callback when _all_ buffers are loaded.\n\t * @param onerror The callback to invoke if there is an error\n\t */\n\tconstructor(\n\t\turl?: string | ToneAudioBuffer | AudioBuffer,\n\t\tonload?: (buffer: ToneAudioBuffer) => void,\n\t\tonerror?: (error: Error) => void,\n\t);\n\tconstructor(options?: Partial<ToneAudioBufferOptions>);\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tconst options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n\n\t\tthis.reverse = options.reverse;\n\t\tthis.onload = options.onload;\n\n\t\tif (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n\t\t\tthis.set(options.url);\n\t\t} else if (isString(options.url)) {\n\t\t\t// initiate the download\n\t\t\tthis.load(options.url).catch(options.onerror);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneAudioBufferOptions {\n\t\treturn {\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\treverse: false,\n\t\t};\n\t}\n\n\t/**\n\t * The sample rate of the AudioBuffer\n\t */\n\tget sampleRate(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.sampleRate;\n\t\t} else {\n\t\t\treturn getContext().sampleRate;\n\t\t}\n\t}\n\n\t/**\n\t * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n\t */\n\tset(buffer: AudioBuffer | ToneAudioBuffer): this {\n\t\tif (buffer instanceof ToneAudioBuffer) {\n\t\t\t// if it's loaded, set it\n\t\t\tif (buffer.loaded) {\n\t\t\t\tthis._buffer = buffer.get();\n\t\t\t} else {\n\t\t\t\t// otherwise when it's loaded, invoke it's callback\n\t\t\t\tbuffer.onload = () => {\n\t\t\t\t\tthis.set(buffer);\n\t\t\t\t\tthis.onload(this);\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\tthis._buffer = buffer;\n\t\t}\n\t\t// reverse it initially\n\t\tif (this._reversed) {\n\t\t\tthis._reverse();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The audio buffer stored in the object.\n\t */\n\tget(): AudioBuffer | undefined {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n\t * Invokes the callback once the audio buffer loads.\n\t * @param url The url of the buffer to load. filetype support depends on the browser.\n\t * @returns A Promise which resolves with this ToneAudioBuffer\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tconst doneLoading: Promise<void> = ToneAudioBuffer.load(url).then(audioBuffer => {\n\t\t\tthis.set(audioBuffer);\n\t\t\t// invoke the onload method\n\t\t\tthis.onload(this);\n\t\t});\n\t\tToneAudioBuffer.downloads.push(doneLoading);\n\t\ttry {\n\t\t\tawait doneLoading;\n\t\t} finally {\n\t\t\t// remove the downloaded file\n\t\t\tconst index = ToneAudioBuffer.downloads.indexOf(doneLoading);\n\t\t\tToneAudioBuffer.downloads.splice(index, 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffer = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the audio buffer from the array.\n\t * To create a multichannel AudioBuffer, pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t */\n\tfromArray(array: Float32Array | Float32Array[]): this {\n\t\tconst isMultidimensional = isArray(array) && array[0].length > 0;\n\t\tconst channels = isMultidimensional ? array.length : 1;\n\t\tconst len = isMultidimensional ? (array[0] as Float32Array).length : array.length;\n\t\tconst context = getContext();\n\t\tconst buffer = context.createBuffer(channels, len, context.sampleRate);\n\t\tconst multiChannelArray: Float32Array[] = !isMultidimensional && channels === 1 ?\n\t\t\t[array as Float32Array] : array as Float32Array[];\n\n\t\tfor (let c = 0; c < channels; c++) {\n\t\t\tbuffer.copyToChannel(multiChannelArray[c], c);\n\t\t}\n\t\tthis._buffer = buffer;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sums multiple channels into 1 channel\n\t * @param chanNum Optionally only copy a single channel from the array.\n\t */\n\ttoMono(chanNum?: number): this {\n\t\tif (isNumber(chanNum)) {\n\t\t\tthis.fromArray(this.toArray(chanNum));\n\t\t} else {\n\t\t\tlet outputArray = new Float32Array(this.length as number);\n\t\t\tconst numChannels = this.numberOfChannels;\n\t\t\tfor (let channel = 0; channel < numChannels; channel++) {\n\t\t\t\tconst channelArray = this.toArray(channel) as Float32Array;\n\t\t\t\tfor (let i = 0; i < channelArray.length; i++) {\n\t\t\t\t\toutputArray[i] += channelArray[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// divide by the number of channels\n\t\t\toutputArray = outputArray.map(sample => sample / numChannels);\n\t\t\tthis.fromArray(outputArray);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n\t * Float32Array, and multichannel buffers will return multidimensional arrays.\n\t * @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoArray(channel?: number): Float32Array | Float32Array[] {\n\t\tif (isNumber(channel)) {\n\t\t\treturn this.getChannelData(channel);\n\t\t} else if (this.numberOfChannels === 1) {\n\t\t\treturn this.toArray(0);\n\t\t} else {\n\t\t\tconst ret: Float32Array[] = [];\n\t\t\tfor (let c = 0; c < this.numberOfChannels; c++) {\n\t\t\t\tret[c] = this.getChannelData(c);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the Float32Array representing the PCM audio data for the specific channel.\n\t * @param  channel  The channel number to return\n\t * @return The audio as a TypedArray\n\t */\n\tgetChannelData(channel: number): Float32Array {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.getChannelData(channel);\n\t\t} else {\n\t\t\treturn new Float32Array(0);\n\t\t}\n\t}\n\n\t/**\n\t * Cut a subsection of the array and return a buffer of the\n\t * subsection. Does not modify the original buffer\n\t * @param start The time to start the slice\n\t * @param end The end time to slice. If none is given will default to the end of the buffer\n\t */\n\tslice(start: Seconds, end: Seconds = this.duration): ToneAudioBuffer {\n\t\tconst startSamples = Math.floor(start * this.sampleRate);\n\t\tconst endSamples = Math.floor(end * this.sampleRate);\n\t\tassert(startSamples < endSamples, \"The start time must be less than the end time\");\n\t\tconst length = endSamples - startSamples;\n\t\tconst retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n\t\tfor (let channel = 0; channel < this.numberOfChannels; channel++) {\n\t\t\tretBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n\t\t}\n\t\treturn new ToneAudioBuffer(retBuffer);\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tprivate _reverse(): this {\n\t\tif (this.loaded) {\n\t\t\tfor (let i = 0; i < this.numberOfChannels; i++) {\n\t\t\t\tthis.getChannelData(i).reverse();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffer is loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this.length > 0;\n\t}\n\n\t/**\n\t * The duration of the buffer in seconds.\n\t */\n\tget duration(): Seconds {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.duration;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The length of the buffer in samples\n\t */\n\tget length(): Samples {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.length;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n\t */\n\tget numberOfChannels(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.numberOfChannels;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tget reverse(): boolean {\n\t\treturn this._reversed;\n\t}\n\tset reverse(rev: boolean) {\n\t\tif (this._reversed !== rev) {\n\t\t\tthis._reversed = rev;\n\t\t\tthis._reverse();\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// STATIC METHODS\n\t//-------------------------------------\n\n\t/**\n\t * A path which is prefixed before every url.\n\t */\n\tstatic baseUrl = \"\";\n\n\t/**\n\t * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n\t * pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t * @return A ToneAudioBuffer created from the array\n\t */\n\tstatic fromArray(array: Float32Array | Float32Array[]): ToneAudioBuffer {\n\t\treturn (new ToneAudioBuffer()).fromArray(array);\n\t}\n\n\t/**\n\t * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n\t * @param  url The url to load.\n\t * @return A promise which resolves to a ToneAudioBuffer\n\t */\n\tstatic async fromUrl(url: string): Promise<ToneAudioBuffer> {\n\t\tconst buffer = new ToneAudioBuffer();\n\t\treturn await buffer.load(url);\n\t}\n\n\t/**\n\t * All of the downloads\n\t */\n\tstatic downloads: Array<Promise<void>> = [];\n\n\t/**\n\t * Loads a url using fetch and returns the AudioBuffer.\n\t */\n\tstatic async load(url: string): Promise<AudioBuffer> {\n\n\t\t// test if the url contains multiple extensions\n\t\tconst matches = url.match(/\\[(.+\\|?)+\\]$/);\n\t\tif (matches) {\n\t\t\tconst extensions = matches[1].split(\"|\");\n\t\t\tlet extension = extensions[0];\n\t\t\tfor (const ext of extensions) {\n\t\t\t\tif (ToneAudioBuffer.supportsType(ext)) {\n\t\t\t\t\textension = ext;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\turl = url.replace(matches[0], extension);\n\t\t}\n\n\t\t// make sure there is a slash between the baseUrl and the url\n\t\tconst baseUrl = ToneAudioBuffer.baseUrl === \"\" || ToneAudioBuffer.baseUrl.endsWith(\"/\") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + \"/\";\n\t\tconst response = await fetch(baseUrl + url);\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`could not load url: ${url}`);\n\t\t}\n\t\tconst arrayBuffer = await response.arrayBuffer();\n\n\t\tconst audioBuffer = await getContext().decodeAudioData(arrayBuffer);\n\n\t\treturn audioBuffer;\n\t}\n\n\t/**\n\t * Checks a url's extension to see if the current browser can play that file type.\n\t * @param url The url/extension to test\n\t * @return If the file extension can be played\n\t * @static\n\t * @example\n\t * Tone.ToneAudioBuffer.supportsType(\"wav\"); // returns true\n\t * Tone.ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n\t */\n\tstatic supportsType(url: string): boolean {\n\t\tconst extensions = url.split(\".\");\n\t\tconst extension = extensions[extensions.length - 1];\n\t\tconst response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n\t\treturn response !== \"\";\n\t}\n\n\t/**\n\t * Returns a Promise which resolves when all of the buffers have loaded\n\t */\n\tstatic async loaded(): Promise<void> {\n\t\t// this makes sure that the function is always async\n\t\tawait Promise.resolve();\n\t\twhile (ToneAudioBuffer.downloads.length) {\n\t\t\tawait ToneAudioBuffer.downloads[0];\n\t\t}\n\t}\n}\n","import { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { Seconds } from \"../type/Units\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n * @example\n * // generate a single channel, 0.5 second buffer\n * const context = new Tone.OfflineContext(1, 0.5, 44100);\n * const osc = new Tone.Oscillator({ context });\n * context.render().then(buffer => {\n * \tconsole.log(buffer.numberOfChannels, buffer.duration);\n * });\n */\nexport class OfflineContext extends Context {\n\n\treadonly name: string = \"OfflineContext\";\n\n\t/**\n\t * A private reference to the duration\n\t */\n\tprivate readonly _duration: Seconds;\n\n\t/**\n\t * An artificial clock source\n\t */\n\tprivate _currentTime: Seconds = 0;\n\n\t/**\n\t * Private reference to the OfflineAudioContext.\n\t */\n\tprotected _context!: OfflineAudioContext;\n\n\treadonly isOffline: boolean = true;\n\n\t/**\n\t * @param  channels  The number of channels to render\n\t * @param  duration  The duration to render in seconds\n\t * @param sampleRate the sample rate to render at\n\t */\n\tconstructor(\n\t\tchannels: number,\n\t\tduration: Seconds, \n\t\tsampleRate: number,\n\t);\n\tconstructor(context: OfflineAudioContext);\n\tconstructor() {\n\n\t\tsuper({\n\t\t\tclockSource: \"offline\",\n\t\t\tcontext: isOfflineAudioContext(arguments[0]) ?\n\t\t\t\targuments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n\t\t\tlookAhead: 0,\n\t\t\tupdateInterval: isOfflineAudioContext(arguments[0]) ?\n\t\t\t\t128 / arguments[0].sampleRate : 128 / arguments[2],\n\t\t});\n\n\t\tthis._duration = isOfflineAudioContext(arguments[0]) ?\n\t\t\targuments[0].length / arguments[0].sampleRate : arguments[1];\n\t}\n\n\t/**\n\t * Override the now method to point to the internal clock time\n\t */\n\tnow(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Same as this.now()\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Render just the clock portion of the audio context.\n\t */\n\tprivate async _renderClock(asynchronous: boolean): Promise<void> {\n\t\tlet index = 0;\n\t\twhile (this._duration - this._currentTime >= 0) {\n\n\t\t\t// invoke all the callbacks on that time\n\t\t\tthis.emit(\"tick\");\n\n\t\t\t// increment the clock in block-sized chunks\n\t\t\tthis._currentTime += 128 / this.sampleRate;\n\n\t\t\t// yield once a second of audio\n\t\t\tindex++;\n\t\t\tconst yieldEvery = Math.floor(this.sampleRate / 128);\n\t\t\tif (asynchronous && index % yieldEvery === 0) {\n\t\t\t\tawait new Promise(done => setTimeout(done, 1));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Render the output of the OfflineContext\n\t * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n\t */\n\tasync render(asynchronous = true): Promise<ToneAudioBuffer> {\n\t\tawait this.workletsAreReady();\n\t\tawait this._renderClock(asynchronous);\n\t\tconst buffer = await this._context.startRendering();\n\t\treturn new ToneAudioBuffer(buffer);\n\t}\n\n\t/**\n\t * Close the context\n\t */\n\tclose(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n}\n","import { version } from \"../version\";\nimport { AnyAudioContext, hasAudioContext, theWindow } from \"./context/AudioContext\";\nimport { Context } from \"./context/Context\";\nimport { DummyContext } from \"./context/DummyContext\";\nimport { BaseContext } from \"./context/BaseContext\";\nimport { OfflineContext } from \"./context/OfflineContext\";\nimport { isAudioContext, isOfflineAudioContext } from \"./util/AdvancedTypeCheck\";\n\n/**\n * This dummy context is used to avoid throwing immediate errors when importing in Node.js\n */\nconst dummyContext = new DummyContext();\n\n/**\n * The global audio context which is getable and assignable through\n * getContext and setContext\n */\nlet globalContext: BaseContext = dummyContext;\n\n/**\n * Returns the default system-wide [[Context]]\n * @category Core\n */\nexport function getContext(): BaseContext {\n\tif (globalContext === dummyContext && hasAudioContext) {\n\t\tsetContext(new Context());\n\t}\n\treturn globalContext;\n}\n\n/**\n * Set the default audio context\n * @category Core\n */\nexport function setContext(context: BaseContext | AnyAudioContext): void {\n\tif (isAudioContext(context)) {\n\t\tglobalContext = new Context(context);\n\t} else if (isOfflineAudioContext(context)) {\n\t\tglobalContext = new OfflineContext(context);\n\t} else {\n\t\tglobalContext = context;\n\t}\n}\n\n/**\n * Most browsers will not play _any_ audio until a user\n * clicks something (like a play button). Invoke this method\n * on a click or keypress event handler to start the audio context.\n * More about the Autoplay policy\n * [here](https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio)\n * @example\n * document.querySelector(\"button\").addEventListener(\"click\", async () => {\n * \tawait Tone.start();\n * \tconsole.log(\"context started\");\n * });\n * @category Core\n */\nexport function start(): Promise<void> {\n\treturn globalContext.resume();\n}\n\n/**\n * Log Tone.js + version in the console.\n */\nif (theWindow && !theWindow.TONE_SILENCE_LOGGING) {\n\tlet prefix = \"v\";\n\tif (version === \"dev\") {\n\t\tprefix = \"\";\n\t}\n\tconst printString = ` * Tone.js ${prefix}${version} * `;\n\t// eslint-disable-next-line no-console\n\tconsole.log(`%c${printString}`, \"background: #000; color: #fff\");\n}\n","import { BaseContext } from \"./BaseContext\";\nimport { Seconds } from \"../type/Units\";\nimport { AnyAudioContext } from \"./AudioContext\";\n\ntype Draw = import(\"../util/Draw\").Draw;\ntype Destination = import(\"./Destination\").Destination;\ntype Transport = import(\"../clock/Transport\").Transport;\ntype Listener = import(\"./Listener\").Listener;\n\nexport class DummyContext extends BaseContext {\n\t//---------------------------\n\t// BASE AUDIO CONTEXT METHODS\n\t//---------------------------\n\tcreateAnalyser(): AnalyserNode {\n\t\treturn {} as AnalyserNode;\n\t}\n\n\tcreateOscillator(): OscillatorNode {\n\t\treturn {} as OscillatorNode;\n\t}\n\n\tcreateBufferSource() {\n\t\treturn {} as AudioBufferSourceNode;\n\t}\n\n\tcreateBiquadFilter(): BiquadFilterNode {\n\t\treturn {} as BiquadFilterNode;\n\t}\n\n\tcreateBuffer(_numberOfChannels: number, _length: number, _sampleRate: number): AudioBuffer {\n\t\treturn {} as AudioBuffer;\n\t}\n\n\tcreateChannelMerger(_numberOfInputs?: number | undefined): ChannelMergerNode {\n\t\treturn {} as ChannelMergerNode;\n\t}\n\n\tcreateChannelSplitter(_numberOfOutputs?: number | undefined): ChannelSplitterNode {\n\t\treturn {} as ChannelSplitterNode;\n\t}\n\n\tcreateConstantSource(): ConstantSourceNode {\n\t\treturn {} as ConstantSourceNode;\n\t}\n\n\tcreateConvolver(): ConvolverNode {\n\t\treturn {} as ConvolverNode;\n\t}\n\n\tcreateDelay(_maxDelayTime?: number | undefined): DelayNode {\n\t\treturn {} as DelayNode;\n\t}\n\n\tcreateDynamicsCompressor(): DynamicsCompressorNode {\n\t\treturn {} as DynamicsCompressorNode;\n\t}\n\n\tcreateGain(): GainNode {\n\t\treturn {} as GainNode;\n\t}\n\n\tcreateIIRFilter(_feedForward: number[] | Float32Array, _feedback: number[] | Float32Array): IIRFilterNode {\n\t\treturn {} as IIRFilterNode;\n\t}\n\n\tcreatePanner(): PannerNode {\n\t\treturn {} as PannerNode;\n\t}\n\n\tcreatePeriodicWave(\n\t\t_real: number[] | Float32Array,\n\t\t_imag: number[] | Float32Array,\n\t\t_constraints?: PeriodicWaveConstraints | undefined,\n\t): PeriodicWave {\n\t\treturn {} as PeriodicWave;\n\t}\n\n\tcreateStereoPanner(): StereoPannerNode {\n\t\treturn {} as StereoPannerNode;\n\t}\n\n\tcreateWaveShaper(): WaveShaperNode {\n\t\treturn {} as WaveShaperNode;\n\t}\n\n\tcreateMediaStreamSource(_stream: MediaStream): MediaStreamAudioSourceNode {\n\t\treturn {} as MediaStreamAudioSourceNode;\n\t}\n\n\tcreateMediaStreamDestination(): MediaStreamAudioDestinationNode {\n\t\treturn {} as MediaStreamAudioDestinationNode;\n\t}\n\n\tdecodeAudioData(_audioData: ArrayBuffer): Promise<AudioBuffer> {\n\t\treturn Promise.resolve({} as AudioBuffer);\n\t}\n\n\t//---------------------------\n\t// TONE AUDIO CONTEXT METHODS\n\t//---------------------------\n\n\tcreateAudioWorkletNode(\n\t\t_name: string,\n\t\t_options?: Partial<AudioWorkletNodeOptions>\n\t): AudioWorkletNode {\n\t\treturn {} as AudioWorkletNode;\n\t}\n\n\tget rawContext(): AnyAudioContext {\n\t\treturn {} as AnyAudioContext;\n\t}\n\n\tasync addAudioWorkletModule(_url: string, _name: string): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tlookAhead = 0;\n\n\tlatencyHint = 0;\n\n\tresume(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tsetTimeout(_fn: (...args: any[]) => void, _timeout: Seconds): number {\n\t\treturn 0;\n\t}\n\n\tclearTimeout(_id: number): this {\n\t\treturn this;\n\t}\n\n\tsetInterval(_fn: (...args: any[]) => void, _interval: Seconds): number {\n\t\treturn 0;\n\t}\n\n\tclearInterval(_id: number): this {\n\t\treturn this;\n\t}\n\n\tgetConstant(_val: number): AudioBufferSourceNode {\n\t\treturn {} as AudioBufferSourceNode;\n\t}\n\n\tget currentTime(): Seconds {\n\t\treturn 0;\n\t}\n\n\tget state(): AudioContextState {\n\t\treturn {} as AudioContextState;\n\t}\n\n\tget sampleRate(): number {\n\t\treturn 0;\n\t}\n\n\tget listener(): Listener {\n\t\treturn {} as Listener;\n\t}\n\n\tget transport(): Transport {\n\t\treturn {} as Transport;\n\t}\n\n\tget draw(): Draw {\n\t\treturn {} as Draw;\n\t}\n\tset draw(_d) { }\n\n\tget destination(): Destination {\n\t\treturn {} as Destination;\n\t}\n\tset destination(_d: Destination) { }\n\n\tnow() {\n\t\treturn 0;\n\t}\n\n\timmediate() {\n\t\treturn 0;\n\t}\n\n\treadonly isOffline: boolean = false;\n}\n","import { Decibels, GainFactor, Hertz, Interval, MidiNote, NormalRange } from \"./Units\";\n\n/**\n * Equal power gain scale. Good for cross-fading.\n * @param  percent (0-1)\n */\nexport function equalPowerScale(percent: NormalRange): number {\n\tconst piFactor = 0.5 * Math.PI;\n\treturn Math.sin(percent * piFactor);\n}\n\n/**\n * Convert decibels into gain.\n */\nexport function dbToGain(db: Decibels): GainFactor {\n\treturn Math.pow(10, db / 20);\n}\n\n/**\n * Convert gain to decibels.\n */\nexport function gainToDb(gain: GainFactor): Decibels {\n\treturn 20 * (Math.log(gain) / Math.LN10);\n}\n\n/**\n * Convert an interval (in semitones) to a frequency ratio.\n * @param interval the number of semitones above the base note\n * @example\n * Tone.intervalToFrequencyRatio(0); // 1\n * Tone.intervalToFrequencyRatio(12); // 2\n * Tone.intervalToFrequencyRatio(-12); // 0.5\n */\nexport function intervalToFrequencyRatio(interval: Interval): number {\n\treturn Math.pow(2, (interval / 12));\n}\n\n/**\n * The Global [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n * to generate all the other pitch values from notes. A4's values in Hertz.\n */\nlet A4: Hertz = 440;\n\nexport function getA4(): Hertz {\n\treturn A4;\n}\n\nexport function setA4(freq: Hertz): void {\n\tA4 = freq;\n}\n\n/**\n * Convert a frequency value to a MIDI note.\n * @param frequency The value to frequency value to convert.\n * @example\n * Tone.ftom(440); // returns 69\n */\nexport function ftom(frequency: Hertz): MidiNote {\n\treturn Math.round(ftomf(frequency)) as MidiNote;\n}\n\n/**\n * Convert a frequency to a floating point midi value\n */\nexport function ftomf(frequency: Hertz): number {\n\treturn 69 + 12 * Math.log2(frequency / A4);\n}\n\n/**\n * Convert a MIDI note to frequency value.\n * @param  midi The midi number to convert.\n * @return The corresponding frequency value\n * @example\n * Tone.mtof(69); // 440\n */\nexport function mtof(midi: MidiNote): Hertz {\n\treturn A4 * Math.pow(2, (midi - 69) / 12);\n}\n","import { BaseContext } from \"../context/BaseContext\";\nimport { Tone } from \"../Tone\";\nimport { isDefined, isObject, isString, isUndef } from \"../util/TypeCheck\";\nimport { BPM, Hertz, MidiNote, Milliseconds, Samples, Seconds, Ticks, Time } from \"./Units\";\n\nexport type TimeValue = Time | TimeBaseClass<any, any>;\n\n/**\n * The units that the TimeBase can accept. extended by other classes\n */\nexport type TimeBaseUnit = \"s\" | \"n\" | \"t\" | \"m\" | \"i\" | \"hz\" | \"tr\" | \"samples\" | \"number\";\n\nexport interface TypeFunction {\n\tregexp: RegExp;\n\tmethod: (value: string, ...args: string[]) => number;\n}\n\nexport interface TimeExpression<Type extends number> {\n\t[key: string]: {\n\t\tregexp: RegExp;\n\t\tmethod: (value: string, ...args: string[]) => Type;\n\t};\n}\n\n/**\n * TimeBase is a flexible encoding of time which can be evaluated to and from a string.\n */\nexport abstract class TimeBaseClass<Type extends number, Unit extends string> extends Tone {\n\n\treadonly context: BaseContext;\n\n\t/**\n\t * The value of the units\n\t */\n\tprotected _val?: TimeValue;\n\n\t/**\n\t * The units of time\n\t */\n\tprotected _units?: Unit;\n\n\t/**\n\t * All of the conversion expressions\n\t */\n\tprotected _expressions: TimeExpression<Type>;\n\n\t/**\n\t * The default units\n\t */\n\treadonly defaultUnits: Unit = \"s\" as Unit;\n\n\t/**\n\t * @param context The context associated with the time value. Used to compute\n\t * Transport and context-relative timing.\n\t * @param  value  The time value as a number, string or object\n\t * @param  units  Unit values\n\t */\n\tconstructor(context: BaseContext, value?: TimeValue, units?: Unit) {\n\t\tsuper();\n\n\t\tthis._val = value;\n\t\tthis._units = units;\n\t\tthis.context = context;\n\t\tthis._expressions = this._getExpressions();\n\t}\n\n\t/**\n\t * All of the time encoding expressions\n\t */\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn {\n\t\t\thz: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._frequencyToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)hz$/i,\n\t\t\t},\n\t\t\ti: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._ticksToUnits(parseInt(value, 10));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)i$/i,\n\t\t\t},\n\t\t\tm: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)m$/i,\n\t\t\t},\n\t\t\tn: {\n\t\t\t\tmethod: (value, dot) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\tconst scalar = dot === \".\" ? 1.5 : 1;\n\t\t\t\t\tif (numericValue === 1) {\n\t\t\t\t\t\treturn this._beatsToUnits(this._getTimeSignature()) * scalar as Type;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this._beatsToUnits(4 / numericValue) * scalar as Type;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)n(\\.?)$/i,\n\t\t\t},\n\t\t\tnumber: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._expressions[this.defaultUnits].method.call(this, value);\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)$/,\n\t\t\t},\n\t\t\ts: {\n\t\t\t\tmethod: (value): Type => {\n\t\t\t\t\treturn this._secondsToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)s$/,\n\t\t\t},\n\t\t\tsamples: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn parseInt(value, 10) / this.context.sampleRate as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)samples$/,\n\t\t\t},\n\t\t\tt: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\treturn this._beatsToUnits(8 / (Math.floor(numericValue) * 3));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)t$/i,\n\t\t\t},\n\t\t\ttr: {\n\t\t\t\tmethod: (m, q, s) => {\n\t\t\t\t\tlet total = 0;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/,\n\t\t\t},\n\t\t};\n\t}\n\n\t//-------------------------------------\n\t// \tVALUE OF\n\t//-------------------------------------\n\n\t/**\n\t * Evaluate the time value. Returns the time in seconds.\n\t */\n\tvalueOf(): Type {\n\t\tif (this._val instanceof TimeBaseClass) {\n\t\t\tthis.fromType(this._val);\n\t\t}\n\t\tif (isUndef(this._val)) {\n\t\t\treturn this._noArg();\n\t\t} else if (isString(this._val) && isUndef(this._units)) {\n\t\t\tfor (const units in this._expressions) {\n\t\t\t\tif (this._expressions[units].regexp.test(this._val.trim())) {\n\t\t\t\t\tthis._units = units as Unit;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isObject(this._val)) {\n\t\t\tlet total = 0;\n\t\t\tfor (const typeName in this._val) {\n\t\t\t\tif (isDefined(this._val[typeName])) {\n\t\t\t\t\tconst quantity = this._val[typeName];\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconst time = (new this.constructor(this.context, typeName)).valueOf() * quantity;\n\t\t\t\t\ttotal += time;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn total as Type;\n\t\t}\n\t\tif (isDefined(this._units)) {\n\t\t\tconst expr = this._expressions[this._units];\n\t\t\tconst matching = this._val.toString().trim().match(expr.regexp);\n\t\t\tif (matching) {\n\t\t\t\treturn expr.method.apply(this, matching.slice(1));\n\t\t\t} else {\n\t\t\t\treturn expr.method.call(this, this._val);\n\t\t\t}\n\t\t} else if (isString(this._val)) {\n\t\t\treturn parseFloat(this._val) as Type;\n\t\t} else {\n\t\t\treturn this._val as Type;\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// \tUNIT CONVERSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn 1 / freq as Type;\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn (60 / this._getBpm()) * beats as Type;\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn seconds as Type;\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn (ticks * (this._beatsToUnits(1)) / this._getPPQ()) as Type;\n\t}\n\n\t/**\n\t * With no arguments, return 'now'\n\t */\n\tprotected _noArg(): Type {\n\t\treturn this._now();\n\t}\n\n\t//-------------------------------------\n\t// \tTEMPO CONVERSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Return the bpm\n\t */\n\tprotected _getBpm(): BPM {\n\t\treturn this.context.transport.bpm.value;\n\t}\n\n\t/**\n\t * Return the timeSignature\n\t */\n\tprotected _getTimeSignature(): number {\n\t\treturn this.context.transport.timeSignature as number;\n\t}\n\n\t/**\n\t * Return the PPQ or 192 if Transport is not available\n\t */\n\tprotected _getPPQ(): number {\n\t\treturn this.context.transport.PPQ;\n\t}\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected abstract _now(): Type;\n\n\t//-------------------------------------\n\t// \tCONVERSION INTERFACE\n\t//-------------------------------------\n\n\t/**\n\t * Coerce a time type into this units type.\n\t * @param type Any time type units\n\t */\n\tfromType(type: TimeBaseClass<any, any>): this {\n\t\tthis._units = undefined;\n\t\tswitch (this.defaultUnits) {\n\t\t\tcase \"s\":\n\t\t\t\tthis._val = type.toSeconds();\n\t\t\t\tbreak;\n\t\t\tcase \"i\":\n\t\t\t\tthis._val = type.toTicks();\n\t\t\t\tbreak;\n\t\t\tcase \"hz\":\n\t\t\t\tthis._val = type.toFrequency();\n\t\t\t\tbreak;\n\t\t\tcase \"midi\":\n\t\t\t\tthis._val = type.toMidi();\n\t\t\t\tbreak;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the value in seconds\n\t */\n\tabstract toSeconds(): Seconds;\n\n\t/**\n\t * Return the value as a Midi note\n\t */\n\tabstract toMidi(): MidiNote;\n\n\t/**\n\t * Convert the value into ticks\n\t */\n\tabstract toTicks(): Ticks;\n\n\t/**\n\t * Return the value in hertz\n\t */\n\ttoFrequency(): Hertz {\n\t\treturn 1 / this.toSeconds();\n\t}\n\n\t/**\n\t * Return the time in samples\n\t */\n\ttoSamples(): Samples {\n\t\treturn this.toSeconds() * this.context.sampleRate;\n\t}\n\n\t/**\n\t * Return the time in milliseconds.\n\t */\n\ttoMilliseconds(): Milliseconds {\n\t\treturn this.toSeconds() * 1000;\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { ftom } from \"./Conversions\";\nimport { TimeBaseClass, TimeBaseUnit, TimeExpression, TimeValue } from \"./TimeBase\";\nimport { BarsBeatsSixteenths, MidiNote, Seconds, Subdivision, Ticks, Time } from \"./Units\";\n\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * const time = Tone.Time(\"4n\"); // a quarter note\n * @category Unit\n */\nexport class TimeClass<Type extends Seconds | Ticks = Seconds, Unit extends string = TimeBaseUnit>\n\textends TimeBaseClass<Type, Unit> {\n\n\treadonly name: string = \"TimeClass\";\n\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn Object.assign(super._getExpressions(), {\n\t\t\tnow: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\treturn this._now() + new (this.constructor as typeof TimeClass)(this.context, capture).valueOf() as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^\\+(.+)/,\n\t\t\t},\n\t\t\tquantize: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\tconst quantTo = new TimeClass(this.context, capture).valueOf();\n\t\t\t\t\treturn this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));\n\t\t\t\t},\n\t\t\t\tregexp: /^@(.+)/,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Quantize the time by the given subdivision. Optionally add a\n\t * percentage which will move the time value towards the ideal\n\t * quantized value by that percentage.\n\t * @param  subdiv    The subdivision to quantize to\n\t * @param  percent  Move the time value towards the quantized value by a percentage.\n\t * @example\n\t * Tone.Time(21).quantize(2); // returns 22\n\t * Tone.Time(0.6).quantize(\"4n\", 0.5); // returns 0.55\n\t */\n\tquantize(subdiv: Time, percent = 1): Type {\n\t\tconst subdivision = new (this.constructor as typeof TimeClass)(this.context, subdiv).valueOf();\n\t\tconst value = this.valueOf();\n\t\tconst multiple = Math.round(value / subdivision);\n\t\tconst ideal = multiple * subdivision;\n\t\tconst diff = ideal - value;\n\t\treturn value + diff * percent as Type;\n\t}\n\n\t//-------------------------------------\n\t// CONVERSIONS\n\t//-------------------------------------\n\t/**\n\t * Convert a Time to Notation. The notation values are will be the\n\t * closest representation between 1m to 128th note.\n\t * @return {Notation}\n\t * @example\n\t * // if the Transport is at 120bpm:\n\t * Tone.Time(2).toNotation(); // returns \"1m\"\n\t */\n\ttoNotation(): Subdivision {\n\t\tconst time = this.toSeconds();\n\t\tconst testNotations: Subdivision[] = [\"1m\"];\n\t\tfor (let power = 1; power < 9; power++) {\n\t\t\tconst subdiv = Math.pow(2, power);\n\t\t\ttestNotations.push(subdiv + \"n.\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"n\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"t\" as Subdivision);\n\t\t}\n\t\ttestNotations.push(\"0\");\n\t\t// find the closets notation representation\n\t\tlet closest = testNotations[0];\n\t\tlet closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n\t\ttestNotations.forEach(notation => {\n\t\t\tconst notationSeconds = new TimeClass(this.context, notation).toSeconds();\n\t\t\tif (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n\t\t\t\tclosest = notation;\n\t\t\t\tclosestSeconds = notationSeconds;\n\t\t\t}\n\t\t});\n\t\treturn closest;\n\t}\n\n\t/**\n\t * Return the time encoded as Bars:Beats:Sixteenths.\n\t */\n\ttoBarsBeatsSixteenths(): BarsBeatsSixteenths {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tlet quarters = this.valueOf() / quarterTime;\n\t\tquarters = parseFloat(quarters.toFixed(4));\n\t\tconst measures = Math.floor(quarters / this._getTimeSignature());\n\t\tlet sixteenths = (quarters % 1) * 4;\n\t\tquarters = Math.floor(quarters) % this._getTimeSignature();\n\t\tconst sixteenthString = sixteenths.toString();\n\t\tif (sixteenthString.length > 3) {\n\t\t\t// the additional parseFloat removes insignificant trailing zeroes\n\t\t\tsixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n\t\t}\n\t\tconst progress = [measures, quarters, sixteenths];\n\t\treturn progress.join(\":\");\n\t}\n\n\t/**\n\t * Return the time in ticks.\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.round(quarters * this._getPPQ());\n\t}\n\n\t/**\n\t * Return the time in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t * Return the value as a midi note.\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.toFrequency());\n\t}\n\n\tprotected _now(): Type {\n\t\treturn this.context.now() as Type;\n\t}\n}\n\n/**\n * Create a TimeClass from a time string or number. The time is computed against the \n * global Tone.Context. To use a specific context, use [[TimeClass]]\n * @param value A value which represents time\n * @param units The value's units if they can't be inferred by the value.\n * @category Unit\n * @example\n * const time = Tone.Time(\"4n\").toSeconds();\n * console.log(time);\n * @example\n * const note = Tone.Time(1).toNotation();\n * console.log(note);\n * @example\n * const freq = Tone.Time(0.5).toFrequency();\n * console.log(freq);\n */\nexport function Time(value?: TimeValue, units?: TimeBaseUnit): TimeClass<Seconds> {\n\treturn new TimeClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { intervalToFrequencyRatio, mtof } from \"./Conversions\";\nimport { ftom, getA4, setA4 } from \"./Conversions\";\nimport { TimeClass } from \"./Time\";\nimport { TimeBaseUnit, TimeExpression, TimeValue } from \"./TimeBase\";\nimport { Frequency, Hertz, Interval, MidiNote, Note, Seconds, Ticks } from \"./Units\";\n\nexport type FrequencyUnit = TimeBaseUnit | \"midi\";\n\n/**\n * Frequency is a primitive type for encoding Frequency values.\n * Eventually all time values are evaluated to hertz using the `valueOf` method.\n * @example\n * Tone.Frequency(\"C3\"); // 261\n * Tone.Frequency(38, \"midi\");\n * Tone.Frequency(\"C3\").transpose(4);\n * @category Unit\n */\nexport class FrequencyClass<Type extends number = Hertz> extends TimeClass<Type, FrequencyUnit> {\n\n\treadonly name: string = \"Frequency\";\n\n\treadonly defaultUnits: FrequencyUnit = \"hz\";\n\n\t/**\n\t * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n\t * to generate all the other pitch values from notes. A4's values in Hertz.\n\t */\n\tstatic get A4(): Hertz {\n\t\treturn getA4();\n\t}\n\tstatic set A4(freq: Hertz) {\n\t\tsetA4(freq);\n\t}\n\n\t//-------------------------------------\n\t// \tAUGMENT BASE EXPRESSIONS\n\t//-------------------------------------\n\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn Object.assign({}, super._getExpressions(), {\n\t\t\tmidi: {\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?midi)/,\n\t\t\t\tmethod(value): number {\n\t\t\t\t\tif (this.defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\tnote: {\n\t\t\t\tregexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,\n\t\t\t\tmethod(pitch, octave): number {\n\t\t\t\t\tconst index = noteToScaleIndex[pitch.toLowerCase()];\n\t\t\t\t\tconst noteNumber = index + (parseInt(octave, 10) + 1) * 12;\n\t\t\t\t\tif (this.defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn noteNumber;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(noteNumber);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\ttr: {\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n\t\t\t\tmethod(m, q, s): number {\n\t\t\t\t\tlet total = 1;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total;\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\t//-------------------------------------\n\t// \tEXPRESSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Transposes the frequency by the given number of semitones.\n\t * @return  A new transposed frequency\n\t * @example\n\t * Tone.Frequency(\"A4\").transpose(3); // \"C5\"\n\t */\n\ttranspose(interval: Interval): FrequencyClass {\n\t\treturn new FrequencyClass(this.context, this.valueOf() * intervalToFrequencyRatio(interval));\n\t}\n\n\t/**\n\t * Takes an array of semitone intervals and returns\n\t * an array of frequencies transposed by those intervals.\n\t * @return  Returns an array of Frequencies\n\t * @example\n\t * Tone.Frequency(\"A4\").harmonize([0, 3, 7]); // [\"A4\", \"C5\", \"E5\"]\n\t */\n\tharmonize(intervals: Interval[]): FrequencyClass[] {\n\t\treturn intervals.map(interval => {\n\t\t\treturn this.transpose(interval);\n\t\t});\n\t}\n\n\t//-------------------------------------\n\t// \tUNIT CONVERSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Return the value of the frequency as a MIDI note\n\t * @example\n\t * Tone.Frequency(\"C4\").toMidi(); // 60\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.valueOf());\n\t}\n\n\t/**\n\t * Return the value of the frequency in Scientific Pitch Notation\n\t * @example\n\t * Tone.Frequency(69, \"midi\").toNote(); // \"A4\"\n\t */\n\ttoNote(): Note {\n\t\tconst freq = this.toFrequency();\n\t\tconst log = Math.log2(freq / FrequencyClass.A4);\n\t\tlet noteNumber = Math.round(12 * log) + 57;\n\t\tconst octave = Math.floor(noteNumber / 12);\n\t\tif (octave < 0) {\n\t\t\tnoteNumber += -12 * octave;\n\t\t}\n\t\tconst noteName = scaleIndexToNote[noteNumber % 12];\n\t\treturn noteName + octave.toString() as Note;\n\t}\n\n\t/**\n\t * Return the duration of one cycle in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn 1 / super.toSeconds();\n\t}\n\n\t/**\n\t * Return the duration of one cycle in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.floor(quarters * this._getPPQ());\n\t}\n\n\t//-------------------------------------\n\t// \tUNIT CONVERSIONS HELPERS\n\t//-------------------------------------\n\n\t/**\n\t * With no arguments, return 0\n\t */\n\tprotected _noArg(): Type {\n\t\treturn 0 as Type;\n\t}\n\n\t/**\n\t * Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn freq as Type;\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn 1 / ((ticks * 60) / (this._getBpm() * this._getPPQ())) as Type;\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn 1 / super._beatsToUnits(beats) as Type;\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn 1 / seconds as Type;\n\t}\n\n\t/**\n\t * Convert a MIDI note to frequency value.\n\t * @param  midi The midi number to convert.\n\t * @return The corresponding frequency value\n\t */\n\tstatic mtof(midi: MidiNote): Hertz {\n\t\treturn mtof(midi);\n\t}\n\n\t/**\n\t * Convert a frequency value to a MIDI note.\n\t * @param frequency The value to frequency value to convert.\n\t */\n\tstatic ftom(frequency: Hertz): MidiNote {\n\t\treturn ftom(frequency);\n\t}\n}\n\n//-------------------------------------\n// \tFREQUENCY CONVERSIONS\n//-------------------------------------\n\n/**\n * Note to scale index. \n * @hidden\n */\nconst noteToScaleIndex = {\n\tcbb: -2, cb: -1, c: 0, \"c#\": 1, cx: 2,\n\tdbb: 0, db: 1, d: 2, \"d#\": 3, dx: 4,\n\tebb: 2, eb: 3, e: 4, \"e#\": 5, ex: 6,\n\tfbb: 3, fb: 4, f: 5, \"f#\": 6, fx: 7,\n\tgbb: 5, gb: 6, g: 7, \"g#\": 8, gx: 9,\n\tabb: 7, ab: 8, a: 9, \"a#\": 10, ax: 11,\n\tbbb: 9, bb: 10, b: 11, \"b#\": 12, bx: 13,\n};\n\n/**\n * scale index to note (sharps)\n * @hidden\n */\nconst scaleIndexToNote = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\n/**\n * Convert a value into a FrequencyClass object.\n * @category Unit\n * @example\n * const midi = Tone.Frequency(\"C3\").toMidi();\n * console.log(midi);\n * @example\n * const hertz = Tone.Frequency(38, \"midi\").toFrequency();\n * console.log(hertz);\n */\nexport function Frequency(value?: TimeValue | Frequency, units?: FrequencyUnit): FrequencyClass {\n\treturn new FrequencyClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { Seconds, Ticks } from \"../type/Units\";\nimport { TimeClass } from \"./Time\";\nimport { TimeBaseUnit, TimeValue } from \"./TimeBase\";\n\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\nexport class TransportTimeClass<Type extends Seconds | Ticks = Seconds> extends TimeClass<Type> {\n\n\treadonly name: string = \"TransportTime\";\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected _now(): Type {\n\t\treturn this.context.transport.seconds as Type;\n\t}\n}\n\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to [[Time]], but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\nexport function TransportTime(value?: TimeValue, units?: TimeBaseUnit): TransportTimeClass {\n\treturn new TransportTimeClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { FrequencyClass } from \"../type/Frequency\";\nimport { TimeClass } from \"../type/Time\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { getDefaultsFromInstance, optionsFromArguments } from \"../util/Defaults\";\nimport { RecursivePartial } from \"../util/Interface\";\nimport { isArray, isBoolean, isDefined, isNumber, isString, isUndef } from \"../util/TypeCheck\";\nimport { BaseContext } from \"./BaseContext\";\n\n/**\n * A unit which process audio\n */\nexport interface ToneWithContextOptions {\n\tcontext: BaseContext;\n}\n\n/**\n * The Base class for all nodes that have an AudioContext.\n */\nexport abstract class ToneWithContext<Options extends ToneWithContextOptions> extends Tone {\n\n\t/**\n\t * The context belonging to the node.\n\t */\n\treadonly context: BaseContext;\n\n\t/**\n\t * The default context to use if no AudioContext is passed in to the constructor.\n\t * Probably should not be set manually. Used internally.\n\t * @hidden\n\t */\n\treadonly defaultContext?: BaseContext;\n\n\t/**\n\t * Pass in a constructor as the first argument\n\t */\n\tconstructor(context?: BaseContext)\n\tconstructor(options?: Partial<ToneWithContextOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(ToneWithContext.getDefaults(), arguments, [\"context\"]);\n\t\tif (this.defaultContext) {\n\t\t\tthis.context = this.defaultContext;\n\t\t} else {\n\t\t\tthis.context = options.context;\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneWithContextOptions {\n\t\treturn {\n\t\t\tcontext: getContext(),\n\t\t};\n\t}\n\n\t/**\n\t * Return the current time of the Context clock plus the lookAhead.\n\t * @example\n\t * setInterval(() => {\n\t * \tconsole.log(Tone.now());\n\t * }, 100);\n\t */\n\tnow(): Seconds {\n\t\treturn this.context.currentTime + this.context.lookAhead;\n\t}\n\n\t/**\n\t * Return the current time of the Context clock without any lookAhead.\n\t * @example\n\t * setInterval(() => {\n\t * \tconsole.log(Tone.immediate());\n\t * }, 100);\n\t */\n\timmediate(): Seconds {\n\t\treturn this.context.currentTime;\n\t}\n\n\t/**\n\t * The duration in seconds of one sample.\n\t * @example\n\t * console.log(Tone.Transport.sampleTime);\n\t */\n\tget sampleTime(): Seconds {\n\t\treturn 1 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * The number of seconds of 1 processing block (128 samples)\n\t * @example\n\t * console.log(Tone.Destination.blockTime);\n\t */\n\tget blockTime(): Seconds {\n\t\treturn 128 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * Convert the incoming time to seconds\n\t * @example\n\t * const gain = new Tone.Gain();\n\t * console.log(gain.toSeconds(\"4n\"));\n\t */\n\ttoSeconds(time?: Time): Seconds {\n\t\treturn new TimeClass(this.context, time).toSeconds();\n\t}\n\n\t/**\n\t * Convert the input to a frequency number\n\t * @example\n\t * const gain = new Tone.Gain();\n\t * console.log(gain.toFrequency(\"4n\"));\n\t */\n\ttoFrequency(freq: Frequency): Hertz {\n\t\treturn new FrequencyClass(this.context, freq).toFrequency();\n\t}\n\n\t/**\n\t * Convert the input time into ticks\n\t * @example\n\t * const gain = new Tone.Gain();\n\t * console.log(gain.toTicks(\"4n\"));\n\t */\n\ttoTicks(time?: Time | TimeClass): Ticks {\n\t\treturn new TransportTimeClass(this.context, time).toTicks();\n\t}\n\n\t//-------------------------------------\n\t// \tGET/SET\n\t//-------------------------------------\n\n\t/**\n\t * Get a subset of the properties which are in the partial props\n\t */\n\tprotected _getPartialProperties(props: Options): Partial<Options> {\n\t\tconst options = this.get();\n\t\t// remove attributes from the prop that are not in the partial\n\t\tObject.keys(options).forEach(name => {\n\t\t\tif (isUndef(props[name])) {\n\t\t\t\tdelete options[name];\n\t\t\t}\n\t\t});\n\t\treturn options;\n\t}\n\n\t/**\n\t * Get the object's attributes.\n\t * @example\n\t * const osc = new Tone.Oscillator();\n\t * console.log(osc.get());\n\t */\n\tget(): Options {\n\t\tconst defaults = getDefaultsFromInstance(this) as Options;\n\t\tObject.keys(defaults).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute)) {\n\t\t\t\tconst member = this[attribute];\n\t\t\t\tif (isDefined(member) && isDefined(member.value) && isDefined(member.setValueAtTime)) {\n\t\t\t\t\tdefaults[attribute] = member.value;\n\t\t\t\t} else if (member instanceof ToneWithContext) {\n\t\t\t\t\tdefaults[attribute] = member._getPartialProperties(defaults[attribute]);\n\t\t\t\t\t// otherwise make sure it's a serializable type\n\t\t\t\t} else if (isArray(member) || isNumber(member) || isString(member) || isBoolean(member)) {\n\t\t\t\t\tdefaults[attribute] = member;\n\t\t\t\t} else {\n\t\t\t\t\t// remove all undefined and unserializable attributes\n\t\t\t\t\tdelete defaults[attribute];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn defaults;\n\t}\n\n\t/**\n\t * Set multiple properties at once with an object.\n\t * @example\n\t * const filter = new Tone.Filter();\n\t * // set values using an object\n\t * filter.set({\n\t * \tfrequency: 300,\n\t * \ttype: \"highpass\"\n\t * });\n\t */\n\tset(props: RecursivePartial<Options>): this {\n\t\tObject.keys(props).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute) && isDefined(this[attribute])) {\n\t\t\t\tif (this[attribute] && isDefined(this[attribute].value) && isDefined(this[attribute].setValueAtTime)) {\n\t\t\t\t\t// small optimization\n\t\t\t\t\tif (this[attribute].value !== props[attribute]) {\n\t\t\t\t\t\tthis[attribute].value = props[attribute];\n\t\t\t\t\t}\n\t\t\t\t} else if (this[attribute] instanceof ToneWithContext) {\n\t\t\t\t\tthis[attribute].set(props[attribute]);\n\t\t\t\t} else {\n\t\t\t\t\tthis[attribute] = props[attribute];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n}\n","import { Seconds } from \"../type/Units\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\nimport { assertRange } from \"./Debug\";\n\nexport type BasicPlaybackState = \"started\" | \"stopped\";\nexport type PlaybackState = BasicPlaybackState | \"paused\";\n\nexport interface StateTimelineEvent extends TimelineEvent {\n\tstate: PlaybackState;\n}\n\n/**\n * A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n * @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n */\nexport class StateTimeline<AdditionalOptions extends {} = {}> extends Timeline<StateTimelineEvent & AdditionalOptions> {\n\n\treadonly name: string = \"StateTimeline\";\n\n\t/**\n\t * The initial state\n\t */\n\tprivate _initial: PlaybackState;\n\n\tconstructor(initial: PlaybackState = \"stopped\") {\n\t\tsuper();\n\t\tthis._initial = initial;\n\t\tthis.setStateAtTime(this._initial, 0);\n\t}\n\n\t/**\n\t * Returns the scheduled state scheduled before or at\n\t * the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t */\n\tgetValueAtTime(time: Seconds): PlaybackState {\n\t\tconst event = this.get(time);\n\t\tif (event !== null) {\n\t\t\treturn event.state;\n\t\t} else {\n\t\t\treturn this._initial;\n\t\t}\n\t}\n\n\t/**\n\t * Add a state to the timeline.\n\t * @param  state The name of the state to set.\n\t * @param  time  The time to query.\n\t * @param options Any additional options that are needed in the timeline.\n\t */\n\tsetStateAtTime(state: PlaybackState, time: Seconds, options?: AdditionalOptions): this {\n\t\tassertRange(time, 0);\n\t\tthis.add(Object.assign({}, options, {\n\t\t\tstate,\n\t\t\ttime,\n\t\t}));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the event before the time with the given state\n\t * @param  state The state to look for\n\t * @param  time  When to check before\n\t * @return  The event with the given state before the time\n\t */\n\tgetLastState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tfor (let i = index; i >= 0; i--) {\n\t\t\tconst event = this._timeline[i];\n\t\t\tif (event.state === state) {\n\t\t\t\treturn event;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return the event after the time with the given state\n\t * @param  state The state to look for\n\t * @param  time  When to check from\n\t * @return  The event with the given state after the time\n\t */\n\tgetNextState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tif (index !== -1) {\n\t\t\tfor (let i = index; i < this._timeline.length; i++) {\n\t\t\t\tconst event = this._timeline[i];\n\t\t\t\tif (event.state === state) {\n\t\t\t\t\treturn event;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import { AbstractParam } from \"../context/AbstractParam\";\nimport { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { Decibels, Frequency, Positive, Time, UnitMap, UnitName } from \"../type/Units\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\nimport { EQ } from \"../util/Math\";\nimport { assert, assertRange } from \"../util/Debug\";\n\nexport interface ParamOptions<TypeName extends UnitName> extends ToneWithContextOptions {\n\tunits: TypeName;\n\tvalue?: UnitMap[TypeName];\n\tparam: AudioParam | Param<TypeName>;\n\tconvert: boolean;\n\tminValue?: number;\n\tmaxValue?: number;\n\tswappable?: boolean;\n}\n\n/**\n * the possible automation types\n */\ntype AutomationType = \"linearRampToValueAtTime\" | \"exponentialRampToValueAtTime\" | \"setValueAtTime\" | \"setTargetAtTime\" | \"cancelScheduledValues\";\n\ninterface TargetAutomationEvent {\n\ttype: \"setTargetAtTime\";\n\ttime: number;\n\tvalue: number;\n\tconstant: number;\n}\n\ninterface NormalAutomationEvent {\n\ttype: Exclude<AutomationType, \"setTargetAtTime\">;\n\ttime: number;\n\tvalue: number;\n}\n/**\n * The events on the automation\n */\nexport type AutomationEvent = NormalAutomationEvent | TargetAutomationEvent;\n\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n */\nexport class Param<TypeName extends UnitName = \"number\">\n\textends ToneWithContext<ParamOptions<TypeName>>\n\timplements AbstractParam<TypeName> {\n\n\treadonly name: string = \"Param\";\n\n\treadonly input: GainNode | AudioParam;\n\n\treadonly units: UnitName;\n\tconvert: boolean;\n\toverridden = false;\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<AutomationEvent>;\n\n\t/**\n\t * The native parameter to control\n\t */\n\tprotected _param: AudioParam;\n\n\t/**\n\t * The default value before anything is assigned\n\t */\n\tprotected _initialValue: number;\n\n\t/**\n\t * The minimum output value\n\t */\n\tprivate _minOutput = 1e-7;\n\n\t/**\n\t * Private reference to the min and max values if passed into the constructor\n\t */\n\tprivate readonly _minValue?: number;\n\tprivate readonly _maxValue?: number;\n\n\t/**\n\t * If the underlying AudioParam can be swapped out\n\t * using the setParam method. \n\t */\n\tprotected readonly _swappable: boolean;\n\n\t/**\n\t * @param param The AudioParam to wrap\n\t * @param units The unit name\n\t * @param convert Whether or not to convert the value to the target units\n\t */\n\tconstructor(param: AudioParam, units?: TypeName, convert?: boolean);\n\tconstructor(options: Partial<ParamOptions<TypeName>>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n\n\t\tconst options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n\n\t\tassert(isDefined(options.param) &&\n\t\t\t(isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n\n\t\twhile (!isAudioParam(options.param)) {\n\t\t\toptions.param = options.param._param;\n\t\t}\n\n\t\tthis._swappable = isDefined(options.swappable) ? options.swappable : false;\n\t\tif (this._swappable) {\n\t\t\tthis.input = this.context.createGain();\n\t\t\t// initialize\n\t\t\tthis._param = options.param;\n\t\t\tthis.input.connect(this._param);\n\t\t} else {\n\t\t\tthis._param = this.input = options.param;\n\t\t}\n\t\tthis._events = new Timeline<AutomationEvent>(1000);\n\t\tthis._initialValue = this._param.defaultValue;\n\t\tthis.units = options.units;\n\t\tthis.convert = options.convert;\n\t\tthis._minValue = options.minValue;\n\t\tthis._maxValue = options.maxValue;\n\n\t\t// if the value is defined, set it immediately\n\t\tif (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {\n\t\t\tthis.setValueAtTime(options.value, 0);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ParamOptions<any> {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t} as ParamOptions<any>);\n\t}\n\n\tget value(): UnitMap[TypeName] {\n\t\tconst now = this.now();\n\t\treturn this.getValueAtTime(now);\n\t}\n\tset value(value) {\n\t\tthis.cancelScheduledValues(this.now());\n\t\tthis.setValueAtTime(value, this.now());\n\t}\n\n\tget minValue(): number {\n\t\t// if it's not the default minValue, return it\n\t\tif (isDefined(this._minValue)) {\n\t\t\treturn this._minValue;\n\t\t} else if (this.units === \"time\" || this.units === \"frequency\" ||\n\t\t\tthis.units === \"normalRange\" || this.units === \"positive\" ||\n\t\t\tthis.units === \"transportTime\" || this.units === \"ticks\" ||\n\t\t\tthis.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n\t\t\treturn 0;\n\t\t} else if (this.units === \"audioRange\") {\n\t\t\treturn -1;\n\t\t} else if (this.units === \"decibels\") {\n\t\t\treturn -Infinity;\n\t\t} else {\n\t\t\treturn this._param.minValue;\n\t\t}\n\t}\n\n\tget maxValue(): number {\n\t\tif (isDefined(this._maxValue)) {\n\t\t\treturn this._maxValue;\n\t\t} else if (this.units === \"normalRange\" ||\n\t\t\tthis.units === \"audioRange\") {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn this._param.maxValue;\n\t\t}\n\t}\n\n\t/**\n\t * Type guard based on the unit name\n\t */\n\tprivate _is<T>(arg: any, type: UnitName): arg is T {\n\t\treturn this.units === type;\n\t}\n\n\t/**\n\t * Make sure the value is always in the defined range\n\t */\n\tprivate _assertRange(value: number): number {\n\t\tif (isDefined(this.maxValue) && isDefined(this.minValue)) {\n\t\t\tassertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Convert the given value from the type specified by Param.units\n\t * into the destination value (such as Gain or Frequency).\n\t */\n\tprotected _fromType(val: UnitMap[TypeName]): number {\n\t\tif (this.convert && !this.overridden) {\n\t\t\tif (this._is<Time>(val, \"time\")) {\n\t\t\t\treturn this.toSeconds(val);\n\t\t\t} else if (this._is<Decibels>(val, \"decibels\")) {\n\t\t\t\treturn dbToGain(val);\n\t\t\t} else if (this._is<Frequency>(val, \"frequency\")) {\n\t\t\t\treturn this.toFrequency(val);\n\t\t\t} else {\n\t\t\t\treturn val as number;\n\t\t\t}\n\t\t} else if (this.overridden) {\n\t\t\t// if it's overridden, should only schedule 0s\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn val as number;\n\t\t}\n\t}\n\n\t/**\n\t * Convert the parameters value into the units specified by Param.units.\n\t */\n\tprotected _toType(val: number): UnitMap[TypeName] {\n\t\tif (this.convert && this.units === \"decibels\") {\n\t\t\treturn gainToDb(val) as UnitMap[TypeName];\n\t\t} else {\n\t\t\treturn val as UnitMap[TypeName];\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// ABSTRACT PARAM INTERFACE\n\t// all docs are generated from ParamInterface.ts\n\t//-------------------------------------\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst numericValue = this._fromType(value);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n\t\tthis._assertRange(numericValue);\n\t\tthis.log(this.units, \"setValueAtTime\", value, computedTime);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis._param.setValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\tgetValueAtTime(time: Time): UnitMap[TypeName] {\n\t\tconst computedTime = Math.max(this.toSeconds(time), 0);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tconst before = this._events.get(computedTime);\n\t\tlet value = this._initialValue;\n\t\t// if it was set by\n\t\tif (before === null) {\n\t\t\tvalue = this._initialValue;\n\t\t} else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\tlet previousVal;\n\t\t\tif (previous === null) {\n\t\t\t\tpreviousVal = this._initialValue;\n\t\t\t} else {\n\t\t\t\tpreviousVal = previous.value;\n\t\t\t}\n\t\t\tif (before.type === \"setTargetAtTime\") {\n\t\t\t\tvalue = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n\t\t\t}\n\t\t} else if (after === null) {\n\t\t\tvalue = before.value;\n\t\t} else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n\t\t\tlet beforeValue = before.value;\n\t\t\tif (before.type === \"setTargetAtTime\") {\n\t\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\t\tif (previous === null) {\n\t\t\t\t\tbeforeValue = this._initialValue;\n\t\t\t\t} else {\n\t\t\t\t\tbeforeValue = previous.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (after.type === \"linearRampToValueAtTime\") {\n\t\t\t\tvalue = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t} else {\n\t\t\t\tvalue = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = before.value;\n\t\t}\n\t\treturn this._toType(value);\n\t}\n\n\tsetRampPoint(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tlet currentVal = this.getValueAtTime(time);\n\t\tthis.cancelAndHoldAtTime(time);\n\t\tif (this._fromType(currentVal) === 0) {\n\t\t\tcurrentVal = this._toType(this._minOutput);\n\t\t}\n\t\tthis.setValueAtTime(currentVal, time);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], endTime: Time): this {\n\t\tconst numericValue = this._fromType(value);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\tthis._assertRange(numericValue);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"linearRampToValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n\t\tthis._param.linearRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], endTime: Time): this {\n\t\tlet numericValue = this._fromType(value);\n\t\tnumericValue = Math.max(this._minOutput, numericValue);\n\t\tthis._assertRange(numericValue);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\t// store the event\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"exponentialRampToValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n\t\tthis._param.exponentialRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\tlinearRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\ttargetRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialApproachValueAtTime(value, startTime, rampTime);\n\t\treturn this;\n\t}\n\n\texponentialApproachValueAtTime(value: UnitMap[TypeName], time: Time, rampTime: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\trampTime = this.toSeconds(rampTime);\n\t\tconst timeConstant = Math.log(rampTime + 1) / Math.log(200);\n\t\tthis.setTargetAtTime(value, time, timeConstant);\n\t\t// at 90% start a linear ramp to the final value\n\t\tthis.cancelAndHoldAtTime(time + rampTime * 0.9);\n\t\tthis.linearRampToValueAtTime(value, time + rampTime);\n\t\treturn this;\n\t}\n\n\tsetTargetAtTime(value: UnitMap[TypeName], startTime: Time, timeConstant: Positive): this {\n\t\tconst numericValue = this._fromType(value);\n\t\t// The value will never be able to approach without timeConstant > 0.\n\t\tassert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n\t\tconst computedTime = this.toSeconds(startTime);\n\t\tthis._assertRange(numericValue);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n\t\tthis._events.add({\n\t\t\tconstant: timeConstant,\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setTargetAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n\t\tthis._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(values: UnitMap[TypeName][], startTime: Time, duration: Time, scaling = 1): this {\n\t\tduration = this.toSeconds(duration);\n\t\tstartTime = this.toSeconds(startTime);\n\t\tconst startingValue = this._fromType(values[0]) * scaling;\n\t\tthis.setValueAtTime(this._toType(startingValue), startTime);\n\t\tconst segTime = duration / (values.length - 1);\n\t\tfor (let i = 1; i < values.length; i++) {\n\t\t\tconst numericValue = this._fromType(values[i]) * scaling;\n\t\t\tthis.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tassert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n\t\tthis._events.cancel(computedTime);\n\t\tthis._param.cancelScheduledValues(computedTime);\n\t\tthis.log(this.units, \"cancelScheduledValues\", computedTime);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n\t\t// remove the schedule events\n\t\tassert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n\n\t\tthis.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime);\n\t\t\n\t\t// if there is an event at the given computedTime\n\t\t// and that even is not a \"set\"\n\t\tconst before = this._events.get(computedTime);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tif (before && EQ(before.time, computedTime)) {\n\t\t\t// remove everything after\n\t\t\tif (after) {\n\t\t\t\tthis._param.cancelScheduledValues(after.time);\n\t\t\t\tthis._events.cancel(after.time);\n\t\t\t} else {\n\t\t\t\tthis._param.cancelAndHoldAtTime(computedTime);\n\t\t\t\tthis._events.cancel(computedTime + this.sampleTime);\n\t\t\t}\n\t\t} else if (after) {\n\t\t\tthis._param.cancelScheduledValues(after.time);\n\t\t\t// cancel the next event(s)\n\t\t\tthis._events.cancel(after.time);\n\t\t\tif (after.type === \"linearRampToValueAtTime\") {\n\t\t\t\tthis.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t} else if (after.type === \"exponentialRampToValueAtTime\") {\n\t\t\t\tthis.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t}\n\t\t}\n\n\t\t// set the value at the given time\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: valueAtTime,\n\t\t});\n\t\tthis._param.setValueAtTime(valueAtTime, computedTime);\n\t\treturn this;\n\t}\n\n\trampTo(value: UnitMap[TypeName], rampTime: Time = 0.1, startTime?: Time): this {\n\t\tif (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n\t\t\tthis.exponentialRampTo(value, rampTime, startTime);\n\t\t} else {\n\t\t\tthis.linearRampTo(value, rampTime, startTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n\t * The applied values will start at the context's current time and schedule\n\t * all of the events which are scheduled on this Param onto the passed in param.\n\t */\n\tapply(param: Param | AudioParam): this {\n\t\tconst now = this.context.currentTime;\n\t\t// set the param's value at the current time and schedule everything else\n\t\tparam.setValueAtTime(this.getValueAtTime(now) as number, now);\n\t\t// if the previous event was a curve, then set the rest of it\n\t\tconst previousEvent = this._events.get(now);\n\t\tif (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n\t\t\t// approx it until the next event with linear ramps\n\t\t\tconst nextEvent = this._events.getAfter(previousEvent.time);\n\t\t\t// or for 2 seconds if there is no event\n\t\t\tconst endTime = nextEvent ? nextEvent.time : now + 2;\n\t\t\tconst subdivisions = (endTime - now) / 10;\n\t\t\tfor (let i = now; i < endTime; i += subdivisions) {\n\t\t\t\tparam.linearRampToValueAtTime(this.getValueAtTime(i) as number, i);\n\t\t\t}\n\t\t}\n\t\tthis._events.forEachAfter(this.context.currentTime, event => {\n\t\t\tif (event.type === \"cancelScheduledValues\") {\n\t\t\t\tparam.cancelScheduledValues(event.time);\n\t\t\t} else if (event.type === \"setTargetAtTime\") {\n\t\t\t\tparam.setTargetAtTime(event.value, event.time, event.constant);\n\t\t\t} else {\n\t\t\t\tparam[event.type](event.value, event.time);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Replace the Param's internal AudioParam. Will apply scheduled curves \n\t * onto the parameter and replace the connections.\n\t */\n\tsetParam(param: AudioParam): this {\n\t\tassert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n\t\tconst input = this.input as GainNode;\n\t\tinput.disconnect(this._param);\n\t\tthis.apply(param);\n\t\tthis._param = param;\n\t\tinput.connect(this._param);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\treturn this;\n\t}\n\n\tget defaultValue(): UnitMap[TypeName] {\n\t\treturn this._toType(this._param.defaultValue);\n\t}\n\n\t//-------------------------------------\n\t// \tAUTOMATION CURVE CALCULATIONS\n\t// \tMIT License, copyright (c) 2014 Jordan Santell\n\t//-------------------------------------\n\n\t// Calculates the the value along the curve produced by setTargetAtTime\n\tprotected _exponentialApproach(t0: number, v0: number, v1: number, timeConstant: number, t: number): number {\n\t\treturn v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n\t}\n\n\t// Calculates the the value along the curve produced by linearRampToValueAtTime\n\tprotected _linearInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n\t}\n\n\t// Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\tprotected _exponentialInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n\t}\n}\n","import { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\nimport { assert, warn } from \"../util/Debug\";\n\nexport type InputNode = ToneAudioNode | AudioNode | Param<any> | AudioParam;\nexport type OutputNode = ToneAudioNode | AudioNode;\n\ninterface ChannelProperties {\n\tchannelCount: number;\n\tchannelCountMode: ChannelCountMode;\n\tchannelInterpretation: ChannelInterpretation;\n}\n\n/**\n * The possible options for this node\n */\nexport type ToneAudioNodeOptions = ToneWithContextOptions;\n\n/**\n * ToneAudioNode is the base class for classes which process audio.\n */\nexport abstract class ToneAudioNode<Options extends ToneAudioNodeOptions = ToneAudioNodeOptions>\n\textends ToneWithContext<Options> {\n\n\t/**\n\t * The name of the class\n\t */\n\tabstract readonly name: string = \"ToneAudioNode\";\n\n\t/**\n\t * The input node or nodes. If the object is a source,\n\t * it does not have any input and this.input is undefined.\n\t */\n\tabstract input: InputNode | undefined;\n\n\t/**\n\t * The output nodes. If the object is a sink,\n\t * it does not have any output and this.output is undefined.\n\t */\n\tabstract output: OutputNode | undefined;\n\n\t/**\n\t * The number of inputs feeding into the AudioNode.\n\t * For source nodes, this will be 0.\n\t * @example\n\t * const node = new Tone.Gain();\n\t * console.log(node.numberOfInputs);\n\t */\n\tget numberOfInputs(): number {\n\t\tif (isDefined(this.input)) {\n\t\t\tif (isAudioParam(this.input) || this.input instanceof Param) {\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\treturn this.input.numberOfInputs;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The number of outputs of the AudioNode.\n\t * @example\n\t * const node = new Tone.Gain();\n\t * console.log(node.numberOfOutputs);\n\t */\n\tget numberOfOutputs(): number {\n\t\tif (isDefined(this.output)) {\n\t\t\treturn this.output.numberOfOutputs;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * List all of the node that must be set to match the ChannelProperties\n\t */\n\tprotected _internalChannels: OutputNode[] = [];\n\n\t//-------------------------------------\n\t// AUDIO PROPERTIES\n\t//-------------------------------------\n\n\t/**\n\t * Used to decide which nodes to get/set properties on\n\t */\n\tprivate _isAudioNode(node: any): node is AudioNode | ToneAudioNode {\n\t\treturn isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));\n\t}\n\n\t/**\n\t * Get all of the audio nodes (either internal or input/output) which together\n\t * make up how the class node responds to channel input/output\n\t */\n\tprivate _getInternalNodes(): OutputNode[] {\n\t\tconst nodeList = this._internalChannels.slice(0);\n\t\tif (this._isAudioNode(this.input)) {\n\t\t\tnodeList.push(this.input);\n\t\t}\n\t\tif (this._isAudioNode(this.output)) {\n\t\t\tif (this.input !== this.output) {\n\t\t\t\tnodeList.push(this.output);\n\t\t\t}\n\t\t}\n\t\treturn nodeList;\n\t}\n\n\t/**\n\t * Set the audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t * @param options\n\t */\n\tprivate _setChannelProperties(options: ChannelProperties): void {\n\t\tconst nodeList = this._getInternalNodes();\n\t\tnodeList.forEach(node => {\n\t\t\tnode.channelCount = options.channelCount;\n\t\t\tnode.channelCountMode = options.channelCountMode;\n\t\t\tnode.channelInterpretation = options.channelInterpretation;\n\t\t});\n\t}\n\n\t/**\n\t * Get the current audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t */\n\tprivate _getChannelProperties(): ChannelProperties {\n\t\tconst nodeList = this._getInternalNodes();\n\t\tassert(nodeList.length > 0, \"ToneAudioNode does not have any internal nodes\");\n\t\t// use the first node to get properties\n\t\t// they should all be the same\n\t\tconst node = nodeList[0];\n\t\treturn {\n\t\t\tchannelCount: node.channelCount,\n\t\t\tchannelCountMode: node.channelCountMode,\n\t\t\tchannelInterpretation: node.channelInterpretation,\n\t\t};\n\t}\n\n\t/**\n\t * channelCount is the number of channels used when up-mixing and down-mixing\n\t * connections to any inputs to the node. The default value is 2 except for\n\t * specific nodes where its value is specially determined.\n\t */\n\tget channelCount(): number {\n\t\treturn this._getChannelProperties().channelCount;\n\t}\n\tset channelCount(channelCount) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCount }));\n\t}\n\n\t/**\n\t * channelCountMode determines how channels will be counted when up-mixing and\n\t * down-mixing connections to any inputs to the node.\n\t * The default value is \"max\". This attribute has no effect for nodes with no inputs.\n\t * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.\n\t * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped to a maximum value of the given channelCount.\n\t * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n\t */\n\tget channelCountMode(): ChannelCountMode {\n\t\treturn this._getChannelProperties().channelCountMode;\n\t}\n\tset channelCountMode(channelCountMode) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCountMode }));\n\t}\n\n\t/**\n\t * channelInterpretation determines how individual channels will be treated\n\t * when up-mixing and down-mixing connections to any inputs to the node.\n\t * The default value is \"speakers\".\n\t */\n\tget channelInterpretation(): ChannelInterpretation {\n\t\treturn this._getChannelProperties().channelInterpretation;\n\t}\n\tset channelInterpretation(channelInterpretation) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelInterpretation }));\n\t}\n\n\t//-------------------------------------\n\t// CONNECTIONS\n\t//-------------------------------------\n\n\t/**\n\t * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n\t * @param destination The output to connect to\n\t * @param outputNum The output to connect from\n\t * @param inputNum The input to connect to\n\t */\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t * @example\n\t * const osc = new Tone.Oscillator(\"C2\").start();\n\t * osc.toDestination();\n\t */\n\ttoDestination(): this {\n\t\tthis.connect(this.context.destination);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t * See [[toDestination]]\n\t * @deprecated\n\t */\n\ttoMaster(): this {\n\t\twarn(\"toMaster() has been renamed toDestination()\");\n\t\treturn this.toDestination();\n\t}\n\n\t/**\n\t * disconnect the output\n\t */\n\tdisconnect(destination?: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tdisconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output of this node to the rest of the nodes in series.\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3\");\n\t * player.autostart = true;\n\t * const filter = new Tone.AutoFilter(4).start();\n\t * const distortion = new Tone.Distortion(0.5);\n\t * // connect the player to the filter, distortion and then to the master output\n\t * player.chain(filter, distortion, Tone.Destination);\n\t */\n\tchain(...nodes: InputNode[]): this {\n\t\tconnectSeries(this, ...nodes);\n\t\treturn this;\n\t}\n\n\t/**\n\t * connect the output of this node to the rest of the nodes in parallel.\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3\");\n\t * player.autostart = true;\n\t * const pitchShift = new Tone.PitchShift(4).toDestination();\n\t * const filter = new Tone.Filter(\"G5\").toDestination();\n\t * // connect a node to the pitch shift and filter in parallel\n\t * player.fan(pitchShift, filter);\n\t */\n\tfan(...nodes: InputNode[]): this {\n\t\tnodes.forEach(node => this.connect(node));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Dispose and disconnect\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (isDefined(this.input)) {\n\t\t\tif (this.input instanceof ToneAudioNode) {\n\t\t\t\tthis.input.dispose();\n\t\t\t} else if (isAudioNode(this.input)) {\n\t\t\t\tthis.input.disconnect();\n\t\t\t}\n\t\t}\n\t\tif (isDefined(this.output)) {\n\t\t\tif (this.output instanceof ToneAudioNode) {\n\t\t\t\tthis.output.dispose();\n\t\t\t} else if (isAudioNode(this.output)) {\n\t\t\t\tthis.output.disconnect();\n\t\t\t}\n\t\t}\n\t\tthis._internalChannels = [];\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// CONNECTIONS\n//-------------------------------------\n\n/**\n * connect together all of the arguments in series\n * @param nodes\n */\nexport function connectSeries(...nodes: InputNode[]): void {\n\tconst first = nodes.shift();\n\tnodes.reduce((prev, current) => {\n\t\tif (prev instanceof ToneAudioNode) {\n\t\t\tprev.connect(current);\n\t\t} else if (isAudioNode(prev)) {\n\t\t\tconnect(prev, current);\n\t\t}\n\t\treturn current;\n\t}, first);\n}\n\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function connect(srcNode: OutputNode, dstNode: InputNode, outputNumber = 0, inputNumber = 0): void {\n\n\tassert(isDefined(srcNode), \"Cannot connect from undefined node\");\n\tassert(isDefined(dstNode), \"Cannot connect to undefined node\");\n\n\tif (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n\t\tassert(dstNode.numberOfInputs > 0, \"Cannot connect to node with no inputs\");\n\t}\n\tassert(srcNode.numberOfOutputs > 0, \"Cannot connect from node with no outputs\");\n\n\t// resolve the input of the dstNode\n\twhile ((dstNode instanceof ToneAudioNode || dstNode instanceof Param)) {\n\t\tif (isDefined(dstNode.input)) {\n\t\t\tdstNode = dstNode.input;\n\t\t}\n\t}\n\n\twhile (srcNode instanceof ToneAudioNode) {\n\t\tif (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t}\n\n\t// make the connection\n\tif (isAudioParam(dstNode)) {\n\t\tsrcNode.connect(dstNode as AudioParam, outputNumber);\n\t} else {\n\t\tsrcNode.connect(dstNode, outputNumber, inputNumber);\n\t}\n}\n\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function disconnect(\n\tsrcNode: OutputNode,\n\tdstNode?: InputNode,\n\toutputNumber = 0,\n\tinputNumber = 0,\n): void {\n\n\t// resolve the destination node\n\tif (isDefined(dstNode)) {\n\t\twhile (dstNode instanceof ToneAudioNode) {\n\t\t\tdstNode = dstNode.input;\n\t\t}\n\t}\n\n\t// resolve the src node\n\twhile (!(isAudioNode(srcNode))) {\n\t\tif (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t}\n\n\tif (isAudioParam(dstNode)) {\n\t\tsrcNode.disconnect(dstNode, outputNumber);\n\t} else if (isAudioNode(dstNode)) {\n\t\tsrcNode.disconnect(dstNode, outputNumber, inputNumber);\n\t} else {\n\t\tsrcNode.disconnect();\n\t}\n}\n","import { Param } from \"../context/Param\";\nimport { UnitMap, UnitName } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\ninterface GainOptions<TypeName extends UnitName> extends ToneAudioNodeOptions {\n\tgain: UnitMap[TypeName];\n\tunits: TypeName;\n\tconvert: boolean;\n\tminValue?: number;\n\tmaxValue?: number;\n}\n\n/**\n * A thin wrapper around the Native Web Audio GainNode.\n * The GainNode is a basic building block of the Web Audio\n * API and is useful for routing audio and adjusting gains.\n * @category Core\n * @example\n * return Tone.Offline(() => {\n * \tconst gainNode = new Tone.Gain(0).toDestination();\n * \tconst osc = new Tone.Oscillator(30).connect(gainNode).start();\n * \tgainNode.gain.rampTo(1, 0.1);\n * \tgainNode.gain.rampTo(0, 0.4, 0.2);\n * }, 0.7, 1);\n */\nexport class Gain<TypeName extends \"gain\" | \"decibels\" | \"normalRange\" = \"gain\"> extends ToneAudioNode<GainOptions<TypeName>> {\n\n\treadonly name: string = \"Gain\";\n\n\t/**\n\t * The gain parameter of the gain node.\n\t * @example\n\t * const gainNode = new Tone.Gain(0).toDestination();\n\t * const osc = new Tone.Oscillator().connect(gainNode).start();\n\t * gainNode.gain.rampTo(1, 0.1);\n\t * gainNode.gain.rampTo(0, 2, \"+0.5\");\n\t */\n\treadonly gain: Param<TypeName>;\n\n\t/**\n\t * The wrapped GainNode.\n\t */\n\tprivate _gainNode: GainNode = this.context.createGain();\n\n\t// input = output\n\treadonly input: GainNode = this._gainNode;\n\treadonly output: GainNode = this._gainNode;\n\n\t/**\n\t * @param  gain The initial gain of the GainNode\n\t * @param units The units of the gain parameter.\n\t */\n\tconstructor(gain?: UnitMap[TypeName], units?: TypeName);\n\tconstructor(options?: Partial<GainOptions<TypeName>>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]));\n\t\tconst options = optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]);\n\n\t\tthis.gain = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tparam: this._gainNode.gain,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.gain,\n\t\t\tminValue: options.minValue,\n\t\t\tmaxValue: options.maxValue,\n\t\t});\n\t\treadOnly(this, \"gain\");\n\t}\n\n\tstatic getDefaults(): GainOptions<any> {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tgain: 1,\n\t\t\tunits: \"gain\",\n\t\t});\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.disconnect();\n\t\tthis.gain.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../core/context/ToneAudioNode\";\nimport { GainFactor, Seconds, Time } from \"../core/type/Units\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assert } from \"../core/util/Debug\";\nimport { BasicPlaybackState } from \"../core/util/StateTimeline\";\n\nexport type OneShotSourceCurve = \"linear\" | \"exponential\";\n\ntype onEndedCallback = (source: OneShotSource<any>) => void;\n\nexport interface OneShotSourceOptions extends ToneAudioNodeOptions {\n\tonended: onEndedCallback;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tcurve: OneShotSourceCurve;\n}\n\n/**\n * Base class for fire-and-forget nodes\n */\nexport abstract class OneShotSource<\n\tOptions extends ToneAudioNodeOptions\n> extends ToneAudioNode<Options> {\n\t/**\n\t * The callback to invoke after the\n\t * source is done playing.\n\t */\n\tonended: onEndedCallback = noOp;\n\n\t/**\n\t * Sources do not have input nodes\n\t */\n\tinput: undefined;\n\n\t/**\n\t * The start time\n\t */\n\tprotected _startTime = -1;\n\n\t/**\n\t * The stop time\n\t */\n\tprotected _stopTime = -1;\n\n\t/**\n\t * The id of the timeout\n\t */\n\tprivate _timeout = -1;\n\n\t/**\n\t * The public output node\n\t */\n\toutput: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The output gain node.\n\t */\n\tprotected _gainNode = this.output;\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tprotected _fadeIn: Time;\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tprotected _fadeOut: Time;\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tprotected _curve: OneShotSourceCurve;\n\n\tconstructor(options: OneShotSourceOptions) {\n\t\tsuper(options);\n\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t\tthis._curve = options.curve;\n\t\tthis.onended = options.onended;\n\t}\n\n\tstatic getDefaults(): OneShotSourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tcurve: \"linear\" as OneShotSourceCurve,\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tonended: noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Stop the source node\n\t */\n\tprotected abstract _stopSource(time: Seconds): void;\n\n\t/**\n\t * Start the source node at the given time\n\t * @param  time When to start the node\n\t */\n\tprotected abstract start(time?: Time): this;\n\t/**\n\t * Start the source at the given time\n\t * @param  time When to start the source\n\t */\n\tprotected _startGain(time: Seconds, gain: GainFactor = 1): this {\n\t\tassert(\n\t\t\tthis._startTime === -1,\n\t\t\t\"Source cannot be started more than once\"\n\t\t);\n\t\t// apply a fade in envelope\n\t\tconst fadeInTime = this.toSeconds(this._fadeIn);\n\n\t\t// record the start time\n\t\tthis._startTime = time + fadeInTime;\n\t\tthis._startTime = Math.max(this._startTime, this.context.currentTime);\n\n\t\t// schedule the envelope\n\t\tif (fadeInTime > 0) {\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampToValueAtTime(\n\t\t\t\t\tgain,\n\t\t\t\t\ttime + fadeInTime\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.exponentialApproachValueAtTime(\n\t\t\t\t\tgain,\n\t\t\t\t\ttime,\n\t\t\t\t\tfadeInTime\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._gainNode.gain.setValueAtTime(gain, time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source node at the given time.\n\t * @param time When to stop the source\n\t */\n\tstop(time?: Time): this {\n\t\tthis.log(\"stop\", time);\n\t\tthis._stopGain(this.toSeconds(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source at the given time\n\t * @param  time When to stop the source\n\t */\n\tprotected _stopGain(time: Seconds): this {\n\t\tassert(this._startTime !== -1, \"'start' must be called before 'stop'\");\n\t\t// cancel the previous stop\n\t\tthis.cancelStop();\n\n\t\t// the fadeOut time\n\t\tconst fadeOutTime = this.toSeconds(this._fadeOut);\n\n\t\t// schedule the stop callback\n\t\tthis._stopTime = this.toSeconds(time) + fadeOutTime;\n\t\tthis._stopTime = Math.max(this._stopTime, this.context.currentTime);\n\t\tif (fadeOutTime > 0) {\n\t\t\t// start the fade out curve at the given time\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampTo(0, fadeOutTime, time);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.targetRampTo(0, fadeOutTime, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// stop any ongoing ramps, and set the value to 0\n\t\t\tthis._gainNode.gain.cancelAndHoldAtTime(time);\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t}\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._timeout = this.context.setTimeout(() => {\n\t\t\t// allow additional time for the exponential curve to fully decay\n\t\t\tconst additionalTail =\n\t\t\t\tthis._curve === \"exponential\" ? fadeOutTime * 2 : 0;\n\t\t\tthis._stopSource(this.now() + additionalTail);\n\t\t\tthis._onended();\n\t\t}, this._stopTime - this.context.currentTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the onended callback\n\t */\n\tprotected _onended(): void {\n\t\tif (this.onended !== noOp) {\n\t\t\tthis.onended(this);\n\t\t\t// overwrite onended to make sure it only is called once\n\t\t\tthis.onended = noOp;\n\t\t\t// dispose when it's ended to free up for garbage collection only in the online context\n\t\t\tif (!this.context.isOffline) {\n\t\t\t\tconst disposeCallback = () => this.dispose();\n\t\t\t\t// @ts-ignore\n\t\t\t\tif (typeof window.requestIdleCallback !== \"undefined\") {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\twindow.requestIdleCallback(disposeCallback);\n\t\t\t\t} else {\n\t\t\t\t\tsetTimeout(disposeCallback, 1000);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the playback state at the given time\n\t */\n\tgetStateAtTime = function(time: Time): BasicPlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (\n\t\t\tthis._startTime !== -1 &&\n\t\t\tcomputedTime >= this._startTime &&\n\t\t\t(this._stopTime === -1 || computedTime <= this._stopTime)\n\t\t) {\n\t\t\treturn \"started\";\n\t\t} else {\n\t\t\treturn \"stopped\";\n\t\t}\n\t};\n\n\t/**\n\t * Get the playback state at the current time\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Cancel a scheduled stop event\n\t */\n\tcancelStop(): this {\n\t\tthis.log(\"cancelStop\");\n\t\tassert(this._startTime !== -1, \"Source is not started\");\n\t\t// cancel the stop envelope\n\t\tthis._gainNode.gain.cancelScheduledValues(\n\t\t\tthis._startTime + this.sampleTime\n\t\t);\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._stopTime = -1;\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.disconnect();\n\t\treturn this;\n\t}\n}\n","import { connect } from \"../core/context/ToneAudioNode\";\nimport { Param } from \"../core/context/Param\";\nimport { Seconds, Time, UnitMap, UnitName } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { OneShotSource, OneShotSourceOptions } from \"../source/OneShotSource\";\n\nexport interface ToneConstantSourceOptions<TypeName extends UnitName> extends OneShotSourceOptions {\n\tconvert: boolean;\n\toffset: UnitMap[TypeName];\n\tunits: TypeName;\n\tminValue?: number;\n\tmaxValue?: number;\n}\n\n/**\n * Wrapper around the native fire-and-forget ConstantSource.\n * Adds the ability to reschedule the stop method.\n * @category Signal\n */\nexport class ToneConstantSource<TypeName extends UnitName = \"number\"> extends OneShotSource<ToneConstantSourceOptions<TypeName>> {\n\n\treadonly name: string = \"ToneConstantSource\";\n\n\t/**\n\t * The signal generator\n\t */\n\tprivate _source = this.context.createConstantSource();\n\n\t/**\n\t * The offset of the signal generator\n\t */\n\treadonly offset: Param<TypeName>;\n\n\t/**\n\t * @param  offset   The offset value\n\t */\n\tconstructor(offset: UnitMap[TypeName]);\n\tconstructor(options?: Partial<ToneConstantSourceOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneConstantSource.getDefaults(), arguments, [\"offset\"]));\n\t\tconst options = optionsFromArguments(ToneConstantSource.getDefaults(), arguments, [\"offset\"]);\n\n\t\tconnect(this._source, this._gainNode);\n\n\t\tthis.offset = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tparam: this._source.offset,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.offset,\n\t\t\tminValue: options.minValue,\n\t\t\tmaxValue: options.maxValue,\n\t\t});\n\t}\n\n\tstatic getDefaults(): ToneConstantSourceOptions<any> {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\toffset: 1,\n\t\t\tunits: \"number\" as UnitName,\n\t\t});\n\t}\n\n\t/**\n\t * Start the source node at the given time\n\t * @param  time When to start the source\n\t */\n\tstart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tthis._startGain(computedTime);\n\t\tthis._source.start(computedTime);\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tthis._source.stop(time);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this.state === \"started\") {\n\t\t\tthis.stop();\n\t\t}\n\t\tthis._source.disconnect();\n\t\tthis.offset.dispose();\n\t\treturn this;\n\t}\n}\n","import { AbstractParam } from \"../core/context/AbstractParam\";\nimport { Param } from \"../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { connect } from \"../core/context/ToneAudioNode\";\nimport { Time, UnitMap, UnitName } from \"../core/type/Units\";\nimport { isAudioParam } from \"../core/util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { ToneConstantSource } from \"./ToneConstantSource\";\n\nexport interface SignalOptions<TypeName extends UnitName> extends ToneAudioNodeOptions {\n\tvalue: UnitMap[TypeName];\n\tunits: TypeName;\n\tconvert: boolean;\n\tminValue?: number;\n\tmaxValue?: number;\n}\n\n/**\n * A signal is an audio-rate value. Tone.Signal is a core component of the library.\n * Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal\n * has all of the methods available to native Web Audio\n * [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)\n * as well as additional conveniences. Read more about working with signals\n * [here](https://github.com/Tonejs/Tone.js/wiki/Signals).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // a scheduleable signal which can be connected to control an AudioParam or another Signal\n * const signal = new Tone.Signal({\n * \tvalue: \"C4\",\n * \tunits: \"frequency\"\n * }).connect(osc.frequency);\n * // the scheduled ramp controls the connected signal\n * signal.rampTo(\"C2\", 4, \"+0.5\");\n * @category Signal\n */\nexport class Signal<TypeName extends UnitName = \"number\"> extends ToneAudioNode<SignalOptions<any>>\n\timplements AbstractParam<TypeName> {\n\n\treadonly name: string = \"Signal\";\n\n\t/**\n\t * Indicates if the value should be overridden on connection.\n\t */\n\treadonly override: boolean = true;\n\n\t/**\n\t * The constant source node which generates the signal\n\t */\n\tprotected _constantSource: ToneConstantSource<TypeName>;\n\treadonly output: OutputNode;\n\tprotected _param: Param<TypeName>;\n\treadonly input: InputNode;\n\n\t/**\n\t * @param value Initial value of the signal\n\t * @param units The unit name, e.g. \"frequency\"\n\t */\n\tconstructor(value?: UnitMap[TypeName], units?: TypeName);\n\tconstructor(options?: Partial<SignalOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n\n\t\tconst options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]) as SignalOptions<TypeName>;\n\n\t\tthis.output = this._constantSource = new ToneConstantSource({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\toffset: options.value,\n\t\t\tunits: options.units,\n\t\t\tminValue: options.minValue,\n\t\t\tmaxValue: options.maxValue,\n\t\t});\n\t\tthis._constantSource.start(0);\n\t\tthis.input = this._param = this._constantSource.offset;\n\t}\n\n\tstatic getDefaults(): SignalOptions<any> {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\t// start it only when connected to something\n\t\tconnectSignal(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._param.dispose();\n\t\tthis._constantSource.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// ABSTRACT PARAM INTERFACE\n\t// just a proxy for the ConstantSourceNode's offset AudioParam\n\t// all docs are generated from AbstractParam.ts\n\t//-------------------------------------\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tthis._param.setValueAtTime(value, time);\n\t\treturn this;\n\t}\n\tgetValueAtTime(time: Time): UnitMap[TypeName] {\n\t\treturn this._param.getValueAtTime(time);\n\t}\n\tsetRampPoint(time: Time): this {\n\t\tthis._param.setRampPoint(time);\n\t\treturn this;\n\t}\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tthis._param.linearRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tthis._param.exponentialRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tthis._param.exponentialRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\tlinearRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tthis._param.linearRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\ttargetRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tthis._param.targetRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\texponentialApproachValueAtTime(value: UnitMap[TypeName], time: Time, rampTime: Time): this {\n\t\tthis._param.exponentialApproachValueAtTime(value, time, rampTime);\n\t\treturn this;\n\t}\n\tsetTargetAtTime(value: UnitMap[TypeName], startTime: Time, timeConstant: number): this {\n\t\tthis._param.setTargetAtTime(value, startTime, timeConstant);\n\t\treturn this;\n\t}\n\tsetValueCurveAtTime(values: UnitMap[TypeName][], startTime: Time, duration: Time, scaling?: number): this {\n\t\tthis._param.setValueCurveAtTime(values, startTime, duration, scaling);\n\t\treturn this;\n\t}\n\tcancelScheduledValues(time: Time): this {\n\t\tthis._param.cancelScheduledValues(time);\n\t\treturn this;\n\t}\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tthis._param.cancelAndHoldAtTime(time);\n\t\treturn this;\n\t}\n\trampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tthis._param.rampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\n\tget value(): UnitMap[TypeName] {\n\t\treturn this._param.value;\n\t}\n\tset value(value: UnitMap[TypeName]) {\n\t\tthis._param.value = value;\n\t}\n\n\tget convert(): boolean {\n\t\treturn this._param.convert;\n\t}\n\tset convert(convert: boolean) {\n\t\tthis._param.convert = convert;\n\t}\n\n\tget units(): UnitName {\n\t\treturn this._param.units;\n\t}\n\n\tget overridden(): boolean {\n\t\treturn this._param.overridden;\n\t}\n\tset overridden(overridden: boolean) {\n\t\tthis._param.overridden = overridden;\n\t}\n\n\tget maxValue(): number {\n\t\treturn this._param.maxValue;\n\t}\n\tget minValue(): number {\n\t\treturn this._param.minValue;\n\t}\n\n\t/**\n\t * See [[Param.apply]].\n\t */\n\tapply(param: Param | AudioParam): this {\n\t\tthis._param.apply(param);\n\t\treturn this;\n\t}\n}\n\n/**\n * When connecting from a signal, it's necessary to zero out the node destination\n * node if that node is also a signal. If the destination is not 0, then the values\n * will be summed. This method insures that the output of the destination signal will\n * be the same as the source signal, making the destination signal a pass through node.\n * @param signal The output signal to connect from\n * @param destination the destination to connect to\n * @param outputNum the optional output number\n * @param inputNum the input number\n */\nexport function connectSignal(signal: OutputNode, destination: InputNode, outputNum?: number, inputNum?: number): void {\n\tif (destination instanceof Param || isAudioParam(destination) ||\n\t\t(destination instanceof Signal && destination.override)) {\n\t\t// cancel changes\n\t\tdestination.cancelScheduledValues(0);\n\t\t// reset the value\n\t\tdestination.setValueAtTime(0, 0);\n\t\t// mark the value as overridden\n\t\tif (destination instanceof Signal) {\n\t\t\tdestination.overridden = true;\n\t\t}\n\t}\n\tconnect(signal, destination, outputNum, inputNum);\n}\n","import { AutomationEvent, Param, ParamOptions } from \"../context/Param\";\nimport { Seconds, Ticks, Time, UnitMap, UnitName } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n\ntype TickAutomationEvent = AutomationEvent & {\n\tticks: number;\n};\n\ninterface TickParamOptions<TypeName extends UnitName> extends ParamOptions<TypeName> {\n\tmultiplier: number;\n}\n\n/**\n * A Param class just for computing ticks. Similar to the [[Param]] class,\n * but offers conversion to BPM values as well as ability to compute tick\n * duration and elapsed ticks\n */\nexport class TickParam<TypeName extends \"hertz\" | \"bpm\"> extends Param<TypeName> {\n\n\treadonly name: string = \"TickParam\";\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<TickAutomationEvent> = new Timeline(Infinity);\n\n\t/**\n\t * The internal holder for the multiplier value\n\t */\n\tprivate _multiplier = 1;\n\n\t/**\n\t * @param param The AudioParam to wrap\n\t * @param units The unit name\n\t * @param convert Whether or not to convert the value to the target units\n\t */\n\t/**\n\t * @param value The initial value of the signal\n\t */\n\tconstructor(value?: number);\n\tconstructor(options: Partial<TickParamOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]));\n\t\tconst options = optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]);\n\n\t\t// set the multiplier\n\t\tthis._multiplier = options.multiplier;\n\n\t\t// clear the ticks from the beginning\n\t\tthis._events.cancel(0);\n\t\t// set an initial event\n\t\tthis._events.add({\n\t\t\tticks: 0,\n\t\t\ttime: 0,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: this._fromType(options.value),\n\t\t});\n\t\tthis.setValueAtTime(options.value, 0);\n\t}\n\n\tstatic getDefaults(): TickParamOptions<any> {\n\t\treturn Object.assign(Param.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tsetTargetAtTime(value: UnitMap[TypeName], time: Time, constant: number): this {\n\t\t// approximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tthis.setRampPoint(time);\n\t\tconst computedValue = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\tconst segments = Math.round(Math.max(1 / constant, 1));\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = constant * i + time;\n\t\t\tconst rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.setValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.linearRampToValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\t// aproximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tconst computedVal = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\t// approx 10 segments per second\n\t\tconst segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n\t\tconst segmentDur = ((time - prevEvent.time) / segments);\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = segmentDur * i + prevEvent.time;\n\t\t\tconst rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  event The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tprivate _getTicksUntilEvent(event: TickAutomationEvent | null, time: number): Ticks {\n\t\tif (event === null) {\n\t\t\tevent = {\n\t\t\t\tticks: 0,\n\t\t\t\ttime: 0,\n\t\t\t\ttype: \"setValueAtTime\",\n\t\t\t\tvalue: 0,\n\t\t\t};\n\t\t} else if (isUndef(event.ticks)) {\n\t\t\tconst previousEvent = this._events.previousEvent(event);\n\t\t\tevent.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n\t\t}\n\t\tconst val0 = this._fromType(this.getValueAtTime(event.time));\n\t\tlet val1 = this._fromType(this.getValueAtTime(time));\n\t\t// if it's right on the line, take the previous value\n\t\tconst onTheLineEvent = this._events.get(time);\n\t\tif (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValueAtTime\") {\n\t\t\tval1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n\t\t}\n\t\treturn 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst event = this._events.get(computedTime);\n\t\treturn Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n\t}\n\n\t/**\n\t * Return the elapsed time of the number of ticks from the given time\n\t * @param ticks The number of ticks to calculate\n\t * @param  time The time to get the next tick from\n\t * @return The duration of the number of ticks from the given time in seconds\n\t */\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst currentTick = this.getTicksAtTime(time);\n\t\treturn this.getTimeOfTick(currentTick + ticks) - computedTime;\n\t}\n\n\t/**\n\t * Given a tick, returns the time that tick occurs at.\n\t * @return The time that the tick occurs.\n\t */\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\tconst before = this._events.get(tick, \"ticks\");\n\t\tconst after = this._events.getAfter(tick, \"ticks\");\n\t\tif (before && before.ticks === tick) {\n\t\t\treturn before.time;\n\t\t} else if (before && after &&\n\t\t\tafter.type === \"linearRampToValueAtTime\" &&\n\t\t\tbefore.value !== after.value) {\n\t\t\tconst val0 = this._fromType(this.getValueAtTime(before.time));\n\t\t\tconst val1 = this._fromType(this.getValueAtTime(after.time));\n\t\t\tconst delta = (val1 - val0) / (after.time - before.time);\n\t\t\tconst k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n\t\t\tconst sol1 = (-val0 + k) / delta;\n\t\t\tconst sol2 = (-val0 - k) / delta;\n\t\t\treturn (sol1 > 0 ? sol1 : sol2) + before.time;\n\t\t} else if (before) {\n\t\t\tif (before.value === 0) {\n\t\t\t\treturn Infinity;\n\t\t\t} else {\n\t\t\t\treturn before.time + (tick - before.ticks) / before.value;\n\t\t\t}\n\t\t} else {\n\t\t\treturn tick / this._initialValue;\n\t\t}\n\t}\n\n\t/**\n\t * Convert some number of ticks their the duration in seconds accounting\n\t * for any automation curves starting at the given time.\n\t * @param  ticks The number of ticks to convert to seconds.\n\t * @param  when  When along the automation timeline to convert the ticks.\n\t * @return The duration in seconds of the ticks.\n\t */\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this.getDurationOfTicks(ticks, when);\n\t}\n\n\t/**\n\t * The inverse of [[ticksToTime]]. Convert a duration in\n\t * seconds to the corresponding number of ticks accounting for any\n\t * automation curves starting at the given time.\n\t * @param  duration The time interval to convert to ticks.\n\t * @param  when When along the automation timeline to convert the ticks.\n\t * @return The duration in ticks.\n\t */\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tconst startTicks = this.getTicksAtTime(computedTime);\n\t\tconst endTicks = this.getTicksAtTime(computedTime + computedDuration);\n\t\treturn endTicks - startTicks;\n\t}\n\n\t/**\n\t * Convert from the type when the unit value is BPM\n\t */\n\tprotected _fromType(val: UnitMap[TypeName]): number {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn 1 / (60 / val / this.multiplier);\n\t\t} else {\n\t\t\treturn super._fromType(val);\n\t\t}\n\t}\n\n\t/**\n\t * Special case of type conversion where the units === \"bpm\"\n\t */\n\tprotected _toType(val: number): UnitMap[TypeName] {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn (val / this.multiplier) * 60 as UnitMap[TypeName];\n\t\t} else {\n\t\t\treturn super._toType(val);\n\t\t}\n\t}\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\t// get and reset the current value with the new multiplier\n\t\t// might be necessary to clear all the previous values\n\t\tconst currentVal = this.value;\n\t\tthis._multiplier = m;\n\t\tthis.cancelScheduledValues(0);\n\t\tthis.setValueAtTime(currentVal, 0);\n\t}\n}\n","import { Signal, SignalOptions } from \"../../signal/Signal\";\nimport { InputNode } from \"../context/ToneAudioNode\";\nimport { Seconds, Ticks, Time, UnitMap, UnitName } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { TickParam } from \"./TickParam\";\n\ninterface TickSignalOptions<TypeName extends UnitName> extends SignalOptions<TypeName> {\n\tvalue: UnitMap[TypeName];\n\tmultiplier: number;\n}\n\n/**\n * TickSignal extends Tone.Signal, but adds the capability\n * to calculate the number of elapsed ticks. exponential and target curves\n * are approximated with multiple linear ramps.\n *\n * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,\n * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)\n * describing integrating timing functions for tempo calculations.\n */\nexport class TickSignal<TypeName extends \"hertz\" | \"bpm\"> extends Signal<TypeName> {\n\n\treadonly name: string = \"TickSignal\";\n\n\t/**\n\t * The param which controls the output signal value\n\t */\n\tprotected _param: TickParam<TypeName>;\n\treadonly input: InputNode;\n\n\t/**\n\t * @param value The initial value of the signal\n\t */\n\tconstructor(value?: UnitMap[TypeName]);\n\tconstructor(options: Partial<TickSignalOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]));\n\t\tconst options = optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis.input = this._param = new TickParam({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tmultiplier: options.multiplier,\n\t\t\tparam: this._constantSource.offset,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.value,\n\t\t});\n\t}\n\n\tstatic getDefaults(): TickSignalOptions<any> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this._param.ticksToTime(ticks, when);\n\t}\n\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\treturn this._param.timeToTicks(duration, when);\n\t}\n\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\treturn this._param.getTimeOfTick(tick);\n\t}\n\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\treturn this._param.getDurationOfTicks(ticks, time);\n\t}\n\n\tgetTicksAtTime(time: Time): Ticks {\n\t\treturn this._param.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._param.multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\tthis._param.multiplier = m;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._param.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline, StateTimelineEvent } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n\ninterface TickSourceOptions extends ToneWithContextOptions {\n\tfrequency: number;\n\tunits: \"bpm\" | \"hertz\";\n}\n\ninterface TickSourceOffsetEvent {\n\tticks: number;\n\ttime: number;\n\tseconds: number;\n}\n\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport class TickSource<TypeName extends \"bpm\" | \"hertz\"> extends ToneWithContext<TickSourceOptions> {\n\n\treadonly name: string = \"TickSource\";\n\n\t/**\n\t * The frequency the callback function should be invoked.\n\t */\n\treadonly frequency: TickSignal<TypeName>;\n\n\t/**\n\t * The state timeline\n\t */\n\tprivate _state: StateTimeline = new StateTimeline();\n\n\t/**\n\t * The offset values of the ticks\n\t */\n\tprivate _tickOffset: Timeline<TickSourceOffsetEvent> = new Timeline();\n\n\t/**\n\t * @param frequency The initial frequency that the signal ticks at\n\t */\n\tconstructor(frequency?: number);\n\tconstructor(options?: Partial<TickSourceOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis.frequency = new TickSignal({\n\t\t\tcontext: this.context,\n\t\t\tunits: options.units as TypeName,\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\t// set the initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\t\t// add the first event\n\t\tthis.setTicksAtTime(0, 0);\n\t}\n\n\tstatic getDefaults(): TickSourceOptions {\n\t\treturn Object.assign({\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\" as \"hertz\",\n\t\t}, ToneWithContext.getDefaults());\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the clock at the given time. Optionally pass in an offset\n\t * of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset The number of ticks to start the source at\n\t */\n\tstart(time: Time, offset?: Ticks): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (isDefined(offset)) {\n\t\t\t\tthis.setTicksAtTime(offset, computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// cancel the previous stop\n\t\tif (this._state.getValueAtTime(computedTime) === \"stopped\") {\n\t\t\tconst event = this._state.get(computedTime);\n\t\t\tif (event && event.time > 0) {\n\t\t\t\tthis._tickOffset.cancel(event.time);\n\t\t\t\tthis._state.cancel(event.time);\n\t\t\t}\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis.setTicksAtTime(0, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n\t * @param time When to clear the events after\n\t */\n\tcancel(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._state.cancel(time);\n\t\tthis._tickOffset.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the elapsed ticks at the given time\n\t * @param  time  When to get the tick value\n\t * @return The number of ticks\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", computedTime) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time: computedTime };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedTicks = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedTicks = offsetEvent.ticks;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedTicks;\n\t}\n\n\t/**\n\t * The number of times the callback was invoked. Starts counting at 0\n\t * and increments after the callback was invoked. Returns -1 when stopped.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this.getTicksAtTime(this.now());\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis.setTicksAtTime(t, this.now());\n\t}\n\n\t/**\n\t * The time since ticks=0 that the TickSource has been running. Accounts\n\t * for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this.getSecondsAtTime(this.now());\n\t}\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this.frequency.timeToTicks(s, now);\n\t\tthis.setTicksAtTime(ticks, now);\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\ttime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", time) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedSeconds = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedSeconds = offsetEvent.seconds;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedSeconds += e.time - periodStartTime;\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedSeconds;\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._tickOffset.cancel(time);\n\t\tthis._tickOffset.add({\n\t\t\tseconds: this.frequency.getDurationOfTicks(ticks, time),\n\t\t\tticks,\n\t\t\ttime,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\ttime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  tick The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\tconst offset = this._tickOffset.get(before) as TickSourceOffsetEvent;\n\t\tconst event = this._state.get(before) as StateTimelineEvent;\n\t\tconst startTime = Math.max(offset.time, event.time);\n\t\tconst absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n\t\treturn this.frequency.getTimeOfTick(absoluteTicks);\n\t}\n\n\t/**\n\t * Invoke the callback event at all scheduled ticks between the\n\t * start time and the end time\n\t * @param  startTime  The beginning of the search range\n\t * @param  endTime    The end of the search range\n\t * @param  callback   The callback to invoke with each tick\n\t */\n\tforEachTickBetween(startTime: number, endTime: number, callback: (when: Seconds, ticks: Ticks) => void): this {\n\t\t// only iterate through the sections where it is \"started\"\n\t\tlet lastStateEvent = this._state.get(startTime);\n\t\tthis._state.forEachBetween(startTime, endTime, event => {\n\t\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n\t\t\t\tthis.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);\n\t\t\t}\n\t\t\tlastStateEvent = event;\n\t\t});\n\n\t\tlet error: Error | null = null;\n\n\t\tif (lastStateEvent && lastStateEvent.state === \"started\") {\n\t\t\tconst maxStartTime = Math.max(lastStateEvent.time, startTime);\n\t\t\t// figure out the difference between the frequency ticks and the\n\t\t\tconst startTicks = this.frequency.getTicksAtTime(maxStartTime);\n\t\t\tconst ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n\t\t\tconst diff = startTicks - ticksAtStart;\n\t\t\tlet offset = Math.ceil(diff) - diff;\n\t\t\t// guard against floating point issues\n\t\t\toffset = EQ(offset, 1) ? 0 : offset;\n\t\t\tlet nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\t\t\twhile (nextTickTime < endTime) {\n\t\t\t\ttry {\n\t\t\t\t\tcallback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\terror = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._state.dispose();\n\t\tthis._tickOffset.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline } from \"../util/StateTimeline\";\nimport { TickSignal } from \"./TickSignal\";\nimport { TickSource } from \"./TickSource\";\nimport { assertContextRunning } from \"../util/Debug\";\n\ntype ClockCallback = (time: Seconds, ticks?: Ticks) => void;\n\ninterface ClockOptions extends ToneWithContextOptions {\n\tfrequency: Hertz;\n\tcallback: ClockCallback;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ntype ClockEvent = \"start\" | \"stop\" | \"pause\";\n\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\nexport class Clock<TypeName extends \"bpm\" | \"hertz\" = \"hertz\">\n\textends ToneWithContext<ClockOptions> implements Emitter<ClockEvent> {\n\n\treadonly name: string = \"Clock\";\n\n\t/**\n\t * The callback function to invoke at the scheduled tick.\n\t */\n\tcallback: ClockCallback = noOp;\n\n\t/**\n\t * The tick counter\n\t */\n\tprivate _tickSource: TickSource<TypeName>;\n\n\t/**\n\t * The last time the loop callback was invoked\n\t */\n\tprivate _lastUpdate = 0;\n\n\t/**\n\t * Keep track of the playback state\n\t */\n\tprivate _state: StateTimeline = new StateTimeline(\"stopped\");\n\n\t/**\n\t * Context bound reference to the _loop method\n\t * This is necessary to remove the event in the end.\n\t */\n\tprivate _boundLoop: () => void = this._loop.bind(this);\n\n\t/**\n\t * The rate the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<TypeName>;\n\n\t/**\n\t * @param callback The callback to be invoked with the time of the audio event\n\t * @param frequency The rate of the callback\n\t */\n\tconstructor(callback?: ClockCallback, frequency?: Frequency);\n\tconstructor(options: Partial<ClockOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n\t\tconst options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n\n\t\tthis.callback = options.callback;\n\t\tthis._tickSource = new TickSource({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tunits: options.units,\n\t\t});\n\t\tthis._lastUpdate = 0;\n\t\tthis.frequency = this._tickSource.frequency;\n\t\treadOnly(this, \"frequency\");\n\n\t\t// add an initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\n\t\t// bind a callback to the worker thread\n\t\tthis.context.on(\"tick\", this._boundLoop);\n\t}\n\n\tstatic getDefaults(): ClockOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp as ClockCallback,\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\",\n\t\t}) as ClockOptions;\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the clock at the given time. Optionally pass in an offset\n\t * of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset  Where the tick counter starts counting from.\n\t */\n\tstart(time?: Time, offset?: Ticks): this {\n\t\t// make sure the context is running\n\t\tassertContextRunning(this.context);\n\t\t// start the loop\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis._tickSource.start(computedTime, offset);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"start\", computedTime, offset);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t * @example\n\t * const clock = new Tone.Clock(time => {\n\t * \tconsole.log(time);\n\t * }, 1);\n\t * clock.start();\n\t * // stop the clock after 10 seconds\n\t * clock.stop(\"+10\");\n\t */\n\tstop(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"stop\", computedTime);\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis._tickSource.stop(computedTime);\n\t\tif (computedTime < this._lastUpdate) {\n\t\t\tthis.emit(\"stop\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t\tthis._tickSource.pause(computedTime);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"pause\", computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The number of times the callback was invoked. Starts counting at 0\n\t * and increments after the callback was invoked.\n\t */\n\tget ticks(): Ticks {\n\t\treturn Math.ceil(this.getTicksAtTime(this.now()));\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis._tickSource.ticks = t;\n\t}\n\n\t/**\n\t * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._tickSource.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tthis._tickSource.seconds = s;\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._tickSource.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\tthis._tickSource.setTicksAtTime(ticks, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  tick The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\treturn this._tickSource.getTimeOfTick(tick, before);\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn this._tickSource.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the next tick\n\t * @param  offset The tick number.\n\t */\n\tnextTickTime(offset: Ticks, when: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst currentTick = this.getTicksAtTime(computedTime);\n\t\treturn this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n\t}\n\n\t/**\n\t * The scheduling loop.\n\t */\n\tprivate _loop(): void {\n\n\t\tconst startTime = this._lastUpdate;\n\t\tconst endTime = this.now();\n\t\tthis._lastUpdate = endTime;\n\t\tthis.log(\"loop\", startTime, endTime);\n\n\t\tif (startTime !== endTime) {\n\t\t\t// the state change events\n\t\t\tthis._state.forEachBetween(startTime, endTime, e => {\n\t\t\t\tswitch (e.state) {\n\t\t\t\t\tcase \"started\":\n\t\t\t\t\t\tconst offset = this._tickSource.getTicksAtTime(e.time);\n\t\t\t\t\t\tthis.emit(\"start\", e.time, offset);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"stopped\":\n\t\t\t\t\t\tif (e.time !== 0) {\n\t\t\t\t\t\t\tthis.emit(\"stop\", e.time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"paused\":\n\t\t\t\t\t\tthis.emit(\"pause\", e.time);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// the tick callbacks\n\t\t\tthis._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n\t\t\t\tthis.callback(time, ticks);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t * @example\n\t * const clock = new Tone.Clock();\n\t * clock.start(\"+0.1\");\n\t * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(computedTime);\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.context.off(\"tick\", this._boundLoop);\n\t\tthis._tickSource.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t//-------------------------------------\n\n\ton!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\tonce!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\toff!: (event: ClockEvent, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Clock);\n","import { Timeline, TimelineEvent } from \"./Timeline\";\nimport { Tone } from \"../Tone\";\nimport { Seconds } from \"../type/Units\";\n\ninterface TimelineValueEvent<T> extends TimelineEvent {\n\tvalue: T;\n}\n\n/**\n * Represents a single value which is gettable and settable in a timed way\n */\nexport class TimelineValue<Type> extends Tone {\n\n\treadonly name: string = \"TimelineValue\";\n\n\t/**\n\t * The timeline which stores the values\n\t */\n\tprivate _timeline: Timeline<TimelineValueEvent<Type>> = new Timeline({ memory: 10 })\n\n\t/**\n\t * Hold the value to return if there is no scheduled values\n\t */\n\tprivate _initialValue: Type;\n\n\t/**\n\t * @param initialValue The value to return if there is no scheduled values\n\t */\n\tconstructor(initialValue: Type) {\n\n\t\tsuper();\n\t\tthis._initialValue = initialValue;\n\t}\n\n\t/**\n\t * Set the value at the given time\n\t */\n\tset(value: Type, time: Seconds): this {\n\t\tthis._timeline.add({\n\t\t\tvalue, time\n\t\t});\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Get the value at the given time\n\t */\n\tget(time: Seconds): Type {\n\t\tconst event = this._timeline.get(time);\n\t\tif (event) {\n\t\t\treturn event.value;\n\t\t} else {\n\t\t\treturn this._initialValue;\n\t\t}\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { TimeBaseUnit, TimeValue } from \"./TimeBase\";\nimport { TransportTimeClass } from \"./TransportTime\";\nimport { Seconds, Ticks } from \"./Units\";\n\n/**\n * Ticks is a primitive type for encoding Time values.\n * Ticks can be constructed with or without the `new` keyword. Ticks can be passed\n * into the parameter of any method which takes time as an argument.\n * @example\n * const t = Tone.Ticks(\"4n\"); // a quarter note as ticks\n * @category Unit\n */\nexport class TicksClass extends TransportTimeClass<Ticks> {\n\n\treadonly name: string = \"Ticks\";\n\n\treadonly defaultUnits: TimeBaseUnit = \"i\";\n\n\t/**\n\t * Get the current time in the given units\n\t */\n\tprotected _now(): Ticks {\n\t\treturn this.context.transport.ticks;\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Ticks {\n\t\treturn this._getPPQ() * beats;\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Ticks {\n\t\treturn Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Ticks {\n\t\treturn ticks;\n\t}\n\n\t/**\n\t * Return the time in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\treturn this.valueOf() as Ticks;\n\t}\n\n\t/**\n\t * Return the time in seconds\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn (this.valueOf() / this._getPPQ()) * (60 / this._getBpm());\n\t}\n}\n\n/**\n * Convert a time representation to ticks\n * @category Unit\n */\nexport function Ticks(value?: TimeValue, units?: TimeBaseUnit): TicksClass {\n\treturn new TicksClass(getContext(), value, units);\n}\n","import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\nimport { assert } from \"./Debug\";\n\n/**\n * An IntervalTimeline event must have a time and duration\n */\nexport interface IntervalTimelineEvent {\n\ttime: number;\n\tduration: number;\n\t[propName: string]: any;\n}\n\ntype IteratorCallback = (event: IntervalTimelineEvent) => void;\n\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\nexport class IntervalTimeline extends Tone {\n\n\treadonly name: string = \"IntervalTimeline\";\n\n\t/**\n\t * The root node of the inteval tree\n\t */\n\tprivate _root: IntervalNode | null = null;\n\n\t/**\n\t * Keep track of the length of the timeline.\n\t */\n\tprivate _length = 0;\n\n\t/**\n\t * The event to add to the timeline. All events must\n\t * have a time and duration value\n\t * @param  event  The event to add to the timeline\n\t */\n\tadd(event: IntervalTimelineEvent): this {\n\t\tassert(isDefined(event.time), \"Events must have a time property\");\n\t\tassert(isDefined(event.duration), \"Events must have a duration parameter\");\n\n\t\tevent.time = event.time.valueOf();\n\t\tlet node: IntervalNode | null = new IntervalNode(event.time, event.time + event.duration, event);\n\t\tif (this._root === null) {\n\t\t\tthis._root = node;\n\t\t} else {\n\t\t\tthis._root.insert(node);\n\t\t}\n\t\tthis._length++;\n\t\t// Restructure tree to be balanced\n\t\twhile (node !== null) {\n\t\t\tnode.updateHeight();\n\t\t\tnode.updateMax();\n\t\t\tthis._rebalance(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove an event from the timeline.\n\t * @param  event  The event to remove from the timeline\n\t */\n\tremove(event: IntervalTimelineEvent): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(event.time, results);\n\t\t\tfor (const node of results) {\n\t\t\t\tif (node.event === event) {\n\t\t\t\t\tthis._removeNode(node);\n\t\t\t\t\tthis._length--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The number of items in the timeline.\n\t * @readOnly\n\t */\n\tget length(): number {\n\t\treturn this._length;\n\t}\n\n\t/**\n\t * Remove events whose time time is after the given time\n\t * @param  after  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tthis.forEachFrom(after, event => this.remove(event));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the root node as the given node\n\t */\n\tprivate _setRoot(node: IntervalNode | null): void {\n\t\tthis._root = node;\n\t\tif (this._root !== null) {\n\t\t\tthis._root.parent = null;\n\t\t}\n\t}\n\n\t/**\n\t * Replace the references to the node in the node's parent\n\t * with the replacement node.\n\t */\n\tprivate _replaceNodeInParent(node: IntervalNode, replacement: IntervalNode | null): void {\n\t\tif (node.parent !== null) {\n\t\t\tif (node.isLeftChild()) {\n\t\t\t\tnode.parent.left = replacement;\n\t\t\t} else {\n\t\t\t\tnode.parent.right = replacement;\n\t\t\t}\n\t\t\tthis._rebalance(node.parent);\n\t\t} else {\n\t\t\tthis._setRoot(replacement);\n\t\t}\n\t}\n\n\t/**\n\t * Remove the node from the tree and replace it with\n\t * a successor which follows the schema.\n\t */\n\tprivate _removeNode(node: IntervalNode): void {\n\t\tif (node.left === null && node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, null);\n\t\t} else if (node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, node.left);\n\t\t} else if (node.left === null) {\n\t\t\tthis._replaceNodeInParent(node, node.right);\n\t\t} else {\n\t\t\tconst balance = node.getBalance();\n\t\t\tlet replacement: IntervalNode;\n\t\t\tlet temp: IntervalNode | null = null;\n\t\t\tif (balance > 0) {\n\t\t\t\tif (node.left.right === null) {\n\t\t\t\t\treplacement = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\ttemp = replacement;\n\t\t\t\t} else {\n\t\t\t\t\treplacement = node.left.right;\n\t\t\t\t\twhile (replacement.right !== null) {\n\t\t\t\t\t\treplacement = replacement.right;\n\t\t\t\t\t}\n\t\t\t\t\tif (replacement.parent) {\n\t\t\t\t\t\treplacement.parent.right = replacement.left;\n\t\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node.right.left === null) {\n\t\t\t\treplacement = node.right;\n\t\t\t\treplacement.left = node.left;\n\t\t\t\ttemp = replacement;\n\t\t\t} else {\n\t\t\t\treplacement = node.right.left;\n\t\t\t\twhile (replacement.left !== null) {\n\t\t\t\t\treplacement = replacement.left;\n\t\t\t\t}\n\t\t\t\tif (replacement.parent) {\n\t\t\t\t\treplacement.parent.left = replacement.right;\n\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.parent !== null) {\n\t\t\t\tif (node.isLeftChild()) {\n\t\t\t\t\tnode.parent.left = replacement;\n\t\t\t\t} else {\n\t\t\t\t\tnode.parent.right = replacement;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._setRoot(replacement);\n\t\t\t}\n\t\t\tif (temp) {\n\t\t\t\tthis._rebalance(temp);\n\t\t\t}\n\t\t}\n\t\tnode.dispose();\n\t}\n\n\t/**\n\t * Rotate the tree to the left\n\t */\n\tprivate _rotateLeft(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.right the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.right;\n\t\tif (pivotNode) {\n\t\t\tnode.right = pivotNode.left;\n\t\t\tpivotNode.left = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t * Rotate the tree to the right\n\t */\n\tprivate _rotateRight(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.left the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.left;\n\t\tif (pivotNode) {\n\t\t\tnode.left = pivotNode.right;\n\t\t\tpivotNode.right = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t * Balance the BST\n\t */\n\tprivate _rebalance(node: IntervalNode): void {\n\t\tconst balance = node.getBalance();\n\t\tif (balance > 1 && node.left) {\n\t\t\tif (node.left.getBalance() < 0) {\n\t\t\t\tthis._rotateLeft(node.left);\n\t\t\t} else {\n\t\t\t\tthis._rotateRight(node);\n\t\t\t}\n\t\t} else if (balance < -1 && node.right) {\n\t\t\tif (node.right.getBalance() > 0) {\n\t\t\t\tthis._rotateRight(node.right);\n\t\t\t} else {\n\t\t\t\tthis._rotateLeft(node);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get an event whose time and duration span the give time. Will\n\t * return the match whose \"time\" value is closest to the given time.\n\t * @return  The event which spans the desired time\n\t */\n\tget(time: number): IntervalTimelineEvent | null {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tif (results.length > 0) {\n\t\t\t\tlet max = results[0];\n\t\t\t\tfor (let i = 1; i < results.length; i++) {\n\t\t\t\t\tif (results[i].low > max.low) {\n\t\t\t\t\t\tmax = results[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max.event;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Iterate over everything in the timeline.\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst allNodes: IntervalNode[] = [];\n\t\t\tthis._root.traverse(node => allNodes.push(node));\n\t\t\tallNodes.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array in which the given time\n\t * overlaps with the time and duration time of the event.\n\t * @param  time The time to check if items are overlapping\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array in which the time is greater\n\t * than or equal to the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.searchAfter(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._root !== null) {\n\t\t\tthis._root.traverse(node => node.dispose());\n\t\t}\n\t\tthis._root = null;\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINTERVAL NODE HELPER\n//-------------------------------------\n\n/**\n * Represents a node in the binary search tree, with the addition\n * of a \"high\" value which keeps track of the highest value of\n * its children.\n * References:\n * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\nclass IntervalNode {\n\n\t// the event container\n\tevent: IntervalTimelineEvent | null;\n\t// the low value\n\tlow: number;\n\t// the high value\n\thigh: number;\n\t// the high value for this and all child nodes\n\tmax: number;\n\t// the nodes to the left\n\tprivate _left: IntervalNode | null = null;\n\t// the nodes to the right\n\tprivate _right: IntervalNode | null = null;\n\t// the parent node\n\tparent: IntervalNode | null = null;\n\t// the number of child nodes\n\theight = 0;\n\n\tconstructor(low: number, high: number, event: IntervalTimelineEvent) {\n\t\tthis.event = event;\n\t\t// the low value\n\t\tthis.low = low;\n\t\t// the high value\n\t\tthis.high = high;\n\t\t// the high value for this and all child nodes\n\t\tthis.max = this.high;\n\t}\n\n\t/**\n\t * Insert a node into the correct spot in the tree\n\t */\n\tinsert(node: IntervalNode): void {\n\t\tif (node.low <= this.low) {\n\t\t\tif (this.left === null) {\n\t\t\t\tthis.left = node;\n\t\t\t} else {\n\t\t\t\tthis.left.insert(node);\n\t\t\t}\n\t\t} else if (this.right === null) {\n\t\t\tthis.right = node;\n\t\t} else {\n\t\t\tthis.right.insert(node);\n\t\t}\n\t}\n\n\t/**\n\t * Search the tree for nodes which overlap\n\t * with the given point\n\t * @param  point  The point to query\n\t * @param  results  The array to put the results\n\t */\n\tsearch(point: number, results: IntervalNode[]): void {\n\t\t// If p is to the right of the rightmost point of any interval\n\t\t// in this node and all children, there won't be any matches.\n\t\tif (point > this.max) {\n\t\t\treturn;\n\t\t}\n\t\t// Search left children\n\t\tif (this.left !== null) {\n\t\t\tthis.left.search(point, results);\n\t\t}\n\t\t// Check this node\n\t\tif (this.low <= point && this.high > point) {\n\t\t\tresults.push(this);\n\t\t}\n\t\t// If p is to the left of the time of this interval,\n\t\t// then it can't be in any child to the right.\n\t\tif (this.low > point) {\n\t\t\treturn;\n\t\t}\n\t\t// Search right children\n\t\tif (this.right !== null) {\n\t\t\tthis.right.search(point, results);\n\t\t}\n\t}\n\n\t/**\n\t * Search the tree for nodes which are less\n\t * than the given point\n\t * @param  point  The point to query\n\t * @param  results  The array to put the results\n\t */\n\tsearchAfter(point: number, results: IntervalNode[]): void {\n\t\t// Check this node\n\t\tif (this.low >= point) {\n\t\t\tresults.push(this);\n\t\t\tif (this.left !== null) {\n\t\t\t\tthis.left.searchAfter(point, results);\n\t\t\t}\n\t\t}\n\t\t// search the right side\n\t\tif (this.right !== null) {\n\t\t\tthis.right.searchAfter(point, results);\n\t\t}\n\t}\n\n\t/**\n\t * Invoke the callback on this element and both it's branches\n\t * @param  {Function}  callback\n\t */\n\ttraverse(callback: (self: IntervalNode) => void): void {\n\t\tcallback(this);\n\t\tif (this.left !== null) {\n\t\t\tthis.left.traverse(callback);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.right.traverse(callback);\n\t\t}\n\t}\n\n\t/**\n\t * Update the height of the node\n\t */\n\tupdateHeight(): void {\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tthis.height = Math.max(this.left.height, this.right.height) + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tthis.height = this.right.height + 1;\n\t\t} else if (this.left !== null) {\n\t\t\tthis.height = this.left.height + 1;\n\t\t} else {\n\t\t\tthis.height = 0;\n\t\t}\n\t}\n\n\t/**\n\t * Update the height of the node\n\t */\n\tupdateMax(): void {\n\t\tthis.max = this.high;\n\t\tif (this.left !== null) {\n\t\t\tthis.max = Math.max(this.max, this.left.max);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.max = Math.max(this.max, this.right.max);\n\t\t}\n\t}\n\n\t/**\n\t * The balance is how the leafs are distributed on the node\n\t * @return  Negative numbers are balanced to the right\n\t */\n\tgetBalance(): number {\n\t\tlet balance = 0;\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tbalance = this.left.height - this.right.height;\n\t\t} else if (this.left !== null) {\n\t\t\tbalance = this.left.height + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tbalance = -(this.right.height + 1);\n\t\t}\n\t\treturn balance;\n\t}\n\n\t/**\n\t * @returns true if this node is the left child of its parent\n\t */\n\tisLeftChild(): boolean {\n\t\treturn this.parent !== null && this.parent.left === this;\n\t}\n\n\t/**\n\t * get/set the left node\n\t */\n\tget left(): IntervalNode | null {\n\t\treturn this._left;\n\t}\n\n\tset left(node: IntervalNode | null) {\n\t\tthis._left = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t * get/set the right node\n\t */\n\tget right(): IntervalNode | null {\n\t\treturn this._right;\n\t}\n\n\tset right(node: IntervalNode | null) {\n\t\tthis._right = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t * null out references.\n\t */\n\tdispose(): void {\n\t\tthis.parent = null;\n\t\tthis._left = null;\n\t\tthis._right = null;\n\t\tthis.event = null;\n\t}\n}\n","import { Seconds, Ticks } from \"../type/Units\";\nimport { noOp } from \"../util/Interface\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\nexport interface TransportEventOptions {\n\tcallback: (time: number) => void;\n\tonce: boolean;\n\ttime: Ticks;\n}\n\n/**\n * TransportEvent is an internal class used by [[Transport]]\n * to schedule events. Do no invoke this class directly, it is\n * handled from within Tone.Transport.\n */\nexport class TransportEvent {\n\n\t/**\n\t * Reference to the Transport that created it\n\t */\n\tprotected transport: Transport;\n\n\t/**\n\t * The unique id of the event\n\t */\n\tid: number = TransportEvent._eventId++;\n\n\t/**\n\t * The time the event starts\n\t */\n\ttime: Ticks;\n\n\t/**\n\t * The callback to invoke\n\t */\n\tprivate callback?: (time: Seconds) => void;\n\n\t/**\n\t * If the event should be removed after being invoked.\n\t */\n\tprivate _once: boolean;\n\n\t/**\n\t * @param transport The transport object which the event belongs to\n\t */\n\tconstructor(transport: Transport, opts: Partial<TransportEventOptions>) {\n\n\t\tconst options: TransportEventOptions = Object.assign(TransportEvent.getDefaults(), opts);\n\n\t\tthis.transport = transport;\n\t\tthis.callback = options.callback;\n\t\tthis._once = options.once;\n\t\tthis.time = options.time;\n\t}\n\n\tstatic getDefaults(): TransportEventOptions {\n\t\treturn {\n\t\t\tcallback: noOp,\n\t\t\tonce: false,\n\t\t\ttime: 0,\n\t\t};\n\t}\n\n\t/**\n\t * Current ID counter\n\t */\n\tprivate static _eventId = 0;\n\n\t/**\n\t * Invoke the event callback.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\tif (this.callback) {\n\t\t\tthis.callback(time);\n\t\t\tif (this._once) {\n\t\t\t\tthis.transport.clear(this.id);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tthis.callback = undefined;\n\t\treturn this;\n\t}\n}\n","import { BaseContext } from \"../context/BaseContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { Seconds, Ticks, Time } from \"../type/Units\";\nimport { TransportEvent, TransportEventOptions } from \"./TransportEvent\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\ninterface TransportRepeatEventOptions extends TransportEventOptions {\n\tinterval: Ticks;\n\tduration: Ticks;\n}\n\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\nexport class TransportRepeatEvent extends TransportEvent {\n\n\t/**\n\t * When the event should stop repeating\n\t */\n\tprivate duration: Ticks;\n\n\t/**\n\t * The interval of the repeated event\n\t */\n\tprivate _interval: Ticks;\n\n\t/**\n\t * The ID of the current timeline event\n\t */\n\tprivate _currentId = -1;\n\n\t/**\n\t * The ID of the next timeline event\n\t */\n\tprivate _nextId = -1;\n\n\t/**\n\t * The time of the next event\n\t */\n\tprivate _nextTick = this.time;\n\n\t/**\n\t * a reference to the bound start method\n\t */\n\tprivate _boundRestart = this._restart.bind(this);\n\n\t/**\n\t * The audio context belonging to this event\n\t */\n\tprotected context: BaseContext;\n\n\t/**\n\t * @param transport The transport object which the event belongs to\n\t */\n\tconstructor(transport: Transport, opts: Partial<TransportRepeatEventOptions>) {\n\n\t\tsuper(transport, opts);\n\n\t\tconst options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n\n\t\tthis.duration = new TicksClass(transport.context, options.duration).valueOf();\n\t\tthis._interval = new TicksClass(transport.context, options.interval).valueOf();\n\t\tthis._nextTick = options.time;\n\t\tthis.transport.on(\"start\", this._boundRestart);\n\t\tthis.transport.on(\"loopStart\", this._boundRestart);\n\t\tthis.context = this.transport.context;\n\t\tthis._restart();\n\t}\n\n\tstatic getDefaults(): TransportRepeatEventOptions {\n\t\treturn Object.assign({}, TransportEvent.getDefaults(), {\n\t\t\tduration: Infinity,\n\t\t\tinterval: 1,\n\t\t\tonce: false,\n\t\t});\n\t}\n\n\t/**\n\t * Invoke the callback. Returns the tick time which\n\t * the next event should be scheduled at.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\t// create more events if necessary\n\t\tthis._createEvents(time);\n\t\t// call the super class\n\t\tsuper.invoke(time);\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _createEvents(time: Seconds): void {\n\t\t// schedule the next event\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n\t\t\tthis._nextTick += this._interval;\n\t\t\tthis._currentId = this._nextId;\n\t\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\t}\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _restart(time?: Time): void {\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis._nextTick = this.time;\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks > this.time) {\n\t\t\tthis._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n\t\t}\n\t\tthis._currentId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\tthis._nextTick += this._interval;\n\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis.transport.off(\"start\", this._boundRestart);\n\t\tthis.transport.off(\"loopStart\", this._boundRestart);\n\t\treturn this;\n\t}\n}\n","import { TimeClass } from \"../../core/type/Time\";\nimport { PlaybackState } from \"../../core/util/StateTimeline\";\nimport { TimelineValue } from \"../../core/util/TimelineValue\";\nimport { Signal } from \"../../signal/Signal\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport {\n\tBarsBeatsSixteenths, BPM, NormalRange, Seconds,\n\tSubdivision, Ticks, Time, TimeSignature, TransportTime\n} from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TickParam } from \"./TickParam\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n\ninterface TransportOptions extends ToneWithContextOptions {\n\tbpm: BPM;\n\tswing: NormalRange;\n\tswingSubdivision: Subdivision;\n\ttimeSignature: number;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tppq: number;\n}\n\ntype TransportEventNames = \"start\" | \"stop\" | \"pause\" | \"loop\" | \"loopEnd\" | \"loopStart\";\n\ninterface SyncedSignalEvent {\n\tsignal: Signal;\n\tinitial: number;\n\tratio: Gain;\n}\n\ntype TransportCallback = (time: Seconds) => void;\n\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination();\n * // repeated event every 8th note\n * Tone.Transport.scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Tone.Transport.start();\n * @category Core\n */\nexport class Transport extends ToneWithContext<TransportOptions> implements Emitter<TransportEventNames> {\n\n\treadonly name: string = \"Transport\";\n\n\t//-------------------------------------\n\t// \tLOOPING\n\t//-------------------------------------\n\n\t/**\n\t * If the transport loops or not.\n\t */\n\tprivate _loop: TimelineValue<boolean> = new TimelineValue(false);\n\n\t/**\n\t * The loop start position in ticks\n\t */\n\tprivate _loopStart: Ticks = 0;\n\n\t/**\n\t * The loop end position in ticks\n\t */\n\tprivate _loopEnd: Ticks = 0;\n\n\t//-------------------------------------\n\t// \tCLOCK/TEMPO\n\t//-------------------------------------\n\n\t/**\n\t * Pulses per quarter is the number of ticks per quarter note.\n\t */\n\tprivate _ppq: number;\n\n\t/**\n\t * watches the main oscillator for timing ticks\n\t * initially starts at 120bpm\n\t */\n\tprivate _clock: Clock<\"bpm\">;\n\n\t/**\n\t * The Beats Per Minute of the Transport.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination();\n\t * Tone.Transport.bpm.value = 80;\n\t * // start/stop the oscillator every quarter note\n\t * Tone.Transport.scheduleRepeat(time => {\n\t * \tosc.start(time).stop(time + 0.1);\n\t * }, \"4n\");\n\t * Tone.Transport.start();\n\t * // ramp the bpm to 120 over 10 seconds\n\t * Tone.Transport.bpm.rampTo(120, 10);\n\t */\n\tbpm: TickParam<\"bpm\">;\n\n\t/**\n\t * The time signature, or more accurately the numerator\n\t * of the time signature over a denominator of 4.\n\t */\n\tprivate _timeSignature: number;\n\n\t//-------------------------------------\n\t// \tTIMELINE EVENTS\n\t//-------------------------------------\n\n\t/**\n\t * All the events in an object to keep track by ID\n\t */\n\tprivate _scheduledEvents = {};\n\n\t/**\n\t * The scheduled events.\n\t */\n\tprivate _timeline: Timeline<TransportEvent> = new Timeline();\n\n\t/**\n\t * Repeated events\n\t */\n\tprivate _repeatedEvents: IntervalTimeline = new IntervalTimeline();\n\n\t/**\n\t * All of the synced Signals\n\t */\n\tprivate _syncedSignals: SyncedSignalEvent[] = [];\n\n\t//-------------------------------------\n\t// \tSWING\n\t//-------------------------------------\n\n\t/**\n\t * The subdivision of the swing\n\t */\n\tprivate _swingTicks: Ticks;\n\n\t/**\n\t * The swing amount\n\t */\n\tprivate _swingAmount: NormalRange = 0;\n\n\tconstructor(options?: Partial<TransportOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Transport.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Transport.getDefaults(), arguments);\n\n\t\t// CLOCK/TEMPO\n\t\tthis._ppq = options.ppq;\n\t\tthis._clock = new Clock({\n\t\t\tcallback: this._processTick.bind(this),\n\t\t\tcontext: this.context,\n\t\t\tfrequency: 0,\n\t\t\tunits: \"bpm\",\n\t\t});\n\t\tthis._bindClockEvents();\n\t\tthis.bpm = this._clock.frequency as unknown as TickParam<\"bpm\">;\n\t\tthis._clock.frequency.multiplier = options.ppq;\n\t\tthis.bpm.setValueAtTime(options.bpm, 0);\n\t\treadOnly(this, \"bpm\");\n\t\tthis._timeSignature = options.timeSignature;\n\n\t\t// SWING\n\t\tthis._swingTicks = options.ppq / 2; // 8n\n\t}\n\n\tstatic getDefaults(): TransportOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tbpm: 120,\n\t\t\tloopEnd: \"4m\" as Subdivision,\n\t\t\tloopStart: 0,\n\t\t\tppq: 192,\n\t\t\tswing: 0,\n\t\t\tswingSubdivision: \"8n\" as Subdivision,\n\t\t\ttimeSignature: 4,\n\t\t});\n\t}\n\n\t//-------------------------------------\n\t// \tTICKS\n\t//-------------------------------------\n\n\t/**\n\t * called on every tick\n\t * @param  tickTime clock relative tick time\n\t */\n\tprivate _processTick(tickTime: Seconds, ticks: Ticks): void {\n\t\t// handle swing\n\t\tif (this._swingAmount > 0 &&\n\t\t\tticks % this._ppq !== 0 && // not on a downbeat\n\t\t\tticks % (this._swingTicks * 2) !== 0) {\n\t\t\t// add some swing\n\t\t\tconst progress = (ticks % (this._swingTicks * 2)) / (this._swingTicks * 2);\n\t\t\tconst amount = Math.sin((progress) * Math.PI) * this._swingAmount;\n\t\t\ttickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n\t\t}\n\t\t// do the loop test\n\t\tif (this._loop.get(tickTime)) {\n\t\t\tif (ticks >= this._loopEnd) {\n\t\t\t\tthis.emit(\"loopEnd\", tickTime);\n\t\t\t\tthis._clock.setTicksAtTime(this._loopStart, tickTime);\n\t\t\t\tticks = this._loopStart;\n\t\t\t\tthis.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n\t\t\t\tthis.emit(\"loop\", tickTime);\n\t\t\t}\n\t\t}\n\t\t// invoke the timeline events scheduled on this tick\n\t\tthis._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));\n\t}\n\n\t//-------------------------------------\n\t// \tSCHEDULABLE EVENTS\n\t//-------------------------------------\n\n\t/**\n\t * Schedule an event along the timeline.\n\t * @param callback The callback to be invoked at the time.\n\t * @param time The time to invoke the callback at.\n\t * @return The id of the event which can be used for canceling the event.\n\t * @example\n\t * // schedule an event on the 16th measure\n\t * Tone.Transport.schedule((time) => {\n\t * \t// invoked on measure 16\n\t * \tconsole.log(\"measure 16!\");\n\t * }, \"16:0:0\");\n\t */\n\tschedule(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\ttime: new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Schedule a repeated event along the timeline. The event will fire\n\t * at the `interval` starting at the `startTime` and for the specified\n\t * `duration`.\n\t * @param  callback   The callback to invoke.\n\t * @param  interval   The duration between successive callbacks. Must be a positive number.\n\t * @param  startTime  When along the timeline the events should start being invoked.\n\t * @param  duration How long the event should repeat.\n\t * @return  The ID of the scheduled event. Use this to cancel the event.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination().start();\n\t * // a callback invoked every eighth note after the first measure\n\t * Tone.Transport.scheduleRepeat((time) => {\n\t * \tosc.start(time).stop(time + 0.1);\n\t * }, \"8n\", \"1m\");\n\t */\n\tscheduleRepeat(\n\t\tcallback: TransportCallback,\n\t\tinterval: Time | TimeClass,\n\t\tstartTime?: TransportTime | TransportTimeClass,\n\t\tduration: Time = Infinity,\n\t): number {\n\t\tconst event = new TransportRepeatEvent(this, {\n\t\t\tcallback,\n\t\t\tduration: new TimeClass(this.context, duration).toTicks(),\n\t\t\tinterval: new TimeClass(this.context, interval).toTicks(),\n\t\t\ttime: new TransportTimeClass(this.context, startTime).toTicks(),\n\t\t});\n\t\t// kick it off if the Transport is started\n\t\t// @ts-ignore\n\t\treturn this._addEvent(event, this._repeatedEvents);\n\t}\n\n\t/**\n\t * Schedule an event that will be removed after it is invoked.\n\t * @param callback The callback to invoke once.\n\t * @param time The time the callback should be invoked.\n\t * @returns The ID of the scheduled event.\n\t */\n\tscheduleOnce(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\tonce: true,\n\t\t\ttime: new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Clear the passed in event id from the timeline\n\t * @param eventId The id of the event.\n\t */\n\tclear(eventId: number): this {\n\t\tif (this._scheduledEvents.hasOwnProperty(eventId)) {\n\t\t\tconst item = this._scheduledEvents[eventId.toString()];\n\t\t\titem.timeline.remove(item.event);\n\t\t\titem.event.dispose();\n\t\t\tdelete this._scheduledEvents[eventId.toString()];\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an event to the correct timeline. Keep track of the\n\t * timeline it was added to.\n\t * @returns the event id which was just added\n\t */\n\tprivate _addEvent(event: TransportEvent, timeline: Timeline<TransportEvent>): number {\n\t\tthis._scheduledEvents[event.id.toString()] = {\n\t\t\tevent,\n\t\t\ttimeline,\n\t\t};\n\t\ttimeline.add(event);\n\t\treturn event.id;\n\t}\n\n\t/**\n\t * Remove scheduled events from the timeline after\n\t * the given time. Repeated events will be removed\n\t * if their startTime is after the given time\n\t * @param after Clear all events after this time.\n\t */\n\tcancel(after: TransportTime = 0): this {\n\t\tconst computedAfter = this.toTicks(after);\n\t\tthis._timeline.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\tthis._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// \tSTART/STOP/PAUSE\n\t//-------------------------------------\n\n\t/**\n\t * Bind start/stop/pause events from the clock and emit them.\n\t */\n\tprivate _bindClockEvents(): void {\n\t\tthis._clock.on(\"start\", (time, offset) => {\n\t\t\toffset = new TicksClass(this.context, offset).toSeconds();\n\t\t\tthis.emit(\"start\", time, offset);\n\t\t});\n\n\t\tthis._clock.on(\"stop\", (time) => {\n\t\t\tthis.emit(\"stop\", time);\n\t\t});\n\n\t\tthis._clock.on(\"pause\", (time) => {\n\t\t\tthis.emit(\"pause\", time);\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._clock.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the transport and all sources synced to the transport.\n\t * @param  time The time when the transport should start.\n\t * @param  offset The timeline offset to start the transport.\n\t * @example\n\t * // start the transport in one second starting at beginning of the 5th measure.\n\t * Tone.Transport.start(\"+1\", \"4:0:0\");\n\t */\n\tstart(time?: Time, offset?: TransportTime): this {\n\t\tlet offsetTicks;\n\t\tif (isDefined(offset)) {\n\t\t\toffsetTicks = this.toTicks(offset);\n\t\t}\n\t\t// start the clock\n\t\tthis._clock.start(time, offsetTicks);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the transport and all sources synced to the transport.\n\t * @param time The time when the transport should stop.\n\t * @example\n\t * Tone.Transport.stop();\n\t */\n\tstop(time?: Time): this {\n\t\tthis._clock.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the transport and all sources synced to the transport.\n\t */\n\tpause(time?: Time): this {\n\t\tthis._clock.pause(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Toggle the current state of the transport. If it is\n\t * started, it will stop it, otherwise it will start the Transport.\n\t * @param  time The time of the event\n\t */\n\ttoggle(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tif (this._clock.getStateAtTime(time) !== \"started\") {\n\t\t\tthis.start(time);\n\t\t} else {\n\t\t\tthis.stop(time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// \tSETTERS/GETTERS\n\t//-------------------------------------\n\n\t/**\n\t * The time signature as just the numerator over 4.\n\t * For example 4/4 would be just 4 and 6/8 would be 3.\n\t * @example\n\t * // common time\n\t * Tone.Transport.timeSignature = 4;\n\t * // 7/8\n\t * Tone.Transport.timeSignature = [7, 8];\n\t * // this will be reduced to a single number\n\t * Tone.Transport.timeSignature; // returns 3.5\n\t */\n\tget timeSignature(): TimeSignature {\n\t\treturn this._timeSignature;\n\t}\n\tset timeSignature(timeSig: TimeSignature) {\n\t\tif (isArray(timeSig)) {\n\t\t\ttimeSig = (timeSig[0] / timeSig[1]) * 4;\n\t\t}\n\t\tthis._timeSignature = timeSig;\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the starting position of the loop.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n\t}\n\tset loopStart(startPosition: Time) {\n\t\tthis._loopStart = this.toTicks(startPosition);\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the ending position of the loop.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n\t}\n\tset loopEnd(endPosition: Time) {\n\t\tthis._loopEnd = this.toTicks(endPosition);\n\t}\n\n\t/**\n\t * If the transport loops or not.\n\t */\n\tget loop(): boolean {\n\t\treturn this._loop.get(this.now());\n\t}\n\tset loop(loop) {\n\t\tthis._loop.set(loop, this.now());\n\t}\n\n\t/**\n\t * Set the loop start and stop at the same time.\n\t * @example\n\t * // loop over the first measure\n\t * Tone.Transport.setLoopPoints(0, \"1m\");\n\t * Tone.Transport.loop = true;\n\t */\n\tsetLoopPoints(startPosition: TransportTime, endPosition: TransportTime): this {\n\t\tthis.loopStart = startPosition;\n\t\tthis.loopEnd = endPosition;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n\t */\n\tget swing(): NormalRange {\n\t\treturn this._swingAmount;\n\t}\n\tset swing(amount: NormalRange) {\n\t\t// scale the values to a normal range\n\t\tthis._swingAmount = amount;\n\t}\n\n\t/**\n\t * Set the subdivision which the swing will be applied to.\n\t * The default value is an 8th note. Value must be less\n\t * than a quarter note.\n\t */\n\tget swingSubdivision(): Subdivision {\n\t\treturn new TicksClass(this.context, this._swingTicks).toNotation();\n\t}\n\tset swingSubdivision(subdivision: Subdivision) {\n\t\tthis._swingTicks = this.toTicks(subdivision);\n\t}\n\n\t/**\n\t * The Transport's position in Bars:Beats:Sixteenths.\n\t * Setting the value will jump to that position right away.\n\t */\n\tget position(): BarsBeatsSixteenths | Time {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\treturn new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n\t}\n\tset position(progress: Time) {\n\t\tconst ticks = this.toTicks(progress);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t * The Transport's position in seconds\n\t * Setting the value will jump to that position right away.\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._clock.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.frequency.timeToTicks(s, now);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t * The Transport's loop position as a normalized value. Always\n\t * returns 0 if the transport if loop is not true.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this.loop) {\n\t\t\tconst now = this.now();\n\t\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\t\treturn (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The transports current tick position.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this._clock.ticks;\n\t}\n\tset ticks(t: Ticks) {\n\t\tif (this._clock.ticks !== t) {\n\t\t\tconst now = this.now();\n\t\t\t// stop everything synced to the transport\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\t\t\t// schedule to start on the next tick, #573\n\t\t\t\tconst time = this._clock.getTimeOfTick(Math.ceil(ticks));\n\t\t\t\tthis.emit(\"stop\", time);\n\t\t\t\tthis._clock.setTicksAtTime(t, time);\n\t\t\t\t// restart it with the new time\n\t\t\t\tthis.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n\t\t\t} else {\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn Math.round(this._clock.getTicksAtTime(time));\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._clock.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Pulses Per Quarter note. This is the smallest resolution\n\t * the Transport timing supports. This should be set once\n\t * on initialization and not set again. Changing this value\n\t * after other objects have been created can cause problems.\n\t */\n\tget PPQ(): number {\n\t\treturn this._clock.frequency.multiplier;\n\t}\n\tset PPQ(ppq: number) {\n\t\tthis._clock.frequency.multiplier = ppq;\n\t}\n\n\t//-------------------------------------\n\t// \tSYNCING\n\t//-------------------------------------\n\n\t/**\n\t * Returns the time aligned to the next subdivision\n\t * of the Transport. If the Transport is not started,\n\t * it will return 0.\n\t * Note: this will not work precisely during tempo ramps.\n\t * @param  subdivision  The subdivision to quantize to\n\t * @return  The context time of the next subdivision.\n\t * @example\n\t * // the transport must be started, otherwise returns 0\n\t * Tone.Transport.start(); \n\t * Tone.Transport.nextSubdivision(\"4n\");\n\t */\n\tnextSubdivision(subdivision?: Time): Seconds {\n\t\tsubdivision = this.toTicks(subdivision);\n\t\tif (this.state !== \"started\") {\n\t\t\t// if the transport's not started, return 0\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tconst now = this.now();\n\t\t\t// the remainder of the current ticks and the subdivision\n\t\t\tconst transportPos = this.getTicksAtTime(now);\n\t\t\tconst remainingTicks = subdivision - transportPos % subdivision;\n\t\t\treturn this._clock.nextTickTime(remainingTicks, now);\n\t\t}\n\t}\n\n\t/**\n\t * Attaches the signal to the tempo control signal so that\n\t * any changes in the tempo will change the signal in the same\n\t * ratio.\n\t *\n\t * @param signal\n\t * @param ratio Optionally pass in the ratio between the two signals.\n\t * \t\t\tOtherwise it will be computed based on their current values.\n\t */\n\tsyncSignal(signal: Signal<any>, ratio?: number): this {\n\t\tif (!ratio) {\n\t\t\t// get the sync ratio\n\t\t\tconst now = this.now();\n\t\t\tif (signal.getValueAtTime(now) !== 0) {\n\t\t\t\tconst bpm = this.bpm.getValueAtTime(now);\n\t\t\t\tconst computedFreq = 1 / (60 / bpm / this.PPQ);\n\t\t\t\tratio = signal.getValueAtTime(now) / computedFreq;\n\t\t\t} else {\n\t\t\t\tratio = 0;\n\t\t\t}\n\t\t}\n\t\tconst ratioSignal = new Gain(ratio);\n\t\t// @ts-ignore\n\t\tthis.bpm.connect(ratioSignal);\n\t\t// @ts-ignore\n\t\tratioSignal.connect(signal._param);\n\t\tthis._syncedSignals.push({\n\t\t\tinitial: signal.value,\n\t\t\tratio: ratioSignal,\n\t\t\tsignal,\n\t\t});\n\t\tsignal.value = 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsyncs a previously synced signal from the transport's control.\n\t * See Transport.syncSignal.\n\t */\n\tunsyncSignal(signal: Signal<any>): this {\n\t\tfor (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n\t\t\tconst syncedSignal = this._syncedSignals[i];\n\t\t\tif (syncedSignal.signal === signal) {\n\t\t\t\tsyncedSignal.ratio.dispose();\n\t\t\t\tsyncedSignal.signal.value = syncedSignal.initial;\n\t\t\t\tthis._syncedSignals.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._clock.dispose();\n\t\twritable(this, \"bpm\");\n\t\tthis._timeline.dispose();\n\t\tthis._repeatedEvents.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t//-------------------------------------\n\n\ton!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\tonce!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\toff!: (event: TransportEventNames, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Transport);\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n\tcontext.transport = new Transport({ context });\n});\n\nonContextClose(context => {\n\tcontext.transport.dispose();\n});\n","import { Param } from \"../context/Param\";\nimport { Seconds, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\nexport interface DelayOptions extends ToneAudioNodeOptions {\n\tdelayTime: Time;\n\tmaxDelay: Time;\n}\n\n/**\n * Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface).\n * @category Core\n * @example\n * return Tone.Offline(() => {\n * \tconst delay = new Tone.Delay(0.1).toDestination();\n * \t// connect the signal to both the delay and the destination\n * \tconst pulse = new Tone.PulseOscillator().connect(delay).toDestination();\n * \t// start and stop the pulse\n * \tpulse.start(0).stop(0.01);\n * }, 0.5, 1);\n */\nexport class Delay extends ToneAudioNode<DelayOptions> {\n\n\treadonly name: string = \"Delay\";\n\n\t/**\n\t * Private holder of the max delay time\n\t */\n\tprivate _maxDelay: Seconds;\n\n\t/**\n\t * The amount of time the incoming signal is delayed.\n\t * @example\n\t * const delay = new Tone.Delay().toDestination();\n\t * // modulate the delayTime between 0.1 and 1 seconds\n\t * const delayLFO = new Tone.LFO(0.5, 0.1, 1).start().connect(delay.delayTime);\n\t * const pulse = new Tone.PulseOscillator().connect(delay).start();\n\t * // the change in delayTime causes the pitch to go up and down\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\t/**\n\t * Private reference to the internal DelayNode\n\t */\n\tprivate _delayNode: DelayNode;\n\treadonly input: DelayNode;\n\treadonly output: DelayNode;\n\n\t/**\n\t * @param delayTime The delay applied to the incoming signal.\n\t * @param maxDelay The maximum delay time.\n\t */\n\tconstructor(delayTime?: Time, maxDelay?: Time);\n\tconstructor(options?: Partial<DelayOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]));\n\n\t\tconst options = optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]);\n\n\t\tconst maxDelayInSeconds = this.toSeconds(options.maxDelay);\n\t\tthis._maxDelay = Math.max(maxDelayInSeconds, this.toSeconds(options.delayTime));\n\n\t\tthis._delayNode = this.input = this.output = this.context.createDelay(maxDelayInSeconds);\n\n\t\tthis.delayTime = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._delayNode.delayTime,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.delayTime,\n\t\t\tminValue: 0,\n\t\t\tmaxValue: this.maxDelay,\n\t\t});\n\n\t\treadOnly(this, \"delayTime\");\n\t}\n\n\tstatic getDefaults(): DelayOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdelayTime: 0,\n\t\t\tmaxDelay: 1,\n\t\t});\n\t}\n\n\t/**\n\t * The maximum delay time. This cannot be changed after\n\t * the value is passed into the constructor.\n\t */\n\tget maxDelay(): Seconds {\n\t\treturn this._maxDelay;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.disconnect();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Decibels } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n\ninterface VolumeOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n * Volume is a simple volume node, useful for creating a volume fader.\n *\n * @example\n * const vol = new Tone.Volume(-12).toDestination();\n * const osc = new Tone.Oscillator().connect(vol).start();\n * @category Component\n */\nexport class Volume extends ToneAudioNode<VolumeOptions> {\n\n\treadonly name: string = \"Volume\";\n\n\t/**\n\t * the output node\n\t */\n\toutput: Gain<\"decibels\">;\n\n\t/**\n\t * Input and output are the same\n\t */\n\tinput: Gain<\"decibels\">;\n\n\t/**\n\t * The unmuted volume\n\t */\n\tprivate _unmutedVolume: Decibels;\n\n\t/**\n\t * The volume control in decibels.\n\t * @example\n\t * const vol = new Tone.Volume().toDestination();\n\t * const osc = new Tone.Oscillator().connect(vol).start();\n\t * vol.volume.value = -20;\n\t */\n\tvolume: Param<\"decibels\">;\n\n\t/**\n\t * @param volume the initial volume in decibels\n\t */\n\tconstructor(volume?: Decibels);\n\tconstructor(options?: Partial<VolumeOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]));\n\t\tconst options = optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]);\n\n\t\tthis.input = this.output = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.volume,\n\t\t\tunits: \"decibels\",\n\t\t});\n\t\tthis.volume = this.output.gain;\n\t\treadOnly(this, \"volume\");\n\t\tthis._unmutedVolume = options.volume;\n\n\t\t// set the mute initially\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): VolumeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * const vol = new Tone.Volume(-12).toDestination();\n\t * const osc = new Tone.Oscillator().connect(vol).start();\n\t * // mute the output\n\t * vol.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this.volume.value === -Infinity;\n\t}\n\tset mute(mute: boolean) {\n\t\tif (!this.mute && mute) {\n\t\t\tthis._unmutedVolume = this.volume.value;\n\t\t\t// maybe it should ramp here?\n\t\t\tthis.volume.value = -Infinity;\n\t\t} else if (this.mute && !mute) {\n\t\t\tthis.volume.value = this._unmutedVolume;\n\t\t}\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n","import { Volume } from \"../../component/channel/Volume\";\nimport { Decibels } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization\";\nimport { Gain } from \"./Gain\";\nimport { Param } from \"./Param\";\nimport { connectSeries, ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\ninterface DestinationOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n * A single master output which is connected to the\n * AudioDestinationNode (aka your speakers).\n * It provides useful conveniences such as the ability\n * to set the volume and mute the entire application.\n * It also gives you the ability to apply master effects to your application.\n *\n * @example\n * const oscillator = new Tone.Oscillator().start();\n * // the audio will go from the oscillator to the speakers\n * oscillator.connect(Tone.Destination);\n * // a convenience for connecting to the master output is also provided:\n * oscillator.toDestination();\n * @category Core\n */\nexport class Destination extends ToneAudioNode<DestinationOptions> {\n\n\treadonly name: string = \"Destination\";\n\n\tinput: Volume = new Volume({ context: this.context });\n\toutput: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * The volume of the master output.\n\t */\n\tvolume: Param<\"decibels\"> = this.input.volume;\n\n\tconstructor(options: Partial<DestinationOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Destination.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Destination.getDefaults(), arguments);\n\n\t\tconnectSeries(this.input, this.output, this.context.rawContext.destination);\n\n\t\tthis.mute = options.mute;\n\t\tthis._internalChannels = [this.input, this.context.rawContext.destination, this.output];\n\t}\n\n\tstatic getDefaults(): DestinationOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * const oscillator = new Tone.Oscillator().start().toDestination();\n\t * setTimeout(() => {\n\t * \t// mute the output\n\t * \tTone.Destination.mute = true;\n\t * }, 1000);\n\t */\n\tget mute(): boolean {\n\t\treturn this.input.mute;\n\t}\n\tset mute(mute: boolean) {\n\t\tthis.input.mute = mute;\n\t}\n\n\t/**\n\t * Add a master effects chain. NOTE: this will disconnect any nodes which were previously\n\t * chained in the master effects chain.\n\t * @param args All arguments will be connected in a row and the Master will be routed through it.\n\t * @example\n\t * // route all audio through a filter and compressor\n\t * const lowpass = new Tone.Filter(800, \"lowpass\");\n\t * const compressor = new Tone.Compressor(-18);\n\t * Tone.Destination.chain(lowpass, compressor);\n\t */\n\tchain(...args: Array<AudioNode | ToneAudioNode>): this {\n\t\tthis.input.disconnect();\n\t\targs.unshift(this.input);\n\t\targs.push(this.output);\n\t\tconnectSeries(...args);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The maximum number of channels the system can output\n\t * @example\n\t * console.log(Tone.Destination.maxChannelCount);\n\t */\n\tget maxChannelCount(): number {\n\t\treturn this.context.rawContext.destination.maxChannelCount;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n\tcontext.destination = new Destination({ context });\n});\n\nonContextClose(context => {\n\tcontext.destination.dispose();\n});\n","import { getContext, setContext } from \"../Global\";\nimport { Seconds } from \"../type/Units\";\nimport { OfflineContext } from \"./OfflineContext\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n\n/**\n * Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext.\n * The OfflineAudioContext is capable of rendering much faster than real time in many cases.\n * The callback function also passes in an offline instance of [[Context]] which can be used\n * to schedule events along the Transport. \n * @param  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.\n * @param  duration     the amount of time to record for.\n * @return  The promise which is invoked with the ToneAudioBuffer of the recorded output.\n * @example\n * // render 2 seconds of the oscillator\n * Tone.Offline(() => {\n * \t// only nodes created in this callback will be recorded\n * \tconst oscillator = new Tone.Oscillator().toDestination().start(0);\n * }, 2).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @example\n * // can also schedule events along the Transport\n * // using the passed in Offline Transport\n * Tone.Offline(({ transport }) => {\n * \tconst osc = new Tone.Oscillator().toDestination();\n * \ttransport.schedule(time => {\n * \t\tosc.start(time).stop(time + 0.1);\n * \t}, 1);\n * \t// make sure to start the transport\n * \ttransport.start(0.2);\n * }, 4).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @category Core\n */\nexport async function Offline(\n\tcallback: (context: OfflineContext) => Promise<void> | void,\n\tduration: Seconds,\n\tchannels = 2,\n\tsampleRate: number = getContext().sampleRate,\n): Promise<ToneAudioBuffer> {\n\t// set the OfflineAudioContext based on the current context\n\tconst originalContext = getContext();\n\n\tconst context = new OfflineContext(channels, duration, sampleRate);\n\tsetContext(context);\n\n\t// invoke the callback/scheduling\n\tawait callback(context);\n\n\t// then render the audio\n\tconst bufferPromise = context.render();\n\n\t// return the original AudioContext\n\tsetContext(originalContext);\n\n\t// await the rendering\n\tconst buffer = await bufferPromise;\n\n\t// return the audio\n\treturn new ToneAudioBuffer(buffer);\n}\n","import { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isString } from \"../util/TypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\nimport { assert } from \"../util/Debug\";\n\nexport interface ToneAudioBuffersUrlMap {\n\t[name: string]: string | AudioBuffer | ToneAudioBuffer;\n\t[name: number]: string | AudioBuffer | ToneAudioBuffer;\n}\n\ninterface ToneAudioBuffersOptions {\n\turls: ToneAudioBuffersUrlMap;\n\tonload: () => void;\n\tonerror?: (error: Error) => void;\n\tbaseUrl: string;\n}\n\n/**\n * A data structure for holding multiple buffers in a Map-like datastructure.\n *\n * @example\n * const pianoSamples = new Tone.ToneAudioBuffers({\n * \tA1: \"https://tonejs.github.io/audio/casio/A1.mp3\",\n * \tA2: \"https://tonejs.github.io/audio/casio/A2.mp3\",\n * }, () => {\n * \tconst player = new Tone.Player().toDestination();\n * \t// play one of the samples when they all load\n * \tplayer.buffer = pianoSamples.get(\"C2\");\n * \tplayer.start();\n * });\n * @example\n * // To pass in additional parameters in the second parameter\n * const buffers = new Tone.ToneAudioBuffers({\n * \t urls: {\n * \t\t A1: \"A1.mp3\",\n * \t\t A2: \"A2.mp3\",\n * \t },\n * \t onload: () => console.log(\"loaded\"),\n * \t baseUrl: \"https://tonejs.github.io/audio/casio/\"\n * });\n * @category Core\n */\nexport class ToneAudioBuffers extends Tone {\n\n\treadonly name: string = \"ToneAudioBuffers\";\n\n\t/**\n\t * All of the buffers\n\t */\n\tprivate _buffers: Map<string, ToneAudioBuffer> = new Map();\n\n\t/**\n\t * A path which is prefixed before every url.\n\t */\n\tbaseUrl: string;\n\n\t/**\n\t * Keep track of the number of loaded buffers\n\t */\n\tprivate _loadingCount = 0;\n\n\t/**\n\t * @param  urls  An object literal or array of urls to load.\n\t * @param onload  The callback to invoke when the buffers are loaded.\n\t * @param baseUrl A prefix url to add before all the urls\n\t */\n\tconstructor(\n\t\turls?: ToneAudioBuffersUrlMap,\n\t\tonload?: () => void,\n\t\tbaseUrl?: string,\n\t);\n\tconstructor(options?: Partial<ToneAudioBuffersOptions>);\n\tconstructor() {\n\n\t\tsuper();\n\t\tconst options = optionsFromArguments(\n\t\t\tToneAudioBuffers.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\",\n\t\t);\n\n\t\tthis.baseUrl = options.baseUrl;\n\t\t// add each one\n\t\tObject.keys(options.urls).forEach(name => {\n\t\t\tthis._loadingCount++;\n\t\t\tconst url = options.urls[name];\n\t\t\tthis.add(name, url, this._bufferLoaded.bind(this, options.onload), options.onerror);\n\t\t});\n\n\t}\n\n\tstatic getDefaults(): ToneAudioBuffersOptions {\n\t\treturn {\n\t\t\tbaseUrl: \"\",\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\turls: {},\n\t\t};\n\t}\n\n\t/**\n\t * True if the buffers object has a buffer by that name.\n\t * @param  name  The key or index of the buffer.\n\t */\n\thas(name: string | number): boolean {\n\t\treturn this._buffers.has(name.toString());\n\t}\n\n\t/**\n\t * Get a buffer by name. If an array was loaded,\n\t * then use the array index.\n\t * @param  name  The key or index of the buffer.\n\t */\n\tget(name: string | number): ToneAudioBuffer {\n\t\tassert(this.has(name), `ToneAudioBuffers has no buffer named: ${name}`);\n\t\treturn this._buffers.get(name.toString()) as ToneAudioBuffer;\n\t}\n\n\t/**\n\t * A buffer was loaded. decrement the counter.\n\t */\n\tprivate _bufferLoaded(callback: () => void): void {\n\t\tthis._loadingCount--;\n\t\tif (this._loadingCount === 0 && callback) {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t/**\n\t * If the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn Array.from(this._buffers).every(([_, buffer]) => buffer.loaded);\n\t}\n\n\t/**\n\t * Add a buffer by name and url to the Buffers\n\t * @param  name      A unique name to give the buffer\n\t * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.\n\t * @param  callback  The callback to invoke when the url is loaded.\n\t * @param  onerror  Invoked if the buffer can't be loaded\n\t */\n\tadd(\n\t\tname: string | number,\n\t\turl: string | AudioBuffer | ToneAudioBuffer,\n\t\tcallback: () => void = noOp,\n\t\tonerror: (e: Error) => void = noOp,\n\t): this {\n\t\tif (isString(url)) {\n\t\t\tthis._buffers.set(name.toString(), new ToneAudioBuffer(this.baseUrl + url, callback, onerror));\n\t\t} else {\n\t\t\tthis._buffers.set(name.toString(), new ToneAudioBuffer(url, callback, onerror));\n\t\t}\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffers.forEach(buffer => buffer.dispose());\n\t\tthis._buffers.clear();\n\t\treturn this;\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { ftom, mtof } from \"./Conversions\";\nimport { FrequencyClass, FrequencyUnit } from \"./Frequency\";\nimport { TimeValue } from \"./TimeBase\";\nimport { Hertz, Interval, MidiNote, Seconds, Ticks } from \"./Units\";\n\n/**\n * Midi is a primitive type for encoding Time values.\n * Midi can be constructed with or without the `new` keyword. Midi can be passed\n * into the parameter of any method which takes time as an argument.\n * @category Unit\n */\nexport class MidiClass extends FrequencyClass<MidiNote> {\n\n\treadonly name: string = \"MidiClass\";\n\n\treadonly defaultUnits = \"midi\";\n\n\t/**\n\t * Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): MidiNote {\n\t\treturn ftom(super._frequencyToUnits(freq));\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): MidiNote {\n\t\treturn ftom(super._ticksToUnits(ticks));\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): MidiNote {\n\t\treturn ftom(super._beatsToUnits(beats));\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): MidiNote {\n\t\treturn ftom(super._secondsToUnits(seconds));\n\t}\n\n\t/**\n\t * Return the value of the frequency as a MIDI note\n\t * @example\n\t * Tone.Midi(60).toMidi(); // 60\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t * Return the value of the frequency as a MIDI note\n\t * @example\n\t * Tone.Midi(60).toFrequency(); // 261.6255653005986\n\t */\n\ttoFrequency(): Hertz {\n\t\treturn mtof(this.toMidi());\n\t}\n\n\t/**\n\t * Transposes the frequency by the given number of semitones.\n\t * @return A new transposed MidiClass\n\t * @example\n\t * Tone.Midi(\"A4\").transpose(3); // \"C5\"\n\t */\n\ttranspose(interval: Interval): MidiClass {\n\t\treturn new MidiClass(this.context, this.toMidi() + interval);\n\t}\n}\n\n/**\n * Convert a value into a FrequencyClass object.\n * @category Unit\n */\nexport function Midi(value?: TimeValue, units?: FrequencyUnit): MidiClass {\n\treturn new MidiClass(getContext(), value, units);\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Seconds, Time } from \"../type/Units\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\n\ninterface DrawEvent extends TimelineEvent {\n\tcallback: () => void;\n}\n\n/**\n * Draw is useful for synchronizing visuals and audio events.\n * Callbacks from Tone.Transport or any of the Tone.Event classes\n * always happen _before_ the scheduled time and are not synchronized\n * to the animation frame so they are not good for triggering tightly\n * synchronized visuals and sound. Draw makes it easy to schedule\n * callbacks using the AudioContext time and uses requestAnimationFrame.\n * @example\n * Tone.Transport.schedule((time) => {\n * \t// use the time argument to schedule a callback with Draw\n * \tTone.Draw.schedule(() => {\n * \t\t// do drawing or DOM manipulation here\n * \t\tconsole.log(time);\n * \t}, time);\n * }, \"+0.5\");\n * Tone.Transport.start();\n * @category Core\n */\nexport class Draw extends ToneWithContext<ToneWithContextOptions> {\n\n\treadonly name: string = \"Draw\";\n\n\t/**\n\t * The duration after which events are not invoked.\n\t */\n\texpiration: Seconds = 0.25;\n\n\t/**\n\t * The amount of time before the scheduled time\n\t * that the callback can be invoked. Default is\n\t * half the time of an animation frame (0.008 seconds).\n\t */\n\tanticipation: Seconds = 0.008;\n\n\t/**\n\t * All of the events.\n\t */\n\tprivate _events: Timeline<DrawEvent> = new Timeline();\n\n\t/**\n\t * The draw loop\n\t */\n\tprivate _boundDrawLoop = this._drawLoop.bind(this);\n\n\t/**\n\t * The animation frame id\n\t */\n\tprivate _animationFrame = -1;\n\n\t/**\n\t * Schedule a function at the given time to be invoked\n\t * on the nearest animation frame.\n\t * @param  callback  Callback is invoked at the given time.\n\t * @param  time      The time relative to the AudioContext time to invoke the callback.\n\t * @example\n\t * Tone.Transport.scheduleRepeat(time => {\n\t * \tTone.Draw.schedule(() => console.log(time), time);\n\t * }, 1);\n\t * Tone.Transport.start();\n\t */\n\tschedule(callback: () => void, time: Time): this {\n\t\tthis._events.add({\n\t\t\tcallback,\n\t\t\ttime: this.toSeconds(time),\n\t\t});\n\t\t// start the draw loop on the first event\n\t\tif (this._events.length === 1) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel events scheduled after the given time\n\t * @param  after  Time after which scheduled events will be removed from the scheduling timeline.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._events.cancel(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * The draw loop\n\t */\n\tprivate _drawLoop(): void {\n\t\tconst now = this.context.currentTime;\n\t\twhile (this._events.length && (this._events.peek() as DrawEvent).time - this.anticipation <= now) {\n\t\t\tconst event = this._events.shift();\n\t\t\tif (event && now - event.time <= this.expiration) {\n\t\t\t\tevent.callback();\n\t\t\t}\n\t\t}\n\t\tif (this._events.length > 0) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\tcancelAnimationFrame(this._animationFrame);\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n\tcontext.draw = new Draw({ context });\n});\n\nonContextClose(context => {\n\tcontext.draw.dispose();\n});\n","import { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { Param } from \"../core/context/Param\";\nimport { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels, Seconds, Time } from \"../core/type/Units\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { BasicPlaybackState, StateTimeline, StateTimelineEvent } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n\ntype onStopCallback = (source: Source<any>) => void;\n\nexport interface SourceOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n\tonstop: onStopCallback;\n}\n\n/**\n * Base class for sources. \n * start/stop of this.context.transport.\n * \n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\nexport abstract class Source<Options extends SourceOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t * The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The output note\n\t */\n\toutput: OutputNode;\n\n\t/**\n\t * Sources have no inputs\n\t */\n\tinput = undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * const source = new Tone.PWMOscillator().toDestination();\n\t * source.volume.value = -6;\n\t */\n\tvolume: Param<\"decibels\">;\n\n\t/**\n\t * The callback to invoke when the source is stopped.\n\t */\n\tonstop: onStopCallback;\n\n\t/**\n\t * Keep track of the scheduled state.\n\t */\n\tprotected _state: StateTimeline<{\n\t\tduration?: Seconds;\n\t\toffset?: Seconds;\n\t\t/**\n\t\t * Either the buffer is explicitly scheduled to end using the stop method,\n\t\t * or it's implicitly ended when the buffer is over.\n\t\t */\n\t\timplicitEnd?: boolean;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The synced `start` callback function from the transport\n\t */\n\tprotected _synced = false;\n\n\t/**\n\t * Keep track of all of the scheduled event ids\n\t */\n\tprivate _scheduled: number[] = [];\n\n\t/**\n\t * Placeholder functions for syncing/unsyncing to transport\n\t */\n\tprivate _syncedStart: (time: Seconds, offset: Seconds) => void = noOp;\n\tprivate _syncedStop: (time: Seconds) => void = noOp;\n\n\tconstructor(options: SourceOptions) {\n\t\tsuper(options);\n\t\tthis._state.memory = 100;\n\t\tthis._state.increasing = true;\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tmute: options.mute,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis.onstop = options.onstop;\n\t}\n\n\tstatic getDefaults(): SourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tonstop: noOp,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\" or \"stopped\".\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/ahntone_c3.mp3\", () => {\n\t * \tplayer.start();\n\t * \tconsole.log(player.state);\n\t * }).toDestination();\n\t */\n\tget state(): BasicPlaybackState {\n\t\tif (this._synced) {\n\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\treturn this._state.getValueAtTime(this.context.transport.seconds) as BasicPlaybackState;\n\t\t\t} else {\n\t\t\t\treturn \"stopped\";\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._state.getValueAtTime(this.now()) as BasicPlaybackState;\n\t\t}\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination().start();\n\t * // mute the output\n\t * osc.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute: boolean) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\t// overwrite these functions\n\tprotected abstract _start(time: Time, offset?: Time, duration?: Time): void;\n\tprotected abstract _stop(time: Time): void;\n\tprotected abstract _restart(time: Seconds, offset?: Time, duration?: Time): void;\n\n\t/**\n\t * Ensure that the scheduled time is not before the current time.\n\t * Should only be used when scheduled unsynced.\n\t */\n\tprivate _clampToCurrentTime(time: Seconds): Seconds {\n\t\tif (this._synced) {\n\t\t\treturn time;\n\t\t} else {\n\t\t\treturn Math.max(time, this.context.currentTime);\n\t\t}\n\t}\n\n\t/**\n\t * Start the source at the specified time. If no time is given,\n\t * start the source now.\n\t * @param  time When the source should be started.\n\t * @example\n\t * const source = new Tone.Oscillator().toDestination();\n\t * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tlet computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\t// if it's started, stop it and restart it\n\t\tif (!this._synced && this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\t// time should be strictly greater than the previous start time\n\t\t\tassert(GT(computedTime, (this._state.get(computedTime) as StateTimelineEvent).time), \"Start time must be strictly greater than previous start time\");\n\t\t\tthis._state.cancel(computedTime);\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis.log(\"restart\", computedTime);\n\t\t\tthis.restart(computedTime, offset, duration);\n\t\t} else {\n\t\t\tthis.log(\"start\", computedTime);\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (this._synced) {\n\t\t\t\t// add the offset time to the event\n\t\t\t\tconst event = this._state.get(computedTime);\n\t\t\t\tif (event) {\n\t\t\t\t\tevent.offset = this.toSeconds(defaultArg(offset, 0));\n\t\t\t\t\tevent.duration = duration ? this.toSeconds(duration) : undefined;\n\t\t\t\t}\n\t\t\t\tconst sched = this.context.transport.schedule(t => {\n\t\t\t\t\tthis._start(t, offset, duration);\n\t\t\t\t}, computedTime);\n\t\t\t\tthis._scheduled.push(sched);\n\n\t\t\t\t// if the transport is already started\n\t\t\t\t// and the time is greater than where the transport is\n\t\t\t\tif (this.context.transport.state === \"started\" && \n\t\t\t\t\tthis.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {\n\t\t\t\t\tthis._syncedStart(this.now(), this.context.transport.seconds);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassertContextRunning(this.context);\n\t\t\t\tthis._start(computedTime, offset, duration);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source at the specified time. If no time is given,\n\t * stop the source now.\n\t * @param  time When the source should be stopped.\n\t * @example\n\t * const source = new Tone.Oscillator().toDestination();\n\t * source.start();\n\t * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n\t */\n\tstop(time?: Time): this {\n\t\tlet computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n\t\t\tthis.log(\"stop\", computedTime);\n\t\t\tif (!this._synced) {\n\t\t\t\tthis._stop(computedTime);\n\t\t\t} else {\n\t\t\t\tconst sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n\t\t\t\tthis._scheduled.push(sched);\n\t\t\t}\n\t\t\tthis._state.cancel(computedTime);\n\t\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Restart the source.\n\t */\n\trestart(time?: Time, offset?: Time, duration?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(time) === \"started\") {\n\t\t\tthis._state.cancel(time);\n\t\t\tthis._restart(time, offset, duration);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the source to the Transport so that all subsequent\n\t * calls to `start` and `stop` are synced to the TransportTime\n\t * instead of the AudioContext time.\n\t *\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination();\n\t * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n\t * osc.sync().start(0).stop(0.3);\n\t * // start the transport.\n\t * Tone.Transport.start();\n\t * // set it to loop once a second\n\t * Tone.Transport.loop = true;\n\t * Tone.Transport.loopEnd = 1;\n\t */\n\tsync(): this {\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tthis._syncedStart = (time, offset) => {\n\t\t\t\tif (offset > 0) {\n\t\t\t\t\t// get the playback state at that time\n\t\t\t\t\tconst stateEvent = this._state.get(offset);\n\t\t\t\t\t// listen for start events which may occur in the middle of the sync'ed time\n\t\t\t\t\tif (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n\t\t\t\t\t\t// get the offset\n\t\t\t\t\t\tconst startOffset = offset - this.toSeconds(stateEvent.time);\n\t\t\t\t\t\tlet duration: number | undefined;\n\t\t\t\t\t\tif (stateEvent.duration) {\n\t\t\t\t\t\t\tduration = this.toSeconds(stateEvent.duration) - startOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._syncedStop = time => {\n\t\t\t\tconst seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n\t\t\t\tif (this._state.getValueAtTime(seconds) === \"started\") {\n\t\t\t\t\tthis._stop(time);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.context.transport.on(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"loopStart\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"loopEnd\", this._syncedStop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the source to the Transport. See Source.sync\n\t */\n\tunsync(): this {\n\t\tif (this._synced) {\n\t\t\tthis.context.transport.off(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"loopEnd\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.off(\"loopStart\", this._syncedStart);\n\t\t}\n\t\tthis._synced = false;\n\t\t// clear all of the scheduled ids\n\t\tthis._scheduled.forEach(id => this.context.transport.clear(id));\n\t\tthis._scheduled = [];\n\t\tthis._state.cancel(0);\n\t\t// stop it also\n\t\tthis._stop(0);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.onstop = noOp;\n\t\tthis.unsync();\n\t\tthis._volume.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n","import { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { GainFactor, Positive, Seconds, Time } from \"../../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { assert } from \"../../core/util/Debug\";\nimport { OneShotSource, OneShotSourceCurve, OneShotSourceOptions } from \"../OneShotSource\";\nimport { EQ, GTE, LT } from \"../../core/util/Math\";\n\nexport type ToneBufferSourceCurve = OneShotSourceCurve;\n\nexport interface ToneBufferSourceOptions extends OneShotSourceOptions {\n\turl: string | AudioBuffer | ToneAudioBuffer;\n\tcurve: ToneBufferSourceCurve;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tloop: boolean;\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\nexport class ToneBufferSource extends OneShotSource<ToneBufferSourceOptions> {\n\n\treadonly name: string = \"ToneBufferSource\";\n\n\t/**\n\t * The oscillator\n\t */\n\tprivate _source = this.context.createBufferSource();\n\tprotected _internalChannels = [this._source];\n\n\t/**\n\t * The frequency of the oscillator\n\t */\n\treadonly playbackRate: Param<\"positive\">;\n\n\t/**\n\t * The private instance of the buffer object\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * indicators if the source has started/stopped\n\t */\n\tprivate _sourceStarted = false;\n\tprivate _sourceStopped = false;\n\n\t/**\n\t * @param url The buffer to play or url to load\n\t * @param onload The callback to invoke when the buffer is done playing.\n\t */\n\tconstructor(url?: ToneAudioBuffer | AudioBuffer | string, onload?: () => void);\n\tconstructor(options?: Partial<ToneBufferSourceOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tconnect(this._source, this._gainNode);\n\t\tthis._source.onended = () => this._stopSource();\n\n\t\t/**\n\t\t * The playbackRate of the buffer\n\t\t */\n\t\tthis.playbackRate = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._source.playbackRate,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.playbackRate,\n\t\t});\n\n\t\t// set some values initially\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis._buffer = new ToneAudioBuffer(options.url, options.onload, options.onerror);\n\n\t\tthis._internalChannels.push(this._source);\n\t}\n\n\tstatic getDefaults(): ToneBufferSourceOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\turl: new ToneAudioBuffer(),\n\t\t\tloop: false,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\tplaybackRate: 1,\n\t\t});\n\t}\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(t: Time) {\n\t\tthis._fadeIn = t;\n\t}\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(t: Time) {\n\t\tthis._fadeOut = t;\n\t}\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tget curve(): ToneBufferSourceCurve {\n\t\treturn this._curve;\n\t}\n\tset curve(t) {\n\t\tthis._curve = t;\n\t}\n\n\t/**\n\t * Start the buffer\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n\t * @param  gain  The gain to play the buffer back at.\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time, gain: GainFactor = 1): this {\n\t\tassert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n\t\tconst computedTime = this.toSeconds(time);\n\n\t\t// apply the gain envelope\n\t\tthis._startGain(computedTime, gain);\n\n\t\t// if it's a loop the default offset is the loopstart point\n\t\tif (this.loop) {\n\t\t\toffset = defaultArg(offset, this.loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\t\t// make sure the offset is not less than 0\n\t\tlet computedOffset = Math.max(this.toSeconds(offset), 0);\n\n\t\t// start the buffer source\n\t\tif (this.loop) {\n\t\t\t// modify the offset if it's greater than the loop time\n\t\t\tconst loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\t\tconst loopStart = this.toSeconds(this.loopStart);\n\t\t\tconst loopDuration = loopEnd - loopStart;\n\t\t\t// move the offset back\n\t\t\tif (GTE(computedOffset, loopEnd)) {\n\t\t\t\tcomputedOffset = ((computedOffset - loopStart) % loopDuration) + loopStart;\n\t\t\t}\n\t\t\t// when the offset is very close to the duration, set it to 0\n\t\t\tif (EQ(computedOffset, this.buffer.duration)) {\n\t\t\t\tcomputedOffset = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// this.buffer.loaded would have return false if the AudioBuffer was undefined\n\t\tthis._source.buffer = this.buffer.get() as AudioBuffer;\n\t\tthis._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\tif (LT(computedOffset, this.buffer.duration)) {\n\t\t\tthis._sourceStarted = true;\n\t\t\tthis._source.start(computedTime, computedOffset);\n\t\t}\n\n\t\t// if a duration is given, schedule a stop\n\t\tif (isDefined(duration)) {\n\t\t\tlet computedDur = this.toSeconds(duration);\n\t\t\t// make sure it's never negative\n\t\t\tcomputedDur = Math.max(computedDur, 0);\n\t\t\tthis.stop(computedTime + computedDur);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tif (!this._sourceStopped && this._sourceStarted) {\n\t\t\tthis._sourceStopped = true;\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._onended();\n\t\t}\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._source.loopStart;\n\t}\n\tset loopStart(loopStart: Time) {\n\t\tthis._source.loopStart = this.toSeconds(loopStart);\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._source.loopEnd;\n\t}\n\tset loopEnd(loopEnd: Time) {\n\t\tthis._source.loopEnd = this.toSeconds(loopEnd);\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer: ToneAudioBuffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t */\n\tget loop(): boolean {\n\t\treturn this._source.loop;\n\t}\n\tset loop(loop: boolean) {\n\t\tthis._source.loop = loop;\n\t\tif (this._sourceStarted) {\n\t\t\tthis.cancelStop();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._source.onended = null;\n\t\tthis._source.disconnect();\n\t\tthis._buffer.dispose();\n\t\tthis.playbackRate.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { Positive, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { Source, SourceOptions } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/ToneBufferSource\";\n\nexport type NoiseType = \"white\" | \"brown\" | \"pink\";\n\nexport interface NoiseOptions extends SourceOptions {\n\ttype: NoiseType;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n}\n\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @example\n * // initialize the noise and start\n * const noise = new Tone.Noise(\"pink\").start();\n * // make an autofilter to shape the noise\n * const autoFilter = new Tone.AutoFilter({\n * \tfrequency: \"8n\",\n * \tbaseFrequency: 200,\n * \toctaves: 8\n * }).toDestination().start();\n * // connect the noise\n * noise.connect(autoFilter);\n * // start the autofilter LFO\n * autoFilter.start();\n * @category Source\n */\nexport class Noise extends Source<NoiseOptions> {\n\n\treadonly name: string = \"Noise\";\n\n\t/**\n\t * Private reference to the source\n\t */\n\tprivate _source: ToneBufferSource | null = null;\n\n\t/**\n\t * private reference to the type\n\t */\n\tprivate _type!: NoiseType;\n\n\t/**\n\t * The playback rate of the noise. Affects\n\t * the \"frequency\" of the noise.\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tprotected _fadeIn: Time;\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tprotected _fadeOut: Time;\n\n\t/**\n\t * @param type the noise type (white|pink|brown)\n\t */\n\tconstructor(type?: NoiseType);\n\tconstructor(options?: Partial<NoiseOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]));\n\t\tconst options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.type = options.type;\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): NoiseOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tplaybackRate: 1,\n\t\t\ttype: \"white\" as NoiseType,\n\t\t});\n\t}\n\n\t/**\n\t * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n\t * @example\n\t * const noise = new Tone.Noise().toDestination().start();\n\t * noise.type = \"brown\";\n\t */\n\tget type(): NoiseType {\n\t\treturn this._type;\n\t}\n\tset type(type: NoiseType) {\n\t\tassert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n\t\tif (this._type !== type) {\n\t\t\tthis._type = type;\n\t\t\t// if it's playing, stop and restart it\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tconst now = this.now();\n\t\t\t\tthis._stop(now);\n\t\t\t\tthis._start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The playback rate of the noise. Affects\n\t * the \"frequency\" of the noise.\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate: Positive) {\n\t\tthis._playbackRate = rate;\n\t\tif (this._source) {\n\t\t\tthis._source.playbackRate.value = rate;\n\t\t}\n\t}\n\n\t/**\n\t * internal start method\n\t */\n\tprotected _start(time?: Time): void {\n\t\tconst buffer = _noiseBuffers[this._type];\n\t\tthis._source = new ToneBufferSource({\n\t\t\turl: buffer,\n\t\t\tcontext: this.context,\n\t\t\tfadeIn: this._fadeIn,\n\t\t\tfadeOut: this._fadeOut,\n\t\t\tloop: true,\n\t\t\tonended: () => this.onstop(this),\n\t\t\tplaybackRate: this._playbackRate,\n\t\t}).connect(this.output);\n\t\tthis._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n\t}\n\n\t/**\n\t * internal stop method\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tif (this._source) {\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._source = null;\n\t\t}\n\t}\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(time) {\n\t\tthis._fadeIn = time;\n\t\tif (this._source) {\n\t\t\tthis._source.fadeIn = this._fadeIn;\n\t\t}\n\t}\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(time) {\n\t\tthis._fadeOut = time;\n\t\tif (this._source) {\n\t\t\tthis._source.fadeOut = this._fadeOut;\n\t\t}\n\t}\n\n\tprotected _restart(time?: Time): void {\n\t\t// TODO could be optimized by cancelling the buffer source 'stop'\n\t\tthis._stop(time);\n\t\tthis._start(time);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._source) {\n\t\t\tthis._source.disconnect();\n\t\t}\n\t\treturn this;\n\t}\n}\n\n//--------------------\n// THE NOISE BUFFERS\n//--------------------\n\n// Noise buffer stats\nconst BUFFER_LENGTH = 44100 * 5;\nconst NUM_CHANNELS = 2;\n\n/**\n * The cached noise buffers\n */\ninterface NoiseCache {\n\t[key: string]: ToneAudioBuffer | null;\n}\n\n/**\n * Cache the noise buffers\n */\nconst _noiseCache: NoiseCache = {\n\tbrown: null,\n\tpink: null,\n\twhite: null,\n};\n\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\nconst _noiseBuffers = {\n\tget brown(): ToneAudioBuffer {\n\t\tif (!_noiseCache.brown) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tlet lastOut = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tchannel[i] = (lastOut + (0.02 * white)) / 1.02;\n\t\t\t\t\tlastOut = channel[i];\n\t\t\t\t\tchannel[i] *= 3.5; // (roughly) compensate for gain\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.brown;\n\t},\n\n\tget pink(): ToneAudioBuffer {\n\t\tif (!_noiseCache.pink) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tlet b0, b1, b2, b3, b4, b5, b6;\n\t\t\t\tb0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tb0 = 0.99886 * b0 + white * 0.0555179;\n\t\t\t\t\tb1 = 0.99332 * b1 + white * 0.0750759;\n\t\t\t\t\tb2 = 0.96900 * b2 + white * 0.1538520;\n\t\t\t\t\tb3 = 0.86650 * b3 + white * 0.3104856;\n\t\t\t\t\tb4 = 0.55000 * b4 + white * 0.5329522;\n\t\t\t\t\tb5 = -0.7616 * b5 - white * 0.0168980;\n\t\t\t\t\tchannel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n\t\t\t\t\tchannel[i] *= 0.11; // (roughly) compensate for gain\n\t\t\t\t\tb6 = white * 0.115926;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.pink;\n\t},\n\n\tget white(): ToneAudioBuffer {\n\t\tif (!_noiseCache.white) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tchannel[i] = Math.random() * 2 - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.white;\n\t},\n};\n","import { connect, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels } from \"../core/type/Units\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { Param } from \"../core/context/Param\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck\";\n\nexport interface UserMediaOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input. \n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia().connect(meter);\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * \tconsole.log(\"mic open\");\n * \t// print the incoming mic levels in decibels\n * \tsetInterval(() => console.log(meter.getValue()), 100);\n * }).catch(e => {\n * \t// promise is rejected when the user doesn't have or allow mic access\n * \tconsole.log(\"mic not open\");\n * });\n * @category Source\n */\n\nexport class UserMedia extends ToneAudioNode<UserMediaOptions> {\n\n\treadonly name: string = \"UserMedia\";\n\n\treadonly input: undefined;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The MediaStreamNode\n\t */\n\tprivate _mediaStream?: MediaStreamAudioSourceNode;\n\n\t/**\n\t * The media stream created by getUserMedia.\n\t */\n\tprivate _stream?: MediaStream;\n\n\t/**\n\t * The open device\n\t */\n\tprivate _device?: MediaDeviceInfo;\n\n\t/**\n\t * The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The volume of the output in decibels.\n\t */\n\treadonly volume: Param<\"decibels\">;\n\n\t/**\n\t * @param volume The level of the input in decibels\n\t */\n\tconstructor(volume?: Decibels);\n\tconstructor(options?: Partial<UserMediaOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]));\n\t\tconst options = optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]);\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): UserMediaOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0\n\t\t});\n\t}\n\n\t/**\n\t * Open the media stream. If a string is passed in, it is assumed\n\t * to be the label or id of the stream, if a number is passed in,\n\t * it is the input number of the stream.\n\t * @param  labelOrId The label or id of the audio input media device.\n\t *                   With no argument, the default stream is opened.\n\t * @return The promise is resolved when the stream is open.\n\t */\n\tasync open(labelOrId?: string | number): Promise<this> {\n\t\tassert(UserMedia.supported, \"UserMedia is not supported\");\n\t\t// close the previous stream\n\t\tif (this.state === \"started\") {\n\t\t\tthis.close();\n\t\t}\n\t\tconst devices = await UserMedia.enumerateDevices();\n\t\tif (isNumber(labelOrId)) {\n\t\t\tthis._device = devices[labelOrId];\n\t\t} else {\n\t\t\tthis._device = devices.find((device) => {\n\t\t\t\treturn device.label === labelOrId || device.deviceId === labelOrId;\n\t\t\t});\n\t\t\t// didn't find a matching device\n\t\t\tif (!this._device && devices.length > 0) {\n\t\t\t\tthis._device = devices[0];\n\t\t\t}\n\t\t\tassert(isDefined(this._device), `No matching device ${labelOrId}`);\n\t\t}\n\t\t// do getUserMedia\n\t\tconst constraints = {\n\t\t\taudio: {\n\t\t\t\techoCancellation: false,\n\t\t\t\tsampleRate: this.context.sampleRate,\n\t\t\t\tnoiseSuppression: false,\n\t\t\t\tmozNoiseSuppression: false,\n\t\t\t}\n\t\t};\n\t\tif (this._device) {\n\t\t\t// @ts-ignore\n\t\t\tconstraints.audio.deviceId = this._device.deviceId;\n\t\t}\n\t\tconst stream = await navigator.mediaDevices.getUserMedia(constraints);\n\t\t// start a new source only if the previous one is closed\n\t\tif (!this._stream) {\n\t\t\tthis._stream = stream;\n\t\t\t// Wrap a MediaStreamSourceNode around the live input stream.\n\t\t\tconst mediaStreamNode = this.context.createMediaStreamSource(stream);\n\t\t\t// Connect the MediaStreamSourceNode to a gate gain node\n\t\t\tconnect(mediaStreamNode, this.output);\n\t\t\tthis._mediaStream = mediaStreamNode;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Close the media stream\n\t */\n\tclose(): this {\n\t\tif (this._stream && this._mediaStream) {\n\t\t\tthis._stream.getAudioTracks().forEach((track) => {\n\t\t\t\ttrack.stop();\n\t\t\t});\n\t\t\tthis._stream = undefined;\n\t\t\t// remove the old media stream\n\t\t\tthis._mediaStream.disconnect();\n\t\t\tthis._mediaStream = undefined;\n\t\t}\n\t\tthis._device = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a promise which resolves with the list of audio input devices available.\n\t * @return The promise that is resolved with the devices\n\t * @example\n\t * Tone.UserMedia.enumerateDevices().then((devices) => {\n\t * \t// print the device labels\n\t * \tconsole.log(devices.map(device => device.label));\n\t * });\n\t */\n\tstatic async enumerateDevices(): Promise<MediaDeviceInfo[]> {\n\t\tconst allDevices = await navigator.mediaDevices.enumerateDevices();\n\t\treturn allDevices.filter(device => {\n\t\t\treturn device.kind === \"audioinput\";\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, \"started\" when the microphone is open\n\t * and \"stopped\" when the mic is closed.\n\t */\n\tget state() {\n\t\treturn this._stream && this._stream.active ? \"started\" : \"stopped\";\n\t}\n\n\t/**\n\t * Returns an identifier for the represented device that is\n\t * persisted across sessions. It is un-guessable by other applications and\n\t * unique to the origin of the calling application. It is reset when the\n\t * user clears cookies (for Private Browsing, a different identifier is\n\t * used that is not persisted across sessions). Returns undefined when the\n\t * device is not open.\n\t */\n\tget deviceId(): string | undefined {\n\t\tif (this._device) {\n\t\t\treturn this._device.deviceId;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a group identifier. Two devices have the\n\t * same group identifier if they belong to the same physical device.\n\t * Returns null  when the device is not open.\n\t */\n\tget groupId(): string | undefined {\n\t\tif (this._device) {\n\t\t\treturn this._device.groupId;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a label describing this device (for example \"Built-in Microphone\").\n\t * Returns undefined when the device is not open or label is not available\n\t * because of permissions.\n\t */\n\tget label(): string | undefined {\n\t\tif (this._device) {\n\t\t\treturn this._device.label;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * const mic = new Tone.UserMedia();\n\t * mic.open().then(() => {\n\t * \t// promise resolves when input is available\n\t * });\n\t * // mute the output\n\t * mic.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.close();\n\t\tthis._volume.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n\n\t/**\n\t * If getUserMedia is supported by the browser.\n\t */\n\tstatic get supported(): boolean {\n\t\treturn isDefined(navigator.mediaDevices) &&\n\t\t\tisDefined(navigator.mediaDevices.getUserMedia);\n\t}\n}\n","import { AudioRange, Cents, Degrees, Frequency, Positive } from \"../../core/type/Units\";\nimport { Omit } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { SourceOptions } from \"../Source\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\n\n/**\n * The common interface of all Oscillators\n */\nexport interface ToneOscillatorInterface {\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * const osc = new Tone.Oscillator();\n\t * osc.type = \"sine2\";\n\t * console.log(osc.baseType); // \"sine\"\n\t */\n\tbaseType: OscillatorType | \"pulse\" | \"pwm\";\n\n\t/**\n\t * The oscillator's type. Also capable of setting the first x number of partials of the oscillator. \n\t * For example: \"sine4\" would set be the first 4 partials of the sine wave and \"triangle8\" would \n\t * set the first 8 partials of the triangle wave.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst osc = new Tone.Oscillator().toDestination().start();\n\t * \tosc.type = \"sine2\";\n\t * }, 0.1, 1);\n\t */\n\ttype: ExtendedToneOscillatorType;\n\n\t/**\n\t * The frequency value of the oscillator\n\t * @example\n\t * const osc = new Tone.FMOscillator(\"Bb4\").toDestination().start();\n\t * osc.frequency.rampTo(\"D2\", 3);\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune value in cents (100th of a semitone).\n\t * @example\n\t * const osc = new Tone.PulseOscillator(\"F3\").toDestination().start();\n\t * // pitch it 1 octave = 12 semitones = 1200 cents\n\t * osc.detune.setValueAtTime(-1200, Tone.now());\n\t * osc.detune.setValueAtTime(1200, Tone.now() + 0.5);\n\t * osc.detune.linearRampToValueAtTime(0, Tone.now() + 1);\n\t * osc.stop(Tone.now() + 1.5);\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The phase is the starting position within the oscillator's cycle. For example\n\t * a phase of 180 would start halfway through the oscillator's cycle. \n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst osc = new Tone.Oscillator({\n\t * \t\tfrequency: 20,\n\t * \t\tphase: 90\n\t * \t}).toDestination().start();\n\t * }, 0.1, 1);\n\t */\n\tphase: Degrees;\n\n\t/**\n\t * The partials describes the relative amplitude of each of the harmonics of the oscillator. \n\t * The first value in the array is the first harmonic (i.e. the fundamental frequency), the \n\t * second harmonic is an octave up, the third harmonic is an octave and a fifth, etc. The resulting\n\t * oscillator output is composed of a sine tone at the relative amplitude at each of the harmonic intervals. \n\t * \n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * const osc = new Tone.Oscillator(\"F3\").toDestination().start();\n\t * setInterval(() => {\n\t * \t// generate 8 random partials\n\t * \tosc.partials = new Array(8).map(() => Math.random());\n\t * }, 1000);\n\t */\n\tpartials: number[];\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array. A square wave wave\n\t * is composed of only odd harmonics up through the harmonic series. Partial count\n\t * can limit the number of harmonics which are used to generate the waveform.\n\t * @example\n\t * const osc = new Tone.Oscillator(\"C3\", \"square\").toDestination().start();\n\t * osc.partialCount = 1;\n\t * setInterval(() => {\n\t * \tosc.partialCount++;\n\t * \tconsole.log(osc.partialCount);\n\t * }, 500);\n\t */\n\tpartialCount?: number;\n\n\t/**\n\t * Returns an array of values which represents the waveform.\n\t * @param length The length of the waveform to return\n\t */\n\tasArray(length: number): Promise<Float32Array>;\n}\n\n/**\n * Render a segment of the oscillator to an offline context and return the results as an array\n */\nexport async function generateWaveform(instance: any, length: number): Promise<Float32Array> {\n\tconst duration = length / instance.context.sampleRate;\n\tconst context = new OfflineContext(1, duration, instance.context.sampleRate);\n\tconst clone = new instance.constructor(Object.assign(instance.get(), {\n\t\t// should do 2 iterations\n\t\tfrequency: 2 / duration,\n\t\t// zero out the detune\n\t\tdetune: 0,\n\t\tcontext\n\t})).toDestination();\n\tclone.start(0);\n\tconst buffer = await context.render();\n\treturn buffer.getChannelData(0);\n}\n\n/**\n * Oscillators with partials\n */\ntype SineWithPartials =\n\t\"sine1\" | \"sine2\" | \"sine3\" | \"sine4\" | \"sine5\" | \"sine6\" | \"sine7\" | \"sine8\" | \"sine9\" |\n\t\"sine10\" | \"sine11\" | \"sine12\" | \"sine13\" | \"sine14\" | \"sine15\" | \"sine16\" | \"sine17\" | \"sine18\" | \"sine19\" |\n\t\"sine20\" | \"sine21\" | \"sine22\" | \"sine23\" | \"sine24\" | \"sine25\" | \"sine26\" | \"sine27\" | \"sine28\" | \"sine29\" |\n\t\"sine30\" | \"sine31\" | \"sine32\";\n\ntype SquareWithPartials =\n\t\"square1\" | \"square2\" | \"square3\" | \"square4\" | \"square5\" | \"square6\" | \"square7\" | \"square8\" | \"square9\" |\n\t\"square10\" | \"square11\" | \"square12\" | \"square13\" | \"square14\" | \"square15\" | \"square16\" | \"square17\" | \"square18\" | \"square19\" |\n\t\"square20\" | \"square21\" | \"square22\" | \"square23\" | \"square24\" | \"square25\" | \"square26\" | \"square27\" | \"square28\" | \"square29\" |\n\t\"square30\" | \"square31\" | \"square32\";\n\ntype SawtoothWithPartials =\n\t\"sawtooth1\" | \"sawtooth2\" | \"sawtooth3\" | \"sawtooth4\" | \"sawtooth5\" | \"sawtooth6\" | \"sawtooth7\" | \"sawtooth8\" | \"sawtooth9\" |\n\t\"sawtooth10\" | \"sawtooth11\" | \"sawtooth12\" | \"sawtooth13\" | \"sawtooth14\" | \"sawtooth15\" | \"sawtooth16\" | \"sawtooth17\" | \"sawtooth18\" | \"sawtooth19\" |\n\t\"sawtooth20\" | \"sawtooth21\" | \"sawtooth22\" | \"sawtooth23\" | \"sawtooth24\" | \"sawtooth25\" | \"sawtooth26\" | \"sawtooth27\" | \"sawtooth28\" | \"sawtooth29\" |\n\t\"sawtooth30\" | \"sawtooth31\" | \"sawtooth32\";\n\ntype TriangleWithPartials =\n\t\"triangle1\" | \"triangle2\" | \"triangle3\" | \"triangle4\" | \"triangle5\" | \"triangle6\" | \"triangle7\" | \"triangle8\" | \"triangle9\" |\n\t\"triangle10\" | \"triangle11\" | \"triangle12\" | \"triangle13\" | \"triangle14\" | \"triangle15\" | \"triangle16\" | \"triangle17\" | \"triangle18\" | \"triangle19\" |\n\t\"triangle20\" | \"triangle21\" | \"triangle22\" | \"triangle23\" | \"triangle24\" | \"triangle25\" | \"triangle26\" | \"triangle27\" | \"triangle28\" | \"triangle29\" |\n\t\"triangle30\" | \"triangle31\" | \"triangle32\";\n\ntype TypeWithPartials = SineWithPartials | SquareWithPartials | TriangleWithPartials | SawtoothWithPartials;\n\ninterface BaseOscillatorOptions extends SourceOptions {\n\tfrequency: Frequency;\n\tdetune: Cents;\n\tphase: Degrees;\n}\n\nexport type NonCustomOscillatorType = Exclude<OscillatorType, \"custom\">;\n\ntype AllNonCustomOscillatorType = NonCustomOscillatorType | TypeWithPartials;\n\nexport type ToneOscillatorType = AllNonCustomOscillatorType | \"custom\";\n\nexport type ExtendedToneOscillatorType = ToneOscillatorType | \"pwm\" | \"pulse\";\n\n/**\n * Oscillator Interfaces\n */\ninterface ToneCustomOscillatorOptions extends BaseOscillatorOptions {\n\ttype: \"custom\";\n\tpartials: number[];\n}\n\ninterface ToneTypeOscillatorOptions extends BaseOscillatorOptions {\n\ttype: NonCustomOscillatorType;\n\tpartialCount?: number;\n}\n\ninterface TonePartialOscillatorOptions extends BaseOscillatorOptions {\n\ttype: TypeWithPartials;\n}\n\nexport type ToneOscillatorConstructorOptions = ToneCustomOscillatorOptions | ToneTypeOscillatorOptions | TonePartialOscillatorOptions;\n\nexport interface ToneOscillatorOptions extends BaseOscillatorOptions {\n\ttype: ToneOscillatorType;\n\tpartialCount: number;\n\tpartials: number[];\n}\n\n/**\n * FMOscillator Interface\n */\ninterface FMBaseOscillatorOptions extends BaseOscillatorOptions {\n\tharmonicity: Positive;\n\tmodulationIndex: Positive;\n\tmodulationType: AllNonCustomOscillatorType;\n}\n\ninterface FMCustomOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: \"custom\";\n\tpartials: number[];\n}\n\ninterface FMTypeOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: NonCustomOscillatorType;\n\tpartialsCount?: number;\n}\n\ninterface FMPartialsOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: TypeWithPartials;\n}\n\nexport type FMConstructorOptions = FMTypeOscillatorOptions | FMCustomOscillatorOptions | FMPartialsOscillatorOptions;\n\nexport interface FMOscillatorOptions extends ToneOscillatorOptions {\n\tharmonicity: Positive;\n\tmodulationIndex: Positive;\n\tmodulationType: AllNonCustomOscillatorType;\n}\n\n/**\n * AMOscillator Interface\n */\ninterface AMBaseOscillatorOptions extends BaseOscillatorOptions {\n\tharmonicity: Positive;\n\tmodulationType: AllNonCustomOscillatorType;\n}\n\ninterface AMCustomOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: \"custom\";\n\tpartials: number[];\n}\n\ninterface AMTypeOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: NonCustomOscillatorType;\n\tpartialsCount?: number;\n}\n\ninterface AMPartialsOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: TypeWithPartials;\n}\n\nexport type AMConstructorOptions = AMCustomOscillatorOptions | AMTypeOscillatorOptions | AMPartialsOscillatorOptions;\n\nexport interface AMOscillatorOptions extends ToneOscillatorOptions {\n\tharmonicity: Positive;\n\tmodulationType: AllNonCustomOscillatorType;\n}\n/**\n * FatOscillator\n */\ninterface FatBaseOscillatorOptions extends BaseOscillatorOptions {\n\tspread: Cents;\n\tcount: Positive;\n}\n\ninterface FatCustomOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: \"custom\";\n\tpartials: number[];\n}\n\ninterface FatTypeOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: NonCustomOscillatorType;\n\tpartialCount?: number;\n}\n\ninterface FatPartialsOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: TypeWithPartials;\n}\n\nexport type FatConstructorOptions = FatCustomOscillatorOptions | FatTypeOscillatorOptions | FatPartialsOscillatorOptions;\n\nexport interface FatOscillatorOptions extends ToneOscillatorOptions {\n\tspread: Cents;\n\tcount: Positive;\n}\n\n/**\n * Pulse Oscillator\n */\nexport interface PulseOscillatorOptions extends BaseOscillatorOptions {\n\ttype: \"pulse\";\n\twidth: AudioRange;\n}\n\n/**\n * PWM Oscillator\n */\nexport interface PWMOscillatorOptions extends BaseOscillatorOptions {\n\ttype: \"pwm\";\n\tmodulationFrequency: Frequency;\n}\n\n/**\n * OMNI OSCILLATOR\n */\n\n/**\n * FM Oscillators with partials\n */\ntype FMSineWithPartials =\n\t\"fmsine1\" | \"fmsine2\" | \"fmsine3\" | \"fmsine4\" | \"fmsine5\" | \"fmsine6\" | \"fmsine7\" | \"fmsine8\" | \"fmsine9\" |\n\t\"fmsine10\" | \"fmsine11\" | \"fmsine12\" | \"fmsine13\" | \"fmsine14\" | \"fmsine15\" | \"fmsine16\" | \"fmsine17\" | \"fmsine18\" | \"fmsine19\" |\n\t\"fmsine20\" | \"fmsine21\" | \"fmsine22\" | \"fmsine23\" | \"fmsine24\" | \"fmsine25\" | \"fmsine26\" | \"fmsine27\" | \"fmsine28\" | \"fmsine29\" |\n\t\"fmsine30\" | \"fmsine31\" | \"fmsine32\";\n\ntype FMSquareWithPartials =\n\t\"fmsquare1\" | \"fmsquare2\" | \"fmsquare3\" | \"fmsquare4\" | \"fmsquare5\" | \"fmsquare6\" | \"fmsquare7\" | \"fmsquare8\" | \"fmsquare9\" |\n\t\"fmsquare10\" | \"fmsquare11\" | \"fmsquare12\" | \"fmsquare13\" | \"fmsquare14\" | \"fmsquare15\" | \"fmsquare16\" | \"fmsquare17\" | \"fmsquare18\" | \"fmsquare19\" |\n\t\"fmsquare20\" | \"fmsquare21\" | \"fmsquare22\" | \"fmsquare23\" | \"fmsquare24\" | \"fmsquare25\" | \"fmsquare26\" | \"fmsquare27\" | \"fmsquare28\" | \"fmsquare29\" |\n\t\"fmsquare30\" | \"fmsquare31\" | \"fmsquare32\";\n\ntype FMSawtoothWithPartials =\n\t\"fmsawtooth1\" | \"fmsawtooth2\" | \"fmsawtooth3\" | \"fmsawtooth4\" | \"fmsawtooth5\" | \"fmsawtooth6\" | \"fmsawtooth7\" | \"fmsawtooth8\" | \"fmsawtooth9\" |\n\t\"fmsawtooth10\" | \"fmsawtooth11\" | \"fmsawtooth12\" | \"fmsawtooth13\" | \"fmsawtooth14\" | \"fmsawtooth15\" | \"fmsawtooth16\" | \"fmsawtooth17\" | \"fmsawtooth18\" | \"fmsawtooth19\" |\n\t\"fmsawtooth20\" | \"fmsawtooth21\" | \"fmsawtooth22\" | \"fmsawtooth23\" | \"fmsawtooth24\" | \"fmsawtooth25\" | \"fmsawtooth26\" | \"fmsawtooth27\" | \"fmsawtooth28\" | \"fmsawtooth29\" |\n\t\"fmsawtooth30\" | \"fmsawtooth31\" | \"fmsawtooth32\";\n\ntype FMTriangleWithPartials =\n\t\"fmtriangle1\" | \"fmtriangle2\" | \"fmtriangle3\" | \"fmtriangle4\" | \"fmtriangle5\" | \"fmtriangle6\" | \"fmtriangle7\" | \"fmtriangle8\" | \"fmtriangle9\" |\n\t\"fmtriangle10\" | \"fmtriangle11\" | \"fmtriangle12\" | \"fmtriangle13\" | \"fmtriangle14\" | \"fmtriangle15\" | \"fmtriangle16\" | \"fmtriangle17\" | \"fmtriangle18\" | \"fmtriangle19\" |\n\t\"fmtriangle20\" | \"fmtriangle21\" | \"fmtriangle22\" | \"fmtriangle23\" | \"fmtriangle24\" | \"fmtriangle25\" | \"fmtriangle26\" | \"fmtriangle27\" | \"fmtriangle28\" | \"fmtriangle29\" |\n\t\"fmtriangle30\" | \"fmtriangle31\" | \"fmtriangle32\";\n\ntype FMTypeWithPartials = FMSineWithPartials | FMSquareWithPartials | FMSawtoothWithPartials | FMTriangleWithPartials;\n\n/**\n * AM Oscillators with partials\n */\ntype AMSineWithPartials =\n\t\"amsine1\" | \"amsine2\" | \"amsine3\" | \"amsine4\" | \"amsine5\" | \"amsine6\" | \"amsine7\" | \"amsine8\" | \"amsine9\" |\n\t\"amsine10\" | \"amsine11\" | \"amsine12\" | \"amsine13\" | \"amsine14\" | \"amsine15\" | \"amsine16\" | \"amsine17\" | \"amsine18\" | \"amsine19\" |\n\t\"amsine20\" | \"amsine21\" | \"amsine22\" | \"amsine23\" | \"amsine24\" | \"amsine25\" | \"amsine26\" | \"amsine27\" | \"amsine28\" | \"amsine29\" |\n\t\"amsine30\" | \"amsine31\" | \"amsine32\";\n\ntype AMSquareWithPartials =\n\t\"amsquare1\" | \"amsquare2\" | \"amsquare3\" | \"amsquare4\" | \"amsquare5\" | \"amsquare6\" | \"amsquare7\" | \"amsquare8\" | \"amsquare9\" |\n\t\"amsquare10\" | \"amsquare11\" | \"amsquare12\" | \"amsquare13\" | \"amsquare14\" | \"amsquare15\" | \"amsquare16\" | \"amsquare17\" | \"amsquare18\" | \"amsquare19\" |\n\t\"amsquare20\" | \"amsquare21\" | \"amsquare22\" | \"amsquare23\" | \"amsquare24\" | \"amsquare25\" | \"amsquare26\" | \"amsquare27\" | \"amsquare28\" | \"amsquare29\" |\n\t\"amsquare30\" | \"amsquare31\" | \"amsquare32\";\n\ntype AMSawtoothWithPartials =\n\t\"amsawtooth1\" | \"amsawtooth2\" | \"amsawtooth3\" | \"amsawtooth4\" | \"amsawtooth5\" | \"amsawtooth6\" | \"amsawtooth7\" | \"amsawtooth8\" | \"amsawtooth9\" |\n\t\"amsawtooth10\" | \"amsawtooth11\" | \"amsawtooth12\" | \"amsawtooth13\" | \"amsawtooth14\" | \"amsawtooth15\" | \"amsawtooth16\" | \"amsawtooth17\" | \"amsawtooth18\" | \"amsawtooth19\" |\n\t\"amsawtooth20\" | \"amsawtooth21\" | \"amsawtooth22\" | \"amsawtooth23\" | \"amsawtooth24\" | \"amsawtooth25\" | \"amsawtooth26\" | \"amsawtooth27\" | \"amsawtooth28\" | \"amsawtooth29\" |\n\t\"amsawtooth30\" | \"amsawtooth31\" | \"amsawtooth32\";\n\ntype AMTriangleWithPartials =\n\t\"amtriangle1\" | \"amtriangle2\" | \"amtriangle3\" | \"amtriangle4\" | \"amtriangle5\" | \"amtriangle6\" | \"amtriangle7\" | \"amtriangle8\" | \"amtriangle9\" |\n\t\"amtriangle10\" | \"amtriangle11\" | \"amtriangle12\" | \"amtriangle13\" | \"amtriangle14\" | \"amtriangle15\" | \"amtriangle16\" | \"amtriangle17\" | \"amtriangle18\" | \"amtriangle19\" |\n\t\"amtriangle20\" | \"amtriangle21\" | \"amtriangle22\" | \"amtriangle23\" | \"amtriangle24\" | \"amtriangle25\" | \"amtriangle26\" | \"amtriangle27\" | \"amtriangle28\" | \"amtriangle29\" |\n\t\"amtriangle30\" | \"amtriangle31\" | \"amtriangle32\";\n\ntype AMTypeWithPartials = AMSineWithPartials | AMSquareWithPartials | AMSawtoothWithPartials | AMTriangleWithPartials;\n\n/**\n * Fat Oscillators with partials\n */\ntype FatSineWithPartials =\n\t\"fatsine1\" | \"fatsine2\" | \"fatsine3\" | \"fatsine4\" | \"fatsine5\" | \"fatsine6\" | \"fatsine7\" | \"fatsine8\" | \"fatsine9\" |\n\t\"fatsine10\" | \"fatsine11\" | \"fatsine12\" | \"fatsine13\" | \"fatsine14\" | \"fatsine15\" | \"fatsine16\" | \"fatsine17\" | \"fatsine18\" | \"fatsine19\" |\n\t\"fatsine20\" | \"fatsine21\" | \"fatsine22\" | \"fatsine23\" | \"fatsine24\" | \"fatsine25\" | \"fatsine26\" | \"fatsine27\" | \"fatsine28\" | \"fatsine29\" |\n\t\"fatsine30\" | \"fatsine31\" | \"fatsine32\";\n\ntype FatSquareWithPartials =\n\t\"fatsquare1\" | \"fatsquare2\" | \"fatsquare3\" | \"fatsquare4\" | \"fatsquare5\" | \"fatsquare6\" | \"fatsquare7\" | \"fatsquare8\" | \"fatsquare9\" |\n\t\"fatsquare10\" | \"fatsquare11\" | \"fatsquare12\" | \"fatsquare13\" | \"fatsquare14\" | \"fatsquare15\" | \"fatsquare16\" | \"fatsquare17\" | \"fatsquare18\" | \"fatsquare19\" |\n\t\"fatsquare20\" | \"fatsquare21\" | \"fatsquare22\" | \"fatsquare23\" | \"fatsquare24\" | \"fatsquare25\" | \"fatsquare26\" | \"fatsquare27\" | \"fatsquare28\" | \"fatsquare29\" |\n\t\"fatsquare30\" | \"fatsquare31\" | \"fatsquare32\";\n\ntype FatSawtoothWithPartials =\n\t\"fatsawtooth1\" | \"fatsawtooth2\" | \"fatsawtooth3\" | \"fatsawtooth4\" | \"fatsawtooth5\" | \"fatsawtooth6\" | \"fatsawtooth7\" | \"fatsawtooth8\" | \"fatsawtooth9\" |\n\t\"fatsawtooth10\" | \"fatsawtooth11\" | \"fatsawtooth12\" | \"fatsawtooth13\" | \"fatsawtooth14\" | \"fatsawtooth15\" | \"fatsawtooth16\" | \"fatsawtooth17\" | \"fatsawtooth18\" | \"fatsawtooth19\" |\n\t\"fatsawtooth20\" | \"fatsawtooth21\" | \"fatsawtooth22\" | \"fatsawtooth23\" | \"fatsawtooth24\" | \"fatsawtooth25\" | \"fatsawtooth26\" | \"fatsawtooth27\" | \"fatsawtooth28\" | \"fatsawtooth29\" |\n\t\"fatsawtooth30\" | \"fatsawtooth31\" | \"fatsawtooth32\";\n\ntype FatTriangleWithPartials =\n\t\"fattriangle1\" | \"fattriangle2\" | \"fattriangle3\" | \"fattriangle4\" | \"fattriangle5\" | \"fattriangle6\" | \"fattriangle7\" | \"fattriangle8\" | \"fattriangle9\" |\n\t\"fattriangle10\" | \"fattriangle11\" | \"fattriangle12\" | \"fattriangle13\" | \"fattriangle14\" | \"fattriangle15\" | \"fattriangle16\" | \"fattriangle17\" | \"fattriangle18\" | \"fattriangle19\" |\n\t\"fattriangle20\" | \"fattriangle21\" | \"fattriangle22\" | \"fattriangle23\" | \"fattriangle24\" | \"fattriangle25\" | \"fattriangle26\" | \"fattriangle27\" | \"fattriangle28\" | \"fattriangle29\" |\n\t\"fattriangle30\" | \"fattriangle31\" | \"fattriangle32\";\n\ntype FatTypeWithPartials = FatSineWithPartials | FatSquareWithPartials | FatSawtoothWithPartials | FatTriangleWithPartials;\n\n/**\n * Omni FM\n */\ninterface OmniFMCustomOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: \"fmcustom\";\n\tpartials: number[];\n}\n\ninterface OmniFMTypeOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: \"fmsine\" | \"fmsquare\" | \"fmsawtooth\" | \"fmtriangle\";\n\tpartialsCount?: number;\n}\n\ninterface OmniFMPartialsOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: FMTypeWithPartials;\n}\n\n/**\n * Omni AM\n */\ninterface OmniAMCustomOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: \"amcustom\";\n\tpartials: number[];\n}\n\ninterface OmniAMTypeOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: \"amsine\" | \"amsquare\" | \"amsawtooth\" | \"amtriangle\";\n\tpartialsCount?: number;\n}\n\ninterface OmniAMPartialsOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: AMTypeWithPartials;\n}\n\n/**\n * Omni Fat\n */\ninterface OmniFatCustomOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: \"fatcustom\";\n\tpartials: number[];\n}\n\ninterface OmniFatTypeOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: \"fatsine\" | \"fatsquare\" | \"fatsawtooth\" | \"fattriangle\";\n\tpartialsCount?: number;\n}\n\ninterface OmniFatPartialsOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: FatTypeWithPartials;\n}\n\nexport type OmniOscillatorType =\n\t\"fatsine\" | \"fatsquare\" | \"fatsawtooth\" | \"fattriangle\" | \"fatcustom\" | FatTypeWithPartials |\n\t\"fmsine\" | \"fmsquare\" | \"fmsawtooth\" | \"fmtriangle\" | \"fmcustom\" | FMTypeWithPartials |\n\t\"amsine\" | \"amsquare\" | \"amsawtooth\" | \"amtriangle\" | \"amcustom\" | AMTypeWithPartials |\n\tTypeWithPartials | OscillatorType | \"pulse\" | \"pwm\";\n\nexport type OmniOscillatorConstructorOptions =\n\tPulseOscillatorOptions | PWMOscillatorOptions |\n\tOmniFatCustomOscillatorOptions | OmniFatTypeOscillatorOptions | OmniFatPartialsOscillatorOptions |\n\tOmniFMCustomOscillatorOptions | OmniFMTypeOscillatorOptions | OmniFMPartialsOscillatorOptions |\n\tOmniAMCustomOscillatorOptions | OmniAMTypeOscillatorOptions | OmniAMPartialsOscillatorOptions |\n\tToneOscillatorConstructorOptions;\n\n// export type OmniOscillatorSourceOptions = OmniOscillatorConstructorOptions & SourceOptions;\n\nexport type OmniOscillatorOptions =\n\tPulseOscillatorOptions & PWMOscillatorOptions &\n\tOmniFatCustomOscillatorOptions & OmniFatTypeOscillatorOptions & OmniFatPartialsOscillatorOptions &\n\tOmniFMCustomOscillatorOptions & OmniFMTypeOscillatorOptions & OmniFMPartialsOscillatorOptions &\n\tOmniAMCustomOscillatorOptions & OmniAMTypeOscillatorOptions & OmniAMPartialsOscillatorOptions &\n\tToneOscillatorConstructorOptions;\n\ntype OmitSourceOptions<T extends BaseOscillatorOptions> = Omit<T, \"frequency\" | \"detune\" | \"context\">;\n\n/**\n * The settable options for the omni oscillator inside of the source which excludes certain attributes that are defined by the parent class\n */\nexport type OmniOscillatorSynthOptions =\n\tOmitSourceOptions<PulseOscillatorOptions> | OmitSourceOptions<PWMOscillatorOptions> |\n\tOmitSourceOptions<OmniFatCustomOscillatorOptions> | OmitSourceOptions<OmniFatTypeOscillatorOptions> | OmitSourceOptions<OmniFatPartialsOscillatorOptions> |\n\tOmitSourceOptions<OmniFMCustomOscillatorOptions> | OmitSourceOptions<OmniFMTypeOscillatorOptions> | OmitSourceOptions<OmniFMPartialsOscillatorOptions> |\n\tOmitSourceOptions<OmniAMCustomOscillatorOptions> | OmitSourceOptions<OmniAMTypeOscillatorOptions> | OmitSourceOptions<OmniAMPartialsOscillatorOptions> |\n\tOmitSourceOptions<ToneCustomOscillatorOptions> | OmitSourceOptions<ToneTypeOscillatorOptions> | OmitSourceOptions<TonePartialOscillatorOptions>\n","import { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { Cents, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OneShotSource, OneShotSourceOptions } from \"../OneShotSource\";\nimport { readOnly } from \"../../core/util/Interface\";\n\nexport interface ToneOscillatorNodeOptions extends OneShotSourceOptions {\n\tfrequency: Frequency;\n\tdetune: Cents;\n\ttype: OscillatorType;\n}\n\n/**\n * Wrapper around the native fire-and-forget OscillatorNode.\n * Adds the ability to reschedule the stop method.\n * ***[[Oscillator]] is better for most use-cases***\n * @category Source\n */\nexport class ToneOscillatorNode extends OneShotSource<ToneOscillatorNodeOptions> {\n\n\treadonly name: string = \"ToneOscillatorNode\";\n\n\t/**\n\t * The oscillator\n\t */\n\tprivate _oscillator = this.context.createOscillator();\n\tprotected _internalChannels = [this._oscillator];\n\n\t/**\n\t * The frequency of the oscillator\n\t */\n\treadonly frequency: Param<\"frequency\">;\n\n\t/**\n\t * The detune of the oscillator\n\t */\n\treadonly detune: Param<\"cents\">;\n\n\t/**\n\t * @param  frequency   The frequency value\n\t * @param  type  The basic oscillator type\n\t */\n\tconstructor(\n\t\tfrequency: Frequency,\n\t\ttype: OscillatorType,\n\t);\n\tconstructor(options?: Partial<ToneOscillatorNodeOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tconnect(this._oscillator, this._gainNode);\n\n\t\tthis.type = options.type;\n\n\t\tthis.frequency = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._oscillator.frequency,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\n\t\tthis.detune = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._oscillator.detune,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): ToneOscillatorNodeOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\ttype: \"sine\" as OscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * Start the oscillator node at the given time\n\t * @param  time When to start the oscillator\n\t */\n\tstart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tthis._startGain(computedTime);\n\t\tthis._oscillator.start(computedTime);\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\t/**\n\t * Sets an arbitrary custom periodic waveform given a PeriodicWave.\n\t * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave\n\t */\n\tsetPeriodicWave(periodicWave: PeriodicWave): this {\n\t\tthis._oscillator.setPeriodicWave(periodicWave);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'\n\t */\n\tget type(): OscillatorType {\n\t\treturn this._oscillator.type;\n\t}\n\tset type(type: OscillatorType) {\n\t\tthis._oscillator.type = type;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this.state === \"started\") {\n\t\t\tthis.stop();\n\t\t}\n\t\tthis._oscillator.disconnect();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","import { AudioRange, Degrees, Frequency, Radians, Time } from \"../../core/type/Units\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport {\n\tgenerateWaveform, ToneOscillatorConstructorOptions, ToneOscillatorInterface,\n\tToneOscillatorOptions, ToneOscillatorType\n} from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { clamp } from \"../../core/util/Math\";\nexport { ToneOscillatorOptions, ToneOscillatorType } from \"./OscillatorInterface\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * // make and start a 440hz sine tone\n * const osc = new Tone.Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\nexport class Oscillator extends Source<ToneOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"Oscillator\";\n\n\t/**\n\t * the main oscillator\n\t */\n\tprivate _oscillator: ToneOscillatorNode | null = null;\n\n\t/**\n\t * The frequency control.\n\t */\n\tfrequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune control signal.\n\t */\n\tdetune: Signal<\"cents\">;\n\n\t/**\n\t * the periodic wave\n\t */\n\tprivate _wave?: PeriodicWave;\n\n\t/**\n\t * The partials of the oscillator\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t * The number of partials to limit or extend the periodic wave by\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t * the phase of the oscillator between 0 - 360\n\t */\n\tprivate _phase!: Radians;\n\n\t/**\n\t * the type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t * @param frequency Starting frequency\n\t * @param type The oscillator type. Read more about type below.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType);\n\tconstructor(options?: Partial<ToneOscillatorConstructorOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal<\"frequency\">({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\tthis.detune = new Signal<\"cents\">({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, \"detune\");\n\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\t\tthis._type = options.type;\n\n\t\tif (options.partialCount && options.type !== \"custom\") {\n\t\t\tthis._type = this.baseType + options.partialCount.toString() as ToneOscillatorType;\n\t\t}\n\t\tthis.phase = options.phase;\n\t}\n\n\tstatic getDefaults(): ToneOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tpartialCount: 0,\n\t\t\tpartials: [],\n\t\t\tphase: 0,\n\t\t\ttype: \"sine\" as const,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// new oscillator with previous values\n\t\tconst oscillator = new ToneOscillatorNode({\n\t\t\tcontext: this.context,\n\t\t\tonended: () => this.onstop(this),\n\t\t});\n\t\tthis._oscillator = oscillator;\n\t\tif (this._wave) {\n\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t} else {\n\t\t\tthis._oscillator.type = this._type as OscillatorType;\n\t\t}\n\t\t// connect the control signal to the oscillator frequency & detune\n\t\tthis._oscillator.connect(this.output);\n\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\tthis.detune.connect(this._oscillator.detune);\n\n\t\t// start the oscillator\n\t\tthis._oscillator.start(computedTime);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.stop(computedTime);\n\t\t}\n\t}\n\n\t/**\n\t * Restart the oscillator. Does not stop the oscillator, but instead\n\t * just cancels any scheduled 'stop' from being invoked.\n\t */\n\tprotected _restart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"restart\", computedTime);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.cancelStop();\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n\t * will also affect the oscillators frequency.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination().start();\n\t * osc.frequency.value = 440;\n\t * // the ratio between the bpm and the frequency will be maintained\n\t * osc.syncFrequency();\n\t * // double the tempo\n\t * Tone.Transport.bpm.value *= 2;\n\t * // the frequency of the oscillator is doubled to 880\n\t */\n\tsyncFrequency(): this {\n\t\tthis.context.transport.syncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the oscillator's frequency from the Transport.\n\t * See Oscillator.syncFrequency\n\t */\n\tunsyncFrequency(): this {\n\t\tthis.context.transport.unsyncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cache the periodic waves to avoid having to redo computations\n\t */\n\tprivate static _periodicWaveCache: Array<{\n\t\tpartials: number[];\n\t\tphase: number;\n\t\ttype: string;\n\t\tpartialCount: number;\n\t\treal: Float32Array;\n\t\timag: Float32Array;\n\t\twave: PeriodicWave;\n\t}> = [];\n\n\t/**\n\t * Get a cached periodic wave. Avoids having to recompute\n\t * the oscillator values when they have already been computed\n\t * with the same values.\n\t */\n\tprivate _getCachedPeriodicWave(): { real: Float32Array; imag: Float32Array; partials: number[]; wave: PeriodicWave } | undefined {\n\t\tif (this._type === \"custom\") {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(description => {\n\t\t\t\treturn description.phase === this._phase &&\n\t\t\t\t\tdeepEquals(description.partials, this._partials);\n\t\t\t});\n\t\t\treturn oscProps;\n\t\t} else {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(description => {\n\t\t\t\treturn description.type === this._type &&\n\t\t\t\t\tdescription.phase === this._phase;\n\t\t\t});\n\t\t\tthis._partialCount = oscProps ? oscProps.partialCount : this._partialCount;\n\t\t\treturn oscProps;\n\t\t}\n\t}\n\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\tset type(type) {\n\t\tthis._type = type;\n\t\tconst isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n\t\tif (this._phase === 0 && isBasicType) {\n\t\t\tthis._wave = undefined;\n\t\t\tthis._partialCount = 0;\n\t\t\t// just go with the basic approach\n\t\t\tif (this._oscillator !== null) {\n\t\t\t\t// already tested that it's a basic type\n\t\t\t\tthis._oscillator.type = type as OscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\t// first check if the value is cached\n\t\t\tconst cache = this._getCachedPeriodicWave();\n\t\t\tif (isDefined(cache)) {\n\t\t\t\tconst { partials, wave } = cache;\n\t\t\t\tthis._wave = wave;\n\t\t\t\tthis._partials = partials;\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst [real, imag] = this._getRealImaginary(type, this._phase);\n\t\t\t\tconst periodicWave = this.context.createPeriodicWave(real, imag);\n\t\t\t\tthis._wave = periodicWave;\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t\t// set the cache\n\t\t\t\tOscillator._periodicWaveCache.push({\n\t\t\t\t\timag,\n\t\t\t\t\tpartialCount: this._partialCount,\n\t\t\t\t\tpartials: this._partials,\n\t\t\t\t\tphase: this._phase,\n\t\t\t\t\treal,\n\t\t\t\t\ttype: this._type,\n\t\t\t\t\twave: this._wave,\n\t\t\t\t});\n\t\t\t\tif (Oscillator._periodicWaveCache.length > 100) {\n\t\t\t\t\tOscillator._periodicWaveCache.shift();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn (this._type as string).replace(this.partialCount.toString(), \"\") as OscillatorType;\n\t}\n\tset baseType(baseType) {\n\t\tif (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n\t\t\tthis.type = baseType + this.partialCount as ToneOscillatorType;\n\t\t} else {\n\t\t\tthis.type = baseType;\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._partialCount;\n\t}\n\tset partialCount(p) {\n\t\tassertRange(p, 0);\n\t\tlet type = this._type;\n\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n\t\tif (partial) {\n\t\t\ttype = partial[1] as OscillatorType;\n\t\t}\n\t\tif (this._type !== \"custom\") {\n\t\t\tif (p === 0) {\n\t\t\t\tthis.type = type;\n\t\t\t} else {\n\t\t\t\tthis.type = type + p.toString() as ToneOscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\t// extend or shorten the partials array\n\t\t\tconst fullPartials = new Float32Array(p);\n\t\t\t// copy over the partials array\n\t\t\tthis._partials.forEach((v, i) => fullPartials[i] = v);\n\t\t\tthis._partials = Array.from(fullPartials);\n\t\t\tthis.type = this._type;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the real and imaginary components based\n\t * on the oscillator type.\n\t * @returns [real: Float32Array, imaginary: Float32Array]\n\t */\n\tprivate _getRealImaginary(type: ToneOscillatorType, phase: Radians): Float32Array[] {\n\t\tconst fftSize = 4096;\n\t\tlet periodicWaveSize = fftSize / 2;\n\n\t\tconst real = new Float32Array(periodicWaveSize);\n\t\tconst imag = new Float32Array(periodicWaveSize);\n\n\t\tlet partialCount = 1;\n\t\tif (type === \"custom\") {\n\t\t\tpartialCount = this._partials.length + 1;\n\t\t\tthis._partialCount = this._partials.length;\n\t\t\tperiodicWaveSize = partialCount;\n\t\t\t// if the partial count is 0, don't bother doing any computation\n\t\t\tif (this._partials.length === 0) {\n\t\t\t\treturn [real, imag];\n\t\t\t}\n\t\t} else {\n\t\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\t\t\tif (partial) {\n\t\t\t\tpartialCount = parseInt(partial[2], 10) + 1;\n\t\t\t\tthis._partialCount = parseInt(partial[2], 10);\n\t\t\t\ttype = partial[1] as ToneOscillatorType;\n\t\t\t\tpartialCount = Math.max(partialCount, 2);\n\t\t\t\tperiodicWaveSize = partialCount;\n\t\t\t} else {\n\t\t\t\tthis._partialCount = 0;\n\t\t\t}\n\t\t\tthis._partials = [];\n\t\t}\n\n\t\tfor (let n = 1; n < periodicWaveSize; ++n) {\n\t\t\tconst piFactor = 2 / (n * Math.PI);\n\t\t\tlet b;\n\t\t\tswitch (type) {\n\t\t\t\tcase \"sine\":\n\t\t\t\t\tb = (n <= partialCount) ? 1 : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"square\":\n\t\t\t\t\tb = (n & 1) ? 2 * piFactor : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sawtooth\":\n\t\t\t\t\tb = piFactor * ((n & 1) ? 1 : -1);\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"triangle\":\n\t\t\t\t\tif (n & 1) {\n\t\t\t\t\t\tb = 2 * (piFactor * piFactor) * ((((n - 1) >> 1) & 1) ? -1 : 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t}\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"custom\":\n\t\t\t\t\tb = this._partials[n - 1];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new TypeError(\"Oscillator: invalid type: \" + type);\n\t\t\t}\n\t\t\tif (b !== 0) {\n\t\t\t\treal[n] = -b * Math.sin(phase * n);\n\t\t\t\timag[n] = b * Math.cos(phase * n);\n\t\t\t} else {\n\t\t\t\treal[n] = 0;\n\t\t\t\timag[n] = 0;\n\t\t\t}\n\t\t}\n\t\treturn [real, imag];\n\t}\n\n\t/**\n\t * Compute the inverse FFT for a given phase.\n\t */\n\tprivate _inverseFFT(real: Float32Array, imag: Float32Array, phase: Radians): number {\n\t\tlet sum = 0;\n\t\tconst len = real.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tsum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n\t\t}\n\t\treturn sum;\n\t}\n\n\t/**\n\t * Returns the initial value of the oscillator when stopped.\n\t * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n\t */\n\tgetInitialValue(): AudioRange {\n\t\tconst [real, imag] = this._getRealImaginary(this._type, 0);\n\t\tlet maxValue = 0;\n\t\tconst twoPi = Math.PI * 2;\n\t\tconst testPositions = 32;\n\t\t// check for peaks in 16 places\n\t\tfor (let i = 0; i < testPositions; i++) {\n\t\t\tmaxValue = Math.max(this._inverseFFT(real, imag, (i / testPositions) * twoPi), maxValue);\n\t\t}\n\t\treturn clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._partials.slice(0, this.partialCount);\n\t}\n\tset partials(partials) {\n\t\tthis._partials = partials;\n\t\tthis._partialCount = this._partials.length;\n\t\tif (partials.length) {\n\t\t\tthis.type = \"custom\";\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._phase * (180 / Math.PI);\n\t}\n\tset phase(phase) {\n\t\tthis._phase = phase * Math.PI / 180;\n\t\t// reset the type\n\t\tthis.type = this._type;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._oscillator !== null) {\n\t\t\tthis._oscillator.dispose();\n\t\t}\n\t\tthis._wave = undefined;\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { InputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { connectSignal } from \"./Signal\";\n\nexport type SignalOperatorOptions = ToneAudioNodeOptions;\n\n/**\n * A signal operator has an input and output and modifies the signal.\n */\nexport abstract class SignalOperator<Options extends SignalOperatorOptions> extends ToneAudioNode<Options> {\n\n\tconstructor(options?: Partial<Options>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(SignalOperator.getDefaults(), arguments, [\"context\"])));\n\t}\n\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tconnectSignal(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isFunction } from \"../core/util/TypeCheck\";\nimport { assert } from \"../core/util/Debug\";\nimport { Signal } from \"./Signal\";\nimport { SignalOperator } from \"./SignalOperator\";\n\nexport type WaveShaperMappingFn = (value: number, index?: number) => number;\n\ntype WaveShaperMapping = WaveShaperMappingFn | number[] | Float32Array;\n\ninterface WaveShaperOptions extends ToneAudioNodeOptions {\n\tmapping?: WaveShaperMapping;\n\tlength: number;\n\tcurve?: number[] | Float32Array;\n}\n\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // multiply the output of the signal by 2 using the waveshaper's function\n * const timesTwo = new Tone.WaveShaper((val) => val * 2, 2048).connect(osc.frequency);\n * const signal = new Tone.Signal(440).connect(timesTwo);\n * @category Signal\n */\nexport class WaveShaper extends SignalOperator<WaveShaperOptions> {\n\n\treadonly name: string = \"WaveShaper\";\n\n\t/**\n\t * the waveshaper node\n\t */\n\tprivate _shaper: WaveShaperNode = this.context.createWaveShaper();\n\n\t/**\n\t * The input to the waveshaper node.\n\t */\n\tinput = this._shaper;\n\n\t/**\n\t * The output from the waveshaper node\n\t */\n\toutput = this._shaper;\n\n\t/**\n\t * @param mapping The function used to define the values.\n\t *                The mapping function should take two arguments:\n\t *                the first is the value at the current position\n\t *                and the second is the array position.\n\t *                If the argument is an array, that array will be\n\t *                set as the wave shaping function. The input\n\t *                signal is an AudioRange [-1, 1] value and the output\n\t *                signal can take on any numerical values.\n\t *\n\t * @param bufferLen The length of the WaveShaperNode buffer.\n\t */\n\tconstructor(mapping?: WaveShaperMapping, length?: number);\n\tconstructor(options?: Partial<WaveShaperOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"])));\n\t\tconst options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n\n\t\tif (isArray(options.mapping) || options.mapping instanceof Float32Array) {\n\t\t\tthis.curve = Float32Array.from(options.mapping);\n\t\t} else if (isFunction(options.mapping)) {\n\t\t\tthis.setMap(options.mapping, options.length);\n\t\t}\n\t}\n\n\tstatic getDefaults(): WaveShaperOptions {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tlength: 1024,\n\t\t});\n\t}\n\n\t/**\n\t * Uses a mapping function to set the value of the curve.\n\t * @param mapping The function used to define the values.\n\t *                The mapping function take two arguments:\n\t *                the first is the value at the current position\n\t *                which goes from -1 to 1 over the number of elements\n\t *                in the curve array. The second argument is the array position.\n\t * @example\n\t * const shaper = new Tone.WaveShaper();\n\t * // map the input signal from [-1, 1] to [0, 10]\n\t * shaper.setMap((val, index) => (val + 1) * 5);\n\t */\n\tsetMap(mapping: WaveShaperMappingFn, length = 1024): this {\n\t\tconst array = new Float32Array(length);\n\t\tfor (let i = 0, len = length; i < len; i++) {\n\t\t\tconst normalized = (i / (len - 1)) * 2 - 1;\n\t\t\tarray[i] = mapping(normalized, i);\n\t\t}\n\t\tthis.curve = array;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The array to set as the waveshaper curve. For linear curves\n\t * array length does not make much difference, but for complex curves\n\t * longer arrays will provide smoother interpolation.\n\t */\n\tget curve(): Float32Array | null {\n\t\treturn this._shaper.curve;\n\t}\n\n\tset curve(mapping: Float32Array | null) {\n\t\tthis._shaper.curve = mapping;\n\t}\n\n\t/**\n\t * Specifies what type of oversampling (if any) should be used when\n\t * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\n\tset oversample(oversampling: OverSampleType) {\n\t\tconst isOverSampleType = [\"none\", \"2x\", \"4x\"].some(str => str.includes(oversampling));\n\t\tassert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.disconnect();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n * AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1].\n * See [[GainToAudio]].\n * @category Signal\n */\nexport class AudioToGain extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"AudioToGain\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _norm = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: x => (x + 1) / 2,\n\t});\n\n\t/**\n\t * The AudioRange input [-1, 1]\n\t */\n\tinput = this._norm;\n\n\t/**\n\t * The GainRange output [0, 1]\n\t */\n\toutput = this._norm;\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._norm.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Signal, SignalOptions } from \"./Signal\";\nimport { InputNode, OutputNode } from \"../core/context/ToneAudioNode\";\n\n/**\n * Multiply two incoming signals. Or, if a number is given in the constructor,\n * multiplies the incoming signal by that value.\n *\n * @example\n * // multiply two signals\n * const mult = new Tone.Multiply();\n * const sigA = new Tone.Signal(3);\n * const sigB = new Tone.Signal(4);\n * sigA.connect(mult);\n * sigB.connect(mult.factor);\n * // output of mult is 12.\n * @example\n * // multiply a signal and a number\n * const mult = new Tone.Multiply(10);\n * const sig = new Tone.Signal(2).connect(mult);\n * // the output of mult is 20.\n * @category Signal\n */\nexport class Multiply<TypeName extends \"number\" | \"positive\" = \"number\"> extends Signal<TypeName> {\n\n\treadonly name: string = \"Multiply\";\n\n\t/**\n\t * Indicates if the value should be overridden on connection\n\t */\n\treadonly override = false;\n\n\t/**\n\t * the input gain node\n\t */\n\tprivate _mult: Gain;\n\n\t/**\n\t * The multiplicand input.\n\t */\n\tinput: InputNode;\n\n\t/**\n\t * The product of the input and [[factor]]\n\t */\n\toutput: OutputNode;\n\n\t/**\n\t * The multiplication factor. Can be set directly or a signal can be connected to it.\n\t */\n\tfactor: Param<TypeName>;\n\n\t/**\n\t * @param value Constant value to multiple\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<SignalOptions<TypeName>>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"])));\n\t\tconst options = optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis._mult = this.input = this.output = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tminValue: options.minValue,\n\t\t\tmaxValue: options.maxValue,\n\t\t});\n\n\t\tthis.factor = this._param = this._mult.gain as unknown as Param<TypeName>;\n\t\tthis.factor.setValueAtTime(options.value, 0);\n\t}\n\n\tstatic getDefaults(): SignalOptions<any> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._mult.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Degrees, Frequency, Seconds } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport {\n\tAMConstructorOptions, AMOscillatorOptions,\n\tgenerateWaveform, NonCustomOscillatorType,\n\tToneOscillatorInterface,\n\tToneOscillatorType\n} from \"./OscillatorInterface\";\n\nexport { AMOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * An amplitude modulated oscillator node. It is implemented with\n * two oscillators, one which modulators the other's amplitude\n * through a gain node.\n * ```\n *    +-------------+       +----------+\n *    | Carrier Osc +>------> GainNode |\n *    +-------------+       |          +--->Output\n *                      +---> gain     |\n * +---------------+    |   +----------+\n * | Modulator Osc +>---+\n * +---------------+\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst amOsc = new Tone.AMOscillator(30, \"sine\", \"square\").toDestination().start();\n * }, 0.2, 1);\n * @category Source\n */\nexport class AMOscillator extends Source<AMOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"AMOscillator\";\n\n\t/**\n\t * The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator;\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The modulating oscillator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t * convert the -1,1 output to 0,1\n\t */\n\tprivate _modulationScale = new AudioToGain({ context: this.context });\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * A harmonicity of 1 gives both oscillators the same frequency.\n\t * Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * const amOsc = new Tone.AMOscillator(\"D2\").toDestination().start();\n\t * Tone.Transport.scheduleRepeat(time => {\n\t * \tamOsc.harmonicity.setValueAtTime(1, time);\n\t * \tamOsc.harmonicity.setValueAtTime(0.5, time + 0.5);\n\t * \tamOsc.harmonicity.setValueAtTime(1.5, time + 1);\n\t * \tamOsc.harmonicity.setValueAtTime(1, time + 2);\n\t * \tamOsc.harmonicity.linearRampToValueAtTime(2, time + 4);\n\t * }, 4);\n\t * Tone.Transport.start();\n\t */\n\treadonly harmonicity: Signal<\"positive\">;\n\n\t/**\n\t * the node where the modulation happens\n\t */\n\tprivate _modulationNode = new Gain({\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * @param frequency The starting frequency of the oscillator.\n\t * @param type The type of the carrier oscillator.\n\t * @param modulationType The type of the modulator oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor(options?: Partial<AMConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n\t\tconst options = optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n\n\t\tthis._carrier = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: options.type,\n\t\t} as OscillatorOptions);\n\t\tthis.frequency = this._carrier.frequency,\n\t\tthis.detune = this._carrier.detune;\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tphase: options.phase,\n\t\t\ttype: options.modulationType,\n\t\t} as OscillatorOptions);\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\t// connections\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\t\tthis._carrier.chain(this._modulationNode, this.output);\n\n\t\treadOnly(this, [\"frequency\", \"detune\", \"harmonicity\"]);\n\t}\n\n\tstatic getDefaults(): AMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationType: \"square\" as NonCustomOscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Seconds): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Seconds): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\tprotected _restart(time: Seconds): void {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t}\n\n\t/**\n\t * The type of the carrier oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis._modulationScale.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Degrees, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport {\n\tFMConstructorOptions, FMOscillatorOptions,\n\tgenerateWaveform, NonCustomOscillatorType, ToneOscillatorInterface, ToneOscillatorType\n} from \"./OscillatorInterface\";\n\nexport { FMOscillatorOptions } from \"./OscillatorInterface\";\n/**\n * FMOscillator implements a frequency modulation synthesis\n * ```\n *                                              +-------------+\n * +---------------+        +-------------+     | Carrier Osc |\n * | Modulator Osc +>-------> GainNode    |     |             +--->Output\n * +---------------+        |             +>----> frequency   |\n *                       +--> gain        |     +-------------+\n *                       |  +-------------+\n * +-----------------+   |\n * | modulationIndex +>--+\n * +-----------------+\n * ```\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst fmOsc = new Tone.FMOscillator({\n * \t\tfrequency: 200,\n * \t\ttype: \"square\",\n * \t\tmodulationType: \"triangle\",\n * \t\tharmonicity: 0.2,\n * \t\tmodulationIndex: 3\n * \t}).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class FMOscillator extends Source<FMOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"FMOscillator\";\n\n\t/**\n\t * The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator;\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The modulating oscillator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * A harmonicity of 1 gives both oscillators the same frequency.\n\t * Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * const fmOsc = new Tone.FMOscillator(\"D2\").toDestination().start();\n\t * // pitch the modulator an octave below carrier\n\t * fmOsc.harmonicity.value = 0.5;\n\t */\n\treadonly harmonicity: Signal<\"positive\">;\n\n\t/**\n\t * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the\n\t * ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t * modulating signal (ma) -- as in ma/mf.\n\t */\n\treadonly modulationIndex: Signal<\"positive\">;\n\n\t/**\n\t * the node where the modulation happens\n\t */\n\tprivate _modulationNode: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * @param frequency The starting frequency of the oscillator.\n\t * @param type The type of the carrier oscillator.\n\t * @param modulationType The type of the modulator oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor(options?: Partial<FMConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n\t\tconst options = optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n\n\t\tthis._carrier = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: 0,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: options.type,\n\t\t} as OscillatorOptions);\n\n\t\tthis.detune = this._carrier.detune;\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tphase: options.phase,\n\t\t\ttype: options.modulationType,\n\t\t} as OscillatorOptions);\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\tthis.modulationIndex = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.modulationIndex,\n\t\t});\n\n\t\t// connections\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.frequency.chain(this.modulationIndex, this._modulationNode);\n\t\tthis._modulator.connect(this._modulationNode.gain);\n\t\tthis._modulationNode.connect(this._carrier.frequency);\n\t\tthis._carrier.connect(this.output);\n\t\tthis.detune.connect(this._modulator.detune);\n\n\t\treadOnly(this, [\"modulationIndex\", \"frequency\", \"detune\", \"harmonicity\"]);\n\t}\n\n\tstatic getDefaults(): FMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationIndex: 2,\n\t\t\tmodulationType: \"square\" as NonCustomOscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\tprotected _restart(time: Seconds): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t\treturn this;\n\t}\n\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis.modulationIndex.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { AudioRange, Degrees, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { WaveShaper } from \"../../signal/WaveShaper\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform, PulseOscillatorOptions, ToneOscillatorInterface } from \"./OscillatorInterface\";\n\nexport { PulseOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * PulseOscillator is an oscillator with control over pulse width,\n * also known as the duty cycle. At 50% duty cycle (width = 0) the wave is\n * a square wave.\n * [Read more](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).\n * ```\n *    width = -0.25        width = 0.0          width = 0.25\n *\n *   +-----+            +-------+       +    +-------+     +-+\n *   |     |            |       |       |            |     |\n *   |     |            |       |       |            |     |\n * +-+     +-------+    +       +-------+            +-----+\n *\n *\n *    width = -0.5                              width = 0.5\n *\n *     +---+                                 +-------+   +---+\n *     |   |                                         |   |\n *     |   |                                         |   |\n * +---+   +-------+                                 +---+\n *\n *\n *    width = -0.75                             width = 0.75\n *\n *       +-+                                 +-------+ +-----+\n *       | |                                         | |\n *       | |                                         | |\n * +-----+ +-------+                                 +-+\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst pulse = new Tone.PulseOscillator(50, 0.4).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class PulseOscillator extends Source<PulseOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"PulseOscillator\";\n\n\t/**\n\t * The width of the pulse.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst pulse = new Tone.PulseOscillator(20, 0.8).toDestination().start();\n\t * }, 0.1, 1);\n\t */\n\treadonly width: Signal<\"audioRange\">;\n\n\t/**\n\t * gate the width amount\n\t */\n\tprivate _widthGate: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * the sawtooth oscillator\n\t */\n\tprivate _triangle: Oscillator;\n\n\t/**\n\t * The frequency control.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune in cents.\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * Threshold the signal to turn it into a square\n\t */\n\tprivate _thresh = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: val => val <= 0 ? -1 : 1,\n\t});\n\n\t/**\n\t * @param frequency The frequency of the oscillator\n\t * @param width The width of the pulse\n\t */\n\tconstructor(frequency?: Frequency, width?: AudioRange);\n\tconstructor(options?: Partial<PulseOscillatorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]));\n\t\tconst options = optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]);\n\n\t\tthis.width = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"audioRange\",\n\t\t\tvalue: options.width,\n\t\t});\n\n\t\tthis._triangle = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: \"triangle\",\n\t\t});\n\t\tthis.frequency = this._triangle.frequency;\n\t\tthis.detune = this._triangle.detune;\n\n\t\t// connections\n\t\tthis._triangle.chain(this._thresh, this.output);\n\t\tthis.width.chain(this._widthGate, this._thresh);\n\t\treadOnly(this, [\"width\", \"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): PulseOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tphase: 0,\n\t\t\ttype: \"pulse\" as \"pulse\",\n\t\t\twidth: 0.2,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._triangle.start(time);\n\t\tthis._widthGate.gain.setValueAtTime(1, time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._triangle.stop(time);\n\t\t// the width is still connected to the output.\n\t\t// that needs to be stopped also\n\t\tthis._widthGate.gain.cancelScheduledValues(time);\n\t\tthis._widthGate.gain.setValueAtTime(0, time);\n\t}\n\n\tprotected _restart(time: Seconds): void {\n\t\tthis._triangle.restart(time);\n\t\tthis._widthGate.gain.cancelScheduledValues(time);\n\t\tthis._widthGate.gain.setValueAtTime(1, time);\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._triangle.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._triangle.phase = phase;\n\t}\n\n\t/**\n\t * The type of the oscillator. Always returns \"pulse\".\n\t */\n\tget type(): \"pulse\" {\n\t\treturn \"pulse\";\n\t}\n\n\t/**\n\t * The baseType of the oscillator. Always returns \"pulse\".\n\t */\n\tget baseType(): \"pulse\" {\n\t\treturn \"pulse\";\n\t}\n\n\t/**\n\t * The partials of the waveform. Cannot set partials for this waveform type\n\t */\n\tget partials(): number[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * No partials for this waveform type.\n\t */\n\tget partialCount(): number {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * *Internal use* The carrier oscillator type is fed through the \n\t * waveshaper node to create the pulse. Using different carrier oscillators\n\t * changes oscillator's behavior. \n\t */\n\tset carrierType(type: \"triangle\" | \"sine\") {\n\t\tthis._triangle.type = type;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up method.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._triangle.dispose();\n\t\tthis.width.dispose();\n\t\tthis._widthGate.dispose();\n\t\tthis._thresh.dispose();\n\t\treturn this;\n\t}\n}\n","import { Cents, Degrees, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport {\n\tFatConstructorOptions, FatOscillatorOptions,\n\tgenerateWaveform, NonCustomOscillatorType, ToneOscillatorInterface, ToneOscillatorType\n} from \"./OscillatorInterface\";\nimport { assertRange } from \"../../core/util/Debug\";\n\nexport { FatOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * FatOscillator is an array of oscillators with detune spread between the oscillators\n * @example\n * const fatOsc = new Tone.FatOscillator(\"Ab3\", \"sawtooth\", 40).toDestination().start();\n * @category Source\n */\nexport class FatOscillator extends Source<FatOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"FatOscillator\";\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The array of oscillators\n\t */\n\tprivate _oscillators: Oscillator[] = [];\n\n\t/**\n\t * The total spread of the oscillators\n\t */\n\tprivate _spread: Cents;\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t * The phase of the oscillators\n\t */\n\tprivate _phase: Degrees;\n\n\t/**\n\t * The partials array\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t * The number of partials to use\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t * @param frequency The oscillator's frequency.\n\t * @param type The type of the oscillator.\n\t * @param spread The detune spread between the oscillators.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, spread?: Cents);\n\tconstructor(options?: Partial<FatConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]));\n\t\tconst options = optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\tthis._spread = options.spread;\n\t\tthis._type = options.type;\n\t\tthis._phase = options.phase;\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\n\t\t// set the count initially\n\t\tthis.count = options.count;\n\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): FatOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tcount: 3,\n\t\t\tspread: 20,\n\t\t\ttype: \"sawtooth\",\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.start(time));\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.stop(time));\n\t}\n\n\tprotected _restart(time: Seconds): void {\n\t\tthis._forEach(osc => osc.restart(time));\n\t}\n\n\t/**\n\t * Iterate over all of the oscillators\n\t */\n\tprivate _forEach(iterator: (osc: Oscillator, index: number) => void): void {\n\t\tfor (let i = 0; i < this._oscillators.length; i++) {\n\t\t\titerator(this._oscillators[i], i);\n\t\t}\n\t}\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._type = type;\n\t\tthis._forEach(osc => osc.type = type);\n\t}\n\n\t/**\n\t * The detune spread between the oscillators. If \"count\" is\n\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t * for a total detune spread of 40 cents.\n\t * @example\n\t * const fatOsc = new Tone.FatOscillator().toDestination().start();\n\t * fatOsc.spread = 70;\n\t */\n\tget spread(): Cents {\n\t\treturn this._spread;\n\t}\n\tset spread(spread: Cents) {\n\t\tthis._spread = spread;\n\t\tif (this._oscillators.length > 1) {\n\t\t\tconst start = -spread / 2;\n\t\t\tconst step = spread / (this._oscillators.length - 1);\n\t\t\tthis._forEach((osc, i) => osc.detune.value = start + step * i);\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators. Must be an integer greater than 1.\n\t * @example\n\t * const fatOsc = new Tone.FatOscillator(\"C#3\", \"sawtooth\").toDestination().start();\n\t * // use 4 sawtooth oscillators\n\t * fatOsc.count = 4;\n\t */\n\tget count(): number {\n\t\treturn this._oscillators.length;\n\t}\n\tset count(count: number) {\n\t\tassertRange(count, 1);\n\t\tif (this._oscillators.length !== count) {\n\t\t\t// dispose the previous oscillators\n\t\t\tthis._forEach(osc => osc.dispose());\n\t\t\tthis._oscillators = [];\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst osc = new Oscillator({\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tvolume: -6 - count * 1.1,\n\t\t\t\t\ttype: this._type as NonCustomOscillatorType,\n\t\t\t\t\tphase: this._phase + (i / count) * 360,\n\t\t\t\t\tpartialCount: this._partialCount,\n\t\t\t\t\tonstop: i === 0 ? () => this.onstop(this) : noOp,\n\t\t\t\t});\n\t\t\t\tif (this.type === \"custom\") {\n\t\t\t\t\tosc.partials = this._partials;\n\t\t\t\t}\n\t\t\t\tthis.frequency.connect(osc.frequency);\n\t\t\t\tthis.detune.connect(osc.detune);\n\t\t\t\tosc.detune.overridden = false;\n\t\t\t\tosc.connect(this.output);\n\t\t\t\tthis._oscillators[i] = osc;\n\t\t\t}\n\t\t\t// set the spread\n\t\t\tthis.spread = this._spread;\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._forEach(osc => osc.start());\n\t\t\t}\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._phase = phase;\n\t\tthis._forEach(osc => osc.phase = phase);\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn this._oscillators[0].baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._forEach(osc => osc.baseType = baseType);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._oscillators[0].partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._partials = partials;\n\t\tthis._partialCount = this._partials.length;\n\t\tif (partials.length) {\n\t\t\tthis._type = \"custom\";\n\t\t\tthis._forEach(osc => osc.partials = partials);\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._oscillators[0].partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._partialCount = partialCount;\n\t\tthis._forEach(osc => osc.partialCount = partialCount);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._forEach(osc => osc.dispose());\n\t\treturn this;\n\t}\n}\n","import { Degrees, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform, PWMOscillatorOptions, ToneOscillatorInterface } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\n\nexport { PWMOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * PWMOscillator modulates the width of a Tone.PulseOscillator\n * at the modulationFrequency. This has the effect of continuously\n * changing the timbre of the oscillator by altering the harmonics\n * generated.\n * @example\n * return Tone.Offline(() => {\n * \tconst pwm = new Tone.PWMOscillator(60, 0.3).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class PWMOscillator extends Source<PWMOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"PWMOscillator\";\n\n\treadonly sourceType = \"pwm\";\n\n\t/**\n\t * the pulse oscillator\n\t */\n\tprivate _pulse: PulseOscillator;\n\t/**\n\t * the modulator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t * Scale the oscillator so it doesn't go silent\n\t * at the extreme values.\n\t */\n\tprivate _scale: Multiply = new Multiply({\n\t\tcontext: this.context,\n\t\tvalue: 2,\n\t});\n\n\t/**\n\t * The frequency control.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune of the oscillator.\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The width modulation rate of the oscillator.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst osc = new Tone.PWMOscillator(20, 2).toDestination().start();\n\t * }, 0.1, 1);\n\t */\n\treadonly modulationFrequency: Signal<\"frequency\">;\n\n\t/**\n\t * @param {Frequency} frequency The starting frequency of the oscillator.\n\t * @param {Frequency} modulationFrequency The modulation frequency of the width of the pulse.\n\t */\n\tconstructor(frequency?: Frequency, modulationFrequency?: Frequency);\n\tconstructor(options?: Partial<PWMOscillatorOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]));\n\t\tconst options = optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]);\n\n\t\tthis._pulse = new PulseOscillator({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.modulationFrequency,\n\t\t});\n\t\t// change the pulse oscillator type\n\t\tthis._pulse.carrierType = \"sine\";\n\n\t\tthis.modulationFrequency = this._pulse.frequency;\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t});\n\n\t\tthis.frequency = this._modulator.frequency;\n\t\tthis.detune = this._modulator.detune;\n\n\t\t// connections\n\t\tthis._modulator.chain(this._scale, this._pulse.width);\n\t\tthis._pulse.connect(this.output);\n\t\treadOnly(this, [\"modulationFrequency\", \"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): PWMOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tmodulationFrequency: 0.4,\n\t\t\tphase: 0,\n\t\t\ttype: \"pwm\" as \"pwm\",\n\t\t});\n\t}\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._modulator.start(time);\n\t\tthis._pulse.start(time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._modulator.stop(time);\n\t\tthis._pulse.stop(time);\n\t}\n\n\t/**\n\t * restart the oscillator\n\t */\n\tprotected _restart(time: Seconds): void {\n\t\tthis._modulator.restart(time);\n\t\tthis._pulse.restart(time);\n\t}\n\n\t/**\n\t * The type of the oscillator. Always returns \"pwm\".\n\t */\n\tget type(): \"pwm\" {\n\t\treturn \"pwm\";\n\t}\n\n\t/**\n\t * The baseType of the oscillator. Always returns \"pwm\".\n\t */\n\tget baseType(): \"pwm\" {\n\t\treturn \"pwm\";\n\t}\n\n\t/**\n\t * The partials of the waveform. Cannot set partials for this waveform type\n\t */\n\tget partials(): number[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * No partials for this waveform type.\n\t */\n\tget partialCount(): number {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._modulator.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._modulator.phase = phase;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._pulse.dispose();\n\t\tthis._scale.dispose();\n\t\tthis._modulator.dispose();\n\t\treturn this;\n\t}\n}\n","import { Cents, Degrees, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport {\n\tgenerateWaveform,\n\tOmniOscillatorConstructorOptions, OmniOscillatorOptions,\n\tOmniOscillatorType, ToneOscillatorInterface, ToneOscillatorType\n} from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\n\nexport { OmniOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * All of the oscillator types that OmniOscillator can take on\n */\ntype AnyOscillator = Oscillator | PWMOscillator | PulseOscillator | FatOscillator | AMOscillator | FMOscillator;\n\n/**\n * All of the Oscillator constructor types mapped to their name.\n */\ninterface OmniOscillatorSource {\n\t\"fm\": FMOscillator;\n\t\"am\": AMOscillator;\n\t\"pwm\": PWMOscillator;\n\t\"pulse\": PulseOscillator;\n\t\"oscillator\": Oscillator;\n\t\"fat\": FatOscillator;\n}\n\n/**\n * The available oscillator types.\n */\nexport type OmniOscSourceType = keyof OmniOscillatorSource;\n\n// Conditional Types\ntype IsAmOrFmOscillator<Osc, Ret> = Osc extends AMOscillator ? Ret : Osc extends FMOscillator ? Ret : undefined;\ntype IsFatOscillator<Osc, Ret> = Osc extends FatOscillator ? Ret : undefined;\ntype IsPWMOscillator<Osc, Ret> = Osc extends PWMOscillator ? Ret : undefined;\ntype IsPulseOscillator<Osc, Ret> = Osc extends PulseOscillator ? Ret : undefined;\ntype IsFMOscillator<Osc, Ret> = Osc extends FMOscillator ? Ret : undefined;\n\ntype AnyOscillatorConstructor = new (...args: any[]) => AnyOscillator;\n\nconst OmniOscillatorSourceMap: {\n\t[key in OmniOscSourceType]: AnyOscillatorConstructor\n} = {\n\tam: AMOscillator,\n\tfat: FatOscillator,\n\tfm: FMOscillator,\n\toscillator: Oscillator,\n\tpulse: PulseOscillator,\n\tpwm: PWMOscillator,\n};\n\n/**\n * OmniOscillator aggregates all of the oscillator types into one. \n * @example\n * return Tone.Offline(() => {\n * \tconst omniOsc = new Tone.OmniOscillator(\"C#4\", \"pwm\").toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class OmniOscillator<OscType extends AnyOscillator>\n\textends Source<OmniOscillatorConstructorOptions>\n\timplements Omit<ToneOscillatorInterface, \"type\"> {\n\n\treadonly name: string = \"OmniOscillator\";\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The oscillator that can switch types\n\t */\n\tprivate _oscillator!: AnyOscillator;\n\n\t/**\n\t * the type of the oscillator source\n\t */\n\tprivate _sourceType!: OmniOscSourceType;\n\n\t/**\n\t * @param frequency The initial frequency of the oscillator.\n\t * @param type The type of the oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: OmniOscillatorType);\n\tconstructor(options?: Partial<OmniOscillatorConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\n\t\t// set the options\n\t\tthis.set(options);\n\t}\n\n\tstatic getDefaults(): OmniOscillatorOptions {\n\t\treturn Object.assign(\n\t\t\tOscillator.getDefaults(),\n\t\t\tFMOscillator.getDefaults(),\n\t\t\tAMOscillator.getDefaults(),\n\t\t\tFatOscillator.getDefaults(),\n\t\t\tPulseOscillator.getDefaults(),\n\t\t\tPWMOscillator.getDefaults(),\n\t\t);\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._oscillator.start(time);\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\tprotected _restart(time: Seconds): this {\n\t\tthis._oscillator.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n\t * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n\t * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n\t * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n\t * when it's not. \n\t * @example\n\t * const omniOsc = new Tone.OmniOscillator().toDestination().start();\n\t * omniOsc.type = \"pwm\";\n\t * // modulationFrequency is parameter which is available\n\t * // only when the type is \"pwm\".\n\t * omniOsc.modulationFrequency.value = 0.5;\n\t */\n\tget type(): OmniOscillatorType {\n\t\tlet prefix = \"\";\n\t\tif ([\"am\", \"fm\", \"fat\"].some(p => this._sourceType === p)) {\n\t\t\tprefix = this._sourceType;\n\t\t}\n\t\treturn prefix + this._oscillator.type as OmniOscillatorType;\n\t}\n\tset type(type) {\n\t\tif (type.substr(0, 2) === \"fm\") {\n\t\t\tthis._createNewOscillator(\"fm\");\n\t\t\tthis._oscillator = this._oscillator as FMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2) as ToneOscillatorType;\n\t\t} else if (type.substr(0, 2) === \"am\") {\n\t\t\tthis._createNewOscillator(\"am\");\n\t\t\tthis._oscillator = this._oscillator as AMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2) as ToneOscillatorType;\n\t\t} else if (type.substr(0, 3) === \"fat\") {\n\t\t\tthis._createNewOscillator(\"fat\");\n\t\t\tthis._oscillator = this._oscillator as FatOscillator;\n\t\t\tthis._oscillator.type = type.substr(3) as ToneOscillatorType;\n\t\t} else if (type === \"pwm\") {\n\t\t\tthis._createNewOscillator(\"pwm\");\n\t\t\tthis._oscillator = this._oscillator as PWMOscillator;\n\t\t} else if (type === \"pulse\") {\n\t\t\tthis._createNewOscillator(\"pulse\");\n\t\t} else {\n\t\t\tthis._createNewOscillator(\"oscillator\");\n\t\t\tthis._oscillator = this._oscillator as Oscillator;\n\t\t\tthis._oscillator.type = (type as ToneOscillatorType);\n\t\t}\n\t}\n\n\t/**\n\t * The value is an empty array when the type is not \"custom\".\n\t * This is not available on \"pwm\" and \"pulse\" oscillator types.\n\t * See [[Oscillator.partials]]\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillator.partials;\n\t}\n\tset partials(partials) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partials = partials;\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._oscillator.partialCount;\n\t}\n\tset partialCount(partialCount) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partialCount = partialCount;\n\t\t}\n\t}\n\n\tset(props: Partial<OmniOscillatorConstructorOptions>): this {\n\t\t// make sure the type is set first\n\t\tif (Reflect.has(props, \"type\") && props.type) {\n\t\t\tthis.type = props.type;\n\t\t}\n\t\t// then set the rest\n\t\tsuper.set(props);\n\t\treturn this;\n\t}\n\n\t/**\n\t * connect the oscillator to the frequency and detune signals\n\t */\n\tprivate _createNewOscillator(oscType: OmniOscSourceType): void {\n\t\tif (oscType !== this._sourceType) {\n\t\t\tthis._sourceType = oscType;\n\t\t\tconst OscConstructor = OmniOscillatorSourceMap[oscType];\n\t\t\t// short delay to avoid clicks on the change\n\t\t\tconst now = this.now();\n\t\t\tif (this._oscillator) {\n\t\t\t\tconst oldOsc = this._oscillator;\n\t\t\t\toldOsc.stop(now);\n\t\t\t\t// dispose the old one\n\t\t\t\tthis.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n\t\t\t}\n\t\t\tthis._oscillator = new OscConstructor({\n\t\t\t\tcontext: this.context,\n\t\t\t});\n\t\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\t\tthis.detune.connect(this._oscillator.detune);\n\t\t\tthis._oscillator.connect(this.output);\n\t\t\tthis._oscillator.onstop = () => this.onstop(this);\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._oscillator.start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._oscillator.phase;\n\t}\n\tset phase(phase) {\n\t\tthis._oscillator.phase = phase;\n\t}\n\n\t/**\n\t * The source type of the oscillator.\n\t * @example\n\t * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare\");\n\t * console.log(omniOsc.sourceType); // 'fm'\n\t */\n\tget sourceType(): OmniOscSourceType {\n\t\treturn this._sourceType;\n\t}\n\tset sourceType(sType) {\n\t\t// the basetype defaults to sine\n\t\tlet baseType = \"sine\";\n\t\tif (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n\t\t\tbaseType = this._oscillator.type;\n\t\t}\n\n\t\t// set the type\n\t\tif (sType === \"fm\") {\n\t\t\tthis.type = \"fm\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"am\") {\n\t\t\tthis.type = \"am\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"fat\") {\n\t\t\tthis.type = \"fat\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"oscillator\") {\n\t\t\tthis.type = baseType as OmniOscillatorType;\n\t\t} else if (sType === \"pulse\") {\n\t\t\tthis.type = \"pulse\";\n\t\t} else if (sType === \"pwm\") {\n\t\t\tthis.type = \"pwm\";\n\t\t}\n\t}\n\n\tprivate _getOscType<SourceType extends OmniOscSourceType>(\n\t\tosc: AnyOscillator,\n\t\tsourceType: SourceType,\n\t): osc is OmniOscillatorSource[SourceType] {\n\t\treturn osc instanceof OmniOscillatorSourceMap[sourceType];\n\t}\n\n\t/**\n\t * The base type of the oscillator. See [[Oscillator.baseType]]\n\t * @example\n\t * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare4\");\n\t * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);\n\t */\n\tget baseType(): OscillatorType | \"pwm\" | \"pulse\" {\n\t\treturn this._oscillator.baseType;\n\t}\n\tset baseType(baseType) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") &&\n\t\t\t!this._getOscType(this._oscillator, \"pwm\") &&\n\t\t\tbaseType !== \"pulse\" && baseType !== \"pwm\") {\n\t\t\tthis._oscillator.baseType = baseType;\n\t\t}\n\t}\n\n\t/**\n\t * The width of the oscillator when sourceType === \"pulse\".\n\t * See [[PWMOscillator.width]]\n\t */\n\tget width(): IsPulseOscillator<OscType, Signal<\"audioRange\">> {\n\t\tif (this._getOscType(this._oscillator, \"pulse\")) {\n\t\t\treturn this._oscillator.width as IsPulseOscillator<OscType, Signal<\"audioRange\">>;\n\t\t} else {\n\t\t\treturn undefined as IsPulseOscillator<OscType, Signal<\"audioRange\">>;\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators when sourceType === \"fat\".\n\t * See [[FatOscillator.count]]\n\t */\n\tget count(): IsFatOscillator<OscType, number> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.count as IsFatOscillator<OscType, number>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, number>;\n\t\t}\n\t}\n\tset count(count) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n\t\t\tthis._oscillator.count = count;\n\t\t}\n\t}\n\n\t/**\n\t * The detune spread between the oscillators when sourceType === \"fat\".\n\t * See [[FatOscillator.count]]\n\t */\n\tget spread(): IsFatOscillator<OscType, Cents> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.spread as IsFatOscillator<OscType, Cents>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, Cents>;\n\t\t}\n\t}\n\tset spread(spread) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n\t\t\tthis._oscillator.spread = spread;\n\t\t}\n\t}\n\n\t/**\n\t * The type of the modulator oscillator. Only if the oscillator is set to \"am\" or \"fm\" types. \n\t * See [[AMOscillator]] or [[FMOscillator]]\n\t */\n\tget modulationType(): IsAmOrFmOscillator<OscType, ToneOscillatorType> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.modulationType as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t}\n\t}\n\tset modulationType(mType) {\n\t\tif ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n\t\t\tthis._oscillator.modulationType = mType;\n\t\t}\n\t}\n\n\t/**\n\t * The modulation index when the sourceType === \"fm\"\n\t * See [[FMOscillator]].\n\t */\n\tget modulationIndex(): IsFMOscillator<OscType, Signal<\"positive\">> {\n\t\tif (this._getOscType(this._oscillator, \"fm\")) {\n\t\t\treturn this._oscillator.modulationIndex as IsFMOscillator<OscType, Signal<\"positive\">>;\n\t\t} else {\n\t\t\treturn undefined as IsFMOscillator<OscType, Signal<\"positive\">>;\n\t\t}\n\t}\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * See [[AMOscillator]] or [[FMOscillator]]\n\t */\n\tget harmonicity(): IsAmOrFmOscillator<OscType, Signal<\"positive\">> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.harmonicity as IsAmOrFmOscillator<OscType, Signal<\"positive\">>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, Signal<\"positive\">>;\n\t\t}\n\t}\n\n\t/**\n\t * The modulationFrequency Signal of the oscillator when sourceType === \"pwm\"\n\t * see [[PWMOscillator]]\n\t * @min 0.1\n\t * @max 5\n\t */\n\tget modulationFrequency(): IsPWMOscillator<OscType, Signal<\"frequency\">> {\n\t\tif (this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\treturn this._oscillator.modulationFrequency as IsPWMOscillator<OscType, Signal<\"frequency\">>;\n\t\t} else {\n\t\t\treturn undefined as IsPWMOscillator<OscType, Signal<\"frequency\">>;\n\t\t}\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis._oscillator.dispose();\n\t\treturn this;\n\t}\n}\n","import { connectSeries } from \"../core/context/ToneAudioNode\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Signal, SignalOptions } from \"./Signal\";\n\n/**\n * Add a signal and a number or two signals. When no value is\n * passed into the constructor, Tone.Add will sum input and `addend`\n * If a value is passed into the constructor, the it will be added to the input.\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst add = new Tone.Add(2).toDestination();\n * \tadd.addend.setValueAtTime(1, 0.2);\n * \tconst signal = new Tone.Signal(2);\n * \t// add a signal and a scalar\n * \tsignal.connect(add);\n * \tsignal.setValueAtTime(1, 0.1);\n * }, 0.5, 1);\n * @category Signal\n */\nexport class Add extends Signal {\n\n\toverride = false;\n\n\treadonly name: string = \"Add\";\n\n\t/**\n\t * the summing node\n\t */\n\tprivate _sum: Gain = new Gain({ context: this.context });\n\treadonly input = this._sum;\n\treadonly output = this._sum;\n\n\t/**\n\t * The value which is added to the input signal\n\t */\n\treadonly addend: Param<\"number\"> = this._param;\n\n\t/**\n\t * @param value If no value is provided, will sum the input and [[addend]].\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<SignalOptions<\"number\">>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Add.getDefaults(), arguments, [\"value\"])));\n\n\t\tconnectSeries(this._constantSource, this._sum);\n\t}\n\n\tstatic getDefaults(): SignalOptions<\"number\"> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sum.dispose();\n\t\treturn this;\n\t}\n}\n","import { InputNode, OutputNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Add } from \"./Add\";\nimport { Multiply } from \"./Multiply\";\nimport { SignalOperator } from \"./SignalOperator\";\n\nexport interface ScaleOptions extends ToneAudioNodeOptions {\n\tmin: number;\n\tmax: number;\n}\n\n/**\n * Performs a linear scaling on an input signal.\n * Scales a NormalRange input to between\n * outputMin and outputMax.\n *\n * @example\n * const scale = new Tone.Scale(50, 100);\n * const signal = new Tone.Signal(0.5).connect(scale);\n * // the output of scale equals 75\n * @category Signal\n */\nexport class Scale<Options extends ScaleOptions = ScaleOptions> extends SignalOperator<Options> {\n\n\treadonly name: string = \"Scale\";\n\n\tinput: InputNode;\n\toutput: OutputNode;\n\n\t/**\n\t * Hold the multiple\n\t */\n\tprotected _mult: Multiply;\n\n\t/**\n\t * Hold the adder\n\t */\n\tprotected _add: Add;\n\n\t/**\n\t * Private reference to the min value\n\t */\n\tprivate _min: number;\n\n\t/**\n\t * Private reference to the max value\n\t */\n\tprivate _max: number;\n\n\t/**\n\t * @param min The output value when the input is 0.\n\t * @param max The output value when the input is 1.\n\t */\n\tconstructor(min?: number, max?: number);\n\tconstructor(options?: Partial<ScaleOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Scale.getDefaults(), arguments, [\"min\", \"max\"])));\n\t\tconst options = optionsFromArguments(Scale.getDefaults(), arguments, [\"min\", \"max\"]);\n\n\t\tthis._mult = this.input = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.max - options.min,\n\t\t});\n\n\t\tthis._add = this.output = new Add({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.min,\n\t\t});\n\n\t\tthis._min = options.min;\n\t\tthis._max = options.max;\n\n\t\tthis.input.connect(this.output);\n\t}\n\n\tstatic getDefaults(): ScaleOptions {\n\t\treturn Object.assign(SignalOperator.getDefaults(), {\n\t\t\tmax: 1,\n\t\t\tmin: 0,\n\t\t});\n\t}\n\n\t/**\n\t * The minimum output value. This number is output when the value input value is 0.\n\t */\n\tget min(): number {\n\t\treturn this._min;\n\t}\n\tset min(min) {\n\t\tthis._min = min;\n\t\tthis._setRange();\n\t}\n\n\t/**\n\t * The maximum output value. This number is output when the value input value is 1.\n\t */\n\tget max(): number {\n\t\treturn this._max;\n\t}\n\tset max(max) {\n\t\tthis._max = max;\n\t\tthis._setRange();\n\t}\n\n\t/**\n\t * set the values\n\t */\n\tprivate _setRange(): void {\n\t\tthis._add.value = this._min;\n\t\tthis._mult.value = this._max - this._min;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._add.dispose();\n\t\tthis._mult.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { connect, disconnect, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { SignalOperator } from \"./SignalOperator\";\n\n/**\n * Tone.Zero outputs 0's at audio-rate. The reason this has to be\n * it's own class is that many browsers optimize out Tone.Signal\n * with a value of 0 and will not process nodes further down the graph.\n * @category Signal\n */\nexport class Zero extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"Zero\";\n\n\t/**\n\t * The gain node which connects the constant source to the output\n\t */\n\tprivate _gain = new Gain({ context: this.context });\n\n\t/**\n\t * Only outputs 0\n\t */\n\toutput = this._gain;\n\n\t/**\n\t * no input node\n\t */\n\tinput = undefined;\n\n\tconstructor(options?: Partial<ToneAudioNodeOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Zero.getDefaults(), arguments)));\n\t\tconnect(this.context.getConstant(0), this._gain);\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tdisconnect(this.context.getConstant(0), this._gain);\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Degrees, Frequency, NormalRange, Time, UnitName } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { BasicPlaybackState } from \"../../core/util/StateTimeline\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Scale } from \"../../signal/Scale\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { Zero } from \"../../signal/Zero\";\nimport { Oscillator, ToneOscillatorType } from \"./Oscillator\";\n\nexport interface LFOOptions extends ToneAudioNodeOptions {\n\ttype: ToneOscillatorType;\n\tmin: number;\n\tmax: number;\n\tphase: Degrees;\n\tfrequency: Frequency;\n\tamplitude: NormalRange;\n\tunits: UnitName;\n}\n\n/**\n * LFO stands for low frequency oscillator. LFO produces an output signal\n * which can be attached to an AudioParam or Tone.Signal\n * in order to modulate that parameter with an oscillator. The LFO can\n * also be synced to the transport to start/stop and change when the tempo changes.\n * @example\n * return Tone.Offline(() => {\n * \tconst lfo = new Tone.LFO(\"4n\", 400, 4000).start().toDestination();\n * }, 0.5, 1);\n * @category Source\n */\nexport class LFO extends ToneAudioNode<LFOOptions> {\n\n\treadonly name: string = \"LFO\";\n\n\t/**\n\t * The oscillator.\n\t */\n\tprivate _oscillator: Oscillator;\n\n\t/**\n\t * The gain of the output\n\t */\n\tprivate _amplitudeGain: Gain<\"normalRange\">;\n\n\t/**\n\t * The amplitude of the LFO, which controls the output range between\n\t * the min and max output. For example if the min is -10 and the max\n\t * is 10, setting the amplitude to 0.5 would make the LFO modulate\n\t * between -5 and 5.\n\t */\n\treadonly amplitude: Param<\"normalRange\">;\n\n\t/**\n\t * The signal which is output when the LFO is stopped\n\t */\n\tprivate _stoppedSignal: Signal<\"audioRange\">;\n\n\t/**\n\t * Just outputs zeros. This is used so that scaled signal is not\n\t * optimized to silence.\n\t */\n\tprivate _zeros: Zero;\n\n\t/**\n\t * The value that the LFO outputs when it's stopped\n\t */\n\tprivate _stoppedValue = 0;\n\n\t/**\n\t * Convert the oscillators audio range to an output between 0-1 so it can be scaled\n\t */\n\tprivate _a2g: AudioToGain;\n\n\t/**\n\t * Scales the final output to the min and max value\n\t */\n\tprivate _scaler: Scale;\n\n\t/**\n\t * The output of the LFO\n\t */\n\treadonly output: OutputNode;\n\n\t/**\n\t * There is no input node\n\t */\n\treadonly input: undefined;\n\n\t/**\n\t * A private placeholder for the units\n\t */\n\tprivate _units: UnitName = \"number\";\n\n\t/**\n\t * If the input value is converted using the [[units]]\n\t */\n\tconvert = true;\n\n\t/**\n\t * The frequency value of the LFO\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * @param frequency The frequency of the oscillation.\n\t * Typically, LFOs will be in the frequency range of 0.1 to 10 hertz.\n\t * @param min The minimum output value of the LFO.\n\t * @param max The maximum value of the LFO.\n\t */\n\tconstructor(frequency?: Frequency, min?: number, max?: number);\n\tconstructor(options?: Partial<LFOOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]));\n\t\tconst options = optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]);\n\n\t\t// @ts-ignore\n\t\tthis._oscillator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\ttype: options.type,\n\t\t});\n\t\tthis.frequency = this._oscillator.frequency;\n\n\t\tthis._amplitudeGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.amplitude,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\t\tthis.amplitude = this._amplitudeGain.gain;\n\t\tthis._stoppedSignal = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"audioRange\",\n\t\t\tvalue: 0,\n\t\t});\n\t\tthis._zeros = new Zero({ context: this.context });\n\t\tthis._a2g = new AudioToGain({ context: this.context });\n\t\tthis._scaler = this.output = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmax: options.max,\n\t\t\tmin: options.min,\n\t\t});\n\n\t\tthis.units = options.units;\n\t\tthis.min = options.min;\n\t\tthis.max = options.max;\n\n\t\t// connect it up\n\t\tthis._oscillator.chain(this._a2g, this._amplitudeGain, this._scaler);\n\t\tthis._zeros.connect(this._a2g);\n\t\tthis._stoppedSignal.connect(this._a2g);\n\t\treadOnly(this, [\"amplitude\", \"frequency\"]);\n\t\tthis.phase = options.phase;\n\t}\n\n\tstatic getDefaults(): LFOOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tamplitude: 1,\n\t\t\tfrequency: \"4n\",\n\t\t\tmax: 1,\n\t\t\tmin: 0,\n\t\t\tphase: 0,\n\t\t\ttype: \"sine\" as ToneOscillatorType,\n\t\t\tunits: \"number\" as UnitName,\n\t\t});\n\t}\n\n\t/**\n\t * Start the LFO.\n\t * @param time The time the LFO will start\n\t */\n\tstart(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._stoppedSignal.setValueAtTime(0, time);\n\t\tthis._oscillator.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the LFO.\n\t * @param  time The time the LFO will stop\n\t */\n\tstop(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._stoppedSignal.setValueAtTime(this._stoppedValue, time);\n\t\tthis._oscillator.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the start/stop/pause to the transport\n\t * and the frequency to the bpm of the transport\n\t * @example\n\t * const lfo = new Tone.LFO(\"8n\");\n\t * lfo.sync().start(0);\n\t * // the rate of the LFO will always be an eighth note, even as the tempo changes\n\t */\n\tsync(): this {\n\t\tthis._oscillator.sync();\n\t\tthis._oscillator.syncFrequency();\n\t\treturn this;\n\t}\n\n\t/**\n\t * unsync the LFO from transport control\n\t */\n\tunsync(): this {\n\t\tthis._oscillator.unsync();\n\t\tthis._oscillator.unsyncFrequency();\n\t\treturn this;\n\t}\n\n\t/**\n\t * The minimum output of the LFO.\n\t */\n\tget min(): number {\n\t\treturn this._toType(this._scaler.min);\n\t}\n\tset min(min) {\n\t\tmin = this._fromType(min);\n\t\tthis._scaler.min = min;\n\t}\n\n\t/**\n\t * The maximum output of the LFO.\n\t */\n\tget max(): number {\n\t\treturn this._toType(this._scaler.max);\n\t}\n\tset max(max) {\n\t\tmax = this._fromType(max);\n\t\tthis._scaler.max = max;\n\t}\n\n\t/**\n\t * The type of the oscillator: See [[Oscillator.type]]\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._oscillator.type;\n\t}\n\tset type(type) {\n\t\tthis._oscillator.type = type;\n\t\tthis._stoppedValue = this._oscillator.getInitialValue();\n\t\tthis._stoppedSignal.value = this._stoppedValue;\n\t}\n\n\t/**\n\t * The phase of the LFO.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._oscillator.phase;\n\t}\n\tset phase(phase) {\n\t\tthis._oscillator.phase = phase;\n\t\tthis._stoppedValue = this._oscillator.getInitialValue();\n\t\tthis._stoppedSignal.value = this._stoppedValue;\n\t}\n\n\t/**\n\t * The output units of the LFO.\n\t */\n\tget units(): UnitName {\n\t\treturn this._units;\n\t}\n\tset units(val) {\n\t\tconst currentMin = this.min;\n\t\tconst currentMax = this.max;\n\t\t// convert the min and the max\n\t\tthis._units = val;\n\t\tthis.min = currentMin;\n\t\tthis.max = currentMax;\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\" or \"stopped\".\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._oscillator.state;\n\t}\n\n\t/**\n\t * @param node the destination to connect to\n\t * @param outputNum the optional output number\n\t * @param inputNum the input number\n\t */\n\tconnect(node: InputNode, outputNum?: number, inputNum?: number): this {\n\t\tif (node instanceof Param || node instanceof Signal) {\n\t\t\tthis.convert = node.convert;\n\t\t\tthis.units = node.units;\n\t\t}\n\t\tconnectSignal(this, node, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Private methods borrowed from Param\n\t */\n\t// @ts-ignore\n\tprivate _fromType = Param.prototype._fromType;\n\t// @ts-ignore\n\tprivate _toType = Param.prototype._toType;\n\t// @ts-ignore\n\tprivate _is = Param.prototype._is;\n\t// @ts-ignore\n\tprivate _clampValue = Param.prototype._clampValue;\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._oscillator.dispose();\n\t\tthis._stoppedSignal.dispose();\n\t\tthis._zeros.dispose();\n\t\tthis._scaler.dispose();\n\t\tthis._a2g.dispose();\n\t\tthis._amplitudeGain.dispose();\n\t\tthis.amplitude.dispose();\n\t\treturn this;\n\t}\n}\n","import { assertRange } from \"./Debug\";\nimport { Time } from \"../type/Units\";\n\n/**\n * Assert that the number is in the given range.\n */\nexport function range(min: number, max = Infinity) {\n\tconst valueMap: WeakMap<any, number> = new WeakMap();\n\treturn function(target: any, propertyKey: string | symbol) {\n\t\tReflect.defineProperty(\n\t\t\ttarget,\n\t\t\tpropertyKey,\n\t\t\t{\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tget: function() {\n\t\t\t\t\treturn valueMap.get(this);\n\t\t\t\t},\n\t\t\t\tset: function(newValue: number) {\n\t\t\t\t\tassertRange(newValue, min, max);\n\t\t\t\t\tvalueMap.set(this, newValue);\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t};\n}\n\n/**\n * Convert the time to seconds and assert that the time is in between the two\n * values when being set.\n */\nexport function timeRange(min: number, max = Infinity) {\n\tconst valueMap: WeakMap<any, Time> = new WeakMap();\n\treturn function(target: any, propertyKey: string) {\n\t\tReflect.defineProperty(\n\t\t\ttarget,\n\t\t\tpropertyKey,\n\t\t\t{\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tget: function() {\n\t\t\t\t\treturn valueMap.get(this);\n\t\t\t\t},\n\t\t\t\tset: function(newValue: Time) {\n\t\t\t\t\tassertRange(this.toSeconds(newValue), min, max);\n\t\t\t\t\tvalueMap.set(this, newValue);\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t};\n}\n","import { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { Positive, Seconds, Time } from \"../../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isUndef } from \"../../core/util/TypeCheck\";\nimport { Source, SourceOptions } from \"../Source\";\nimport { ToneBufferSource } from \"./ToneBufferSource\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { timeRange } from \"../../core/util/Decorator\";\n\nexport interface PlayerOptions extends SourceOptions {\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n\tplaybackRate: Positive;\n\tloop: boolean;\n\tautostart: boolean;\n\tloopStart: Time;\n\tloopEnd: Time;\n\treverse: boolean;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\turl?: ToneAudioBuffer | string | AudioBuffer;\n}\n\n/**\n * Player is an audio file player with start, loop, and stop functions.\n * @example\n * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/gong_1.mp3\").toDestination();\n * // play as soon as the buffer is loaded\n * player.autostart = true;\n * @category Source\n */\nexport class Player extends Source<PlayerOptions> {\n\n\treadonly name: string = \"Player\";\n\n\t/**\n\t * If the file should play as soon\n\t * as the buffer is loaded.\n\t */\n\tautostart: boolean;\n\n\t/**\n\t * The buffer\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * if the buffer should loop once it's over\n\t */\n\tprivate _loop: boolean;\n\n\t/**\n\t * if 'loop' is true, the loop will start at this position\n\t */\n\tprivate _loopStart: Time;\n\n\t/**\n\t * if 'loop' is true, the loop will end at this position\n\t */\n\tprivate _loopEnd: Time;\n\n\t/**\n\t * the playback rate\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t * All of the active buffer source nodes\n\t */\n\tprivate _activeSources: Set<ToneBufferSource> = new Set();\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\t@timeRange(0)\n\tfadeIn: Time;\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\t@timeRange(0)\n\tfadeOut: Time;\n\n\t/**\n\t * @param url Either the AudioBuffer or the url from which to load the AudioBuffer\n\t * @param onload The function to invoke when the buffer is loaded.\n\t */\n\tconstructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);\n\tconstructor(options?: Partial<PlayerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tthis._buffer = new ToneAudioBuffer({\n\t\t\tonload: this._onload.bind(this, options.onload),\n\t\t\tonerror: options.onerror,\n\t\t\treverse: options.reverse,\n\t\t\turl: options.url,\n\t\t});\n\t\tthis.autostart = options.autostart;\n\t\tthis._loop = options.loop;\n\t\tthis._loopStart = options.loopStart;\n\t\tthis._loopEnd = options.loopEnd;\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.fadeIn = options.fadeIn;\n\t\tthis.fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): PlayerOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tautostart: false,\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tloop: false,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\tplaybackRate: 1,\n\t\t\treverse: false,\n\t\t});\n\t}\n\n\t/**\n\t * Load the audio file as an audio buffer.\n\t * Decodes the audio asynchronously and invokes\n\t * the callback once the audio buffer loads.\n\t * Note: this does not need to be called if a url\n\t * was passed in to the constructor. Only use this\n\t * if you want to manually load a new url.\n\t * @param url The url of the buffer to load. Filetype support depends on the browser.\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tawait this._buffer.load(url);\n\t\tthis._onload();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal callback when the buffer is loaded.\n\t */\n\tprivate _onload(callback: () => void = noOp): void {\n\t\tcallback();\n\t\tif (this.autostart) {\n\t\t\tthis.start();\n\t\t}\n\t}\n\n\t/**\n\t * Internal callback when the buffer is done playing.\n\t */\n\tprivate _onSourceEnd(source: ToneBufferSource): void {\n\t\t// invoke the onstop function\n\t\tthis.onstop(this);\n\n\t\t// delete the source from the active sources\n\t\tthis._activeSources.delete(source);\n\t\tif (this._activeSources.size === 0 && !this._synced &&\n\t\t\tthis._state.getValueAtTime(this.now()) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"stopped\", this.now());\n\t\t}\n\t}\n\n\t/**\n\t * Play the buffer at the given startTime. Optionally add an offset\n\t * and/or duration which will play the buffer from a position\n\t * within the buffer for the given duration.\n\t *\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tsuper.start(time, offset, duration);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal start method\n\t */\n\tprotected _start(startTime?: Time, offset?: Time, duration?: Time): void {\n\t\t// if it's a loop the default offset is the loopStart point\n\t\tif (this._loop) {\n\t\t\toffset = defaultArg(offset, this._loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\n\t\t// compute the values in seconds\n\t\tlet computedOffset = this.toSeconds(offset);\n\n\t\t// if it's synced, it should factor in the playback rate for computing the offset\n\t\tif (this._synced) {\n\t\t\tcomputedOffset *= this._playbackRate;\n\t\t}\n\n\t\t// compute the duration which is either the passed in duration of the buffer.duration - offset\n\t\tconst origDuration = duration;\n\t\tduration = defaultArg(duration, Math.max(this._buffer.duration - computedOffset, 0));\n\t\tlet computedDuration = this.toSeconds(duration);\n\n\t\t// scale it by the playback rate\n\t\tcomputedDuration = computedDuration / this._playbackRate;\n\n\t\t// get the start time\n\t\tstartTime = this.toSeconds(startTime);\n\n\t\t// make the source\n\t\tconst source = new ToneBufferSource({\n\t\t\turl: this._buffer,\n\t\t\tcontext: this.context,\n\t\t\tfadeIn: this.fadeIn,\n\t\t\tfadeOut: this.fadeOut,\n\t\t\tloop: this._loop,\n\t\t\tloopEnd: this._loopEnd,\n\t\t\tloopStart: this._loopStart,\n\t\t\tonended: this._onSourceEnd.bind(this),\n\t\t\tplaybackRate: this._playbackRate,\n\t\t}).connect(this.output);\n\n\t\t// set the looping properties\n\t\tif (!this._loop && !this._synced) {\n\t\t\t// cancel the previous stop\n\t\t\tthis._state.cancel(startTime + computedDuration);\n\t\t\t// if it's not looping, set the state change at the end of the sample\n\t\t\tthis._state.setStateAtTime(\"stopped\", startTime + computedDuration, {\n\t\t\t\timplicitEnd: true,\n\t\t\t});\n\t\t}\n\n\t\t// add it to the array of active sources\n\t\tthis._activeSources.add(source);\n\n\t\t// start it\n\t\tif (this._loop && isUndef(origDuration)) {\n\t\t\tsource.start(startTime, computedOffset);\n\t\t} else {\n\t\t\t// subtract the fade out time\n\t\t\tsource.start(startTime, computedOffset, computedDuration - this.toSeconds(this.fadeOut));\n\t\t}\n\t}\n\n\t/**\n\t * Stop playback.\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeSources.forEach(source => source.stop(computedTime));\n\t}\n\n\t/**\n\t * Stop and then restart the player from the beginning (or offset)\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, \n\t * \t\t\t\t\tit will default to the full length of the sample (minus any offset)\n\t */\n\trestart(time?: Seconds, offset?: Time, duration?: Time): this {\n\t\tsuper.restart(time, offset, duration);\n\t\treturn this;\n\t}\n\n\tprotected _restart(time?: Seconds, offset?: Time, duration?: Time): void {\n\t\tthis._stop(time);\n\t\tthis._start(time, offset, duration);\n\t}\n\n\t/**\n\t * Seek to a specific time in the player's buffer. If the\n\t * source is no longer playing at that time, it will stop.\n\t * @param offset The time to seek to.\n\t * @param when The time for the seek event to occur.\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/gurgling_theremin_1.mp3\", () => {\n\t * \tplayer.start();\n\t * \t// seek to the offset in 1 second from now\n\t * \tplayer.seek(0.4, \"+1\");\n\t * }).toDestination();\n\t */\n\tseek(offset: Time, when?: Time): this {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tconst computedOffset = this.toSeconds(offset);\n\t\t\t// if it's currently playing, stop it\n\t\t\tthis._stop(computedTime);\n\t\t\t// restart it at the given time\n\t\t\tthis._start(computedTime, computedOffset);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the loop start and end. Will only loop if loop is set to true.\n\t * @param loopStart The loop start time\n\t * @param loopEnd The loop end time\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/malevoices_aa2_F3.mp3\").toDestination();\n\t * // loop between the given points\n\t * player.setLoopPoints(0.2, 0.3);\n\t * player.loop = true;\n\t * player.autostart = true;\n\t */\n\tsetLoopPoints(loopStart: Time, loopEnd: Time): this {\n\t\tthis.loopStart = loopStart;\n\t\tthis.loopEnd = loopEnd;\n\t\treturn this;\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = loopStart;\n\t\tif (this.buffer.loaded) {\n\t\t\tassertRange(this.toSeconds(loopStart), 0, this.buffer.duration);\n\t\t}\n\t\t// get the current source\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loopStart = loopStart;\n\t\t});\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = loopEnd;\n\t\tif (this.buffer.loaded) {\n\t\t\tassertRange(this.toSeconds(loopEnd), 0, this.buffer.duration);\n\t\t}\n\t\t// get the current source\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loopEnd = loopEnd;\n\t\t});\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/breakbeat.mp3\").toDestination();\n\t * player.loop = true;\n\t * player.autostart = true;\n\t */\n\tget loop(): boolean {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\t// if no change, do nothing\n\t\tif (this._loop === loop) {\n\t\t\treturn;\n\t\t}\n\t\tthis._loop = loop;\n\t\t// set the loop of all of the sources\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loop = loop;\n\t\t});\n\t\tif (loop) {\n\t\t\t// remove the next stopEvent\n\t\t\tconst stopEvent = this._state.getNextState(\"stopped\", this.now());\n\t\t\tif (stopEvent) {\n\t\t\t\tthis._state.cancel(stopEvent.time);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Normal speed is 1. The pitch will change with the playback rate.\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/femalevoices_aa2_A5.mp3\").toDestination();\n\t * // play at 1/4 speed\n\t * player.playbackRate = 0.25;\n\t * // play as soon as the buffer is loaded\n\t * player.autostart = true;\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tconst now = this.now();\n\n\t\t// cancel the stop event since it's at a different time now\n\t\tconst stopEvent = this._state.getNextState(\"stopped\", now);\n\t\tif (stopEvent && stopEvent.implicitEnd) {\n\t\t\tthis._state.cancel(stopEvent.time);\n\t\t\tthis._activeSources.forEach(source => source.cancelStop());\n\t\t}\n\n\t\t// set all the sources\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.playbackRate.setValueAtTime(rate, now);\n\t\t});\n\t}\n\n\t/**\n\t * If the buffer should be reversed\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/chime_1.mp3\").toDestination();\n\t * player.autostart = true;\n\t * player.reverse = true;\n\t */\n\tget reverse(): boolean {\n\t\treturn this._buffer.reverse;\n\t}\n\tset reverse(rev) {\n\t\tthis._buffer.reverse = rev;\n\t}\n\n\t/**\n\t * If the buffer is loaded\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffer.loaded;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\t// disconnect all of the players\n\t\tthis._activeSources.forEach(source => source.dispose());\n\t\tthis._activeSources.clear();\n\t\tthis._buffer.dispose();\n\t\treturn this;\n\t}\n}\n","import { Volume } from \"../../component/channel/Volume\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { ToneAudioBuffers, ToneAudioBuffersUrlMap } from \"../../core/context/ToneAudioBuffers\";\nimport { OutputNode, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { Decibels, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { assert } from \"../../core/util/Debug\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { BasicPlaybackState } from \"../../core/util/StateTimeline\";\nimport { Source, SourceOptions } from \"../Source\";\nimport { Player } from \"./Player\";\n\nexport interface PlayersOptions extends SourceOptions {\n\turls: ToneAudioBuffersUrlMap;\n\tvolume: Decibels;\n\tmute: boolean;\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n\tbaseUrl: string;\n\tfadeIn: Time;\n\tfadeOut: Time;\n}\n\n/**\n * Players combines multiple [[Player]] objects.\n * @category Source\n */\nexport class Players extends ToneAudioNode<PlayersOptions> {\n\n\treadonly name: string = \"Players\";\n\n\t/**\n\t * The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The volume of the output in decibels.\n\t */\n\treadonly volume: Param<\"decibels\">;\n\n\t/**\n\t * The combined output of all of the players\n\t */\n\treadonly output: OutputNode;\n\n\t/**\n\t * Players has no input.\n\t */\n\treadonly input = undefined;\n\n\t/**\n\t * The container of all of the players\n\t */\n\tprivate _players: Map<string, Player> = new Map();\n\n\t/**\n\t * The container of all the buffers\n\t */\n\tprivate _buffers: ToneAudioBuffers;\n\n\t/**\n\t * private holder of the fadeIn time\n\t */\n\tprivate _fadeIn: Time;\n\n\t/**\n\t * private holder of the fadeOut time\n\t */\n\tprivate _fadeOut: Time;\n\n\t/**\n\t * @param urls An object mapping a name to a url.\n\t * @param onload The function to invoke when all buffers are loaded.\n\t */\n\tconstructor(urls?: ToneAudioBuffersUrlMap, onload?: () => void);\n\t/**\n\t * @param urls An object mapping a name to a url.\n\t * @param options The remaining options associated with the players\n\t */\n\tconstructor(urls?: ToneAudioBuffersUrlMap, options?: Partial<Omit<PlayersOptions, \"urls\">>);\n\tconstructor(options?: Partial<PlayersOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Players.getDefaults(), arguments, [\"urls\", \"onload\"], \"urls\"));\n\t\tconst options = optionsFromArguments(Players.getDefaults(), arguments, [\"urls\", \"onload\"], \"urls\");\n\n\t\t/**\n\t\t * The output volume node\n\t\t */\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis._buffers = new ToneAudioBuffers({\n\t\t\turls: options.urls, \n\t\t\tonload: options.onload, \n\t\t\tbaseUrl: options.baseUrl,\n\t\t\tonerror: options.onerror\n\t\t});\n\t\t// mute initially\n\t\tthis.mute = options.mute;\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): PlayersOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tbaseUrl: \"\",\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tmute: false,\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\turls: {},\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\t/**\n\t * The fadeIn time of the envelope applied to the source.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(fadeIn) {\n\t\tthis._fadeIn = fadeIn;\n\t\tthis._players.forEach(player => {\n\t\t\tplayer.fadeIn = fadeIn;\n\t\t});\n\t}\n\n\t/**\n\t * The fadeOut time of the each of the sources.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(fadeOut) {\n\t\tthis._fadeOut = fadeOut;\n\t\tthis._players.forEach(player => {\n\t\t\tplayer.fadeOut = fadeOut;\n\t\t});\n\t}\n\n\t/**\n\t * The state of the players object. Returns \"started\" if any of the players are playing.\n\t */\n\tget state(): BasicPlaybackState {\n\t\tconst playing = Array.from(this._players).some(([_, player]) => player.state === \"started\");\n\t\treturn playing ? \"started\" : \"stopped\";\n\t}\n\n\t/**\n\t * True if the buffers object has a buffer by that name.\n\t * @param name  The key or index of the buffer.\n\t */\n\thas(name: string): boolean {\n\t\treturn this._buffers.has(name);\n\t}\n\n\t/**\n\t * Get a player by name.\n\t * @param  name  The players name as defined in the constructor object or `add` method.\n\t */\n\tplayer(name: string): Player {\n\t\tassert(this.has(name), `No Player with the name ${name} exists on this object`);\n\t\tif (!this._players.has(name)) {\n\t\t\tconst player = new Player({\n\t\t\t\tcontext: this.context,\n\t\t\t\tfadeIn: this._fadeIn,\n\t\t\t\tfadeOut: this._fadeOut,\n\t\t\t\turl: this._buffers.get(name),\n\t\t\t}).connect(this.output);\n\t\t\tthis._players.set(name, player);\n\t\t}\n\t\treturn this._players.get(name) as Player;\n\t}\n\n\t/**\n\t * If all the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffers.loaded;\n\t}\n\n\t/**\n\t * Add a player by name and url to the Players\n\t * @param  name A unique name to give the player\n\t * @param  url  Either the url of the bufer or a buffer which will be added with the given name.\n\t * @param callback  The callback to invoke when the url is loaded.\n\t */\n\tadd(name: string, url: string | ToneAudioBuffer | AudioBuffer, callback?: () => void): this {\n\t\tassert(!this._buffers.has(name), \"A buffer with that name already exists on this object\");\n\t\tthis._buffers.add(name, url, callback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop all of the players at the given time\n\t * @param time The time to stop all of the players.\n\t */\n\tstopAll(time?: Time): this {\n\t\tthis._players.forEach(player => player.stop(time));\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._volume.dispose();\n\t\tthis.volume.dispose();\n\t\tthis._players.forEach(player => player.dispose());\n\t\tthis._buffers.dispose();\n\t\treturn this;\n\t}\n}\n","import { Source, SourceOptions } from \"../Source\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Clock } from \"../../core/clock/Clock\";\nimport { Cents, Positive, Seconds, Time } from \"../../core/type/Units\";\nimport { ToneBufferSource } from \"./ToneBufferSource\";\nimport { intervalToFrequencyRatio } from \"../../core/type/Conversions\";\nimport { assertRange } from \"../../core/util/Debug\";\n\ninterface GrainPlayerOptions extends SourceOptions {\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n\treverse: boolean;\n\turl?: ToneAudioBuffer | string | AudioBuffer;\n\toverlap: Seconds;\n\tgrainSize: Seconds;\n\tplaybackRate: Positive;\n\tdetune: Cents;\n\tloop: boolean;\n\tloopStart: Time;\n\tloopEnd: Time;\n}\n\n/**\n * GrainPlayer implements [granular synthesis](https://en.wikipedia.org/wiki/Granular_synthesis).\n * Granular Synthesis enables you to adjust pitch and playback rate independently. The grainSize is the\n * amount of time each small chunk of audio is played for and the overlap is the\n * amount of crossfading transition time between successive grains.\n * @category Source\n */\nexport class GrainPlayer extends Source<GrainPlayerOptions> {\n\n\treadonly name: string = \"GrainPlayer\";\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tbuffer: ToneAudioBuffer;\n\n\t/**\n\t * Create a repeating tick to schedule the grains.\n\t */\n\tprivate _clock: Clock;\n\n\t/**\n\t * Internal loopStart value\n\t */\n\tprivate _loopStart = 0;\n\n\t/**\n\t * Internal loopStart value\n\t */\n\tprivate _loopEnd = 0;\n\n\t/**\n\t * All of the currently playing BufferSources\n\t */\n\tprivate _activeSources: ToneBufferSource[] = [];\n\n\t/**\n\t * Internal reference to the playback rate\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t * Internal grain size reference;\n\t */\n\tprivate _grainSize: Seconds;\n\n\t/**\n\t * Internal overlap reference;\n\t */\n\tprivate _overlap: Seconds;\n\n\t/**\n\t * Adjust the pitch independently of the playbackRate.\n\t */\n\tdetune: Cents;\n\n\t/**\n\t * If the buffer should loop back to the loopStart when completed\n\t */\n\tloop: boolean;\n\n\t/**\n\t * @param url Either the AudioBuffer or the url from which to load the AudioBuffer\n\t * @param onload The function to invoke when the buffer is loaded.\n\t */\n\tconstructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);\n\tconstructor(options?: Partial<GrainPlayerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(GrainPlayer.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(GrainPlayer.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tthis.buffer = new ToneAudioBuffer({\n\t\t\tonload: options.onload,\n\t\t\tonerror: options.onerror,\n\t\t\treverse: options.reverse,\n\t\t\turl: options.url,\n\t\t});\n\t\tthis._clock = new Clock({\n\t\t\tcontext: this.context,\n\t\t\tcallback: this._tick.bind(this),\n\t\t\tfrequency: 1 / options.grainSize\n\t\t});\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis._grainSize = options.grainSize;\n\t\tthis._overlap = options.overlap;\n\t\tthis.detune = options.detune;\n\n\t\t// setup\n\t\tthis.overlap = options.overlap;\n\t\tthis.loop = options.loop;\n\t\tthis.playbackRate = options.playbackRate;\n\t\tthis.grainSize = options.grainSize;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis.reverse = options.reverse;\n\t\tthis._clock.on(\"stop\", this._onstop.bind(this));\n\t}\n\n\tstatic getDefaults(): GrainPlayerOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\toverlap: 0.1,\n\t\t\tgrainSize: 0.2,\n\t\t\tplaybackRate: 1,\n\t\t\tdetune: 0,\n\t\t\tloop: false,\n\t\t\tloopStart: 0,\n\t\t\tloopEnd: 0,\n\t\t\treverse: false\n\t\t});\n\t}\n\n\t/**\n\t * Internal start method\n\t */\n\tprotected _start(time?: Time, offset?: Time, duration?: Time): void {\n\t\toffset = defaultArg(offset, 0);\n\t\toffset = this.toSeconds(offset);\n\t\ttime = this.toSeconds(time);\n\n\t\tconst grainSize = 1 / this._clock.frequency.getValueAtTime(time);\n\t\tthis._clock.start(time, offset / grainSize);\n\n\t\tif (duration) {\n\t\t\tthis.stop(time + this.toSeconds(duration));\n\t\t}\n\t}\n\n\t/**\n\t * Stop and then restart the player from the beginning (or offset)\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, \n\t * \t\t\t\t\tit will default to the full length of the sample (minus any offset)\n\t */\n\trestart(time?: Seconds, offset?: Time, duration?: Time): this {\n\t\tsuper.restart(time, offset, duration);\n\t\treturn this;\n\t}\n\n\tprotected _restart(time?: Seconds, offset?: Time, duration?: Time): void {\n\t\tthis._stop(time);\n\t\tthis._start(time, offset, duration);\n\t}\n\n\t/**\n\t * Internal stop method\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tthis._clock.stop(time);\n\t}\n\n\t/**\n\t * Invoked when the clock is stopped\n\t */\n\tprivate _onstop(time: Seconds): void {\n\t\t// stop the players\n\t\tthis._activeSources.forEach((source) => {\n\t\t\tsource.fadeOut = 0;\n\t\t\tsource.stop(time);\n\t\t});\n\t\tthis.onstop(this);\n\t}\n\n\t/**\n\t * Invoked on each clock tick. scheduled a new grain at this time.\n\t */\n\tprivate _tick(time: Seconds): void {\n\t\t// check if it should stop looping\n\t\tconst ticks = this._clock.getTicksAtTime(time);\n\t\tconst offset = ticks * this._grainSize;\n\t\tthis.log(\"offset\", offset);\n\n\t\tif (!this.loop && offset > this.buffer.duration) {\n\t\t\tthis.stop(time);\n\t\t\treturn;\n\t\t}\n\n\t\t// at the beginning of the file, the fade in should be 0\n\t\tconst fadeIn = offset < this._overlap ? 0 : this._overlap;\n\n\t\t// create a buffer source\n\t\tconst source = new ToneBufferSource({\n\t\t\tcontext: this.context,\n\t\t\turl: this.buffer,\n\t\t\tfadeIn: fadeIn,\n\t\t\tfadeOut: this._overlap,\n\t\t\tloop: this.loop,\n\t\t\tloopStart: this._loopStart,\n\t\t\tloopEnd: this._loopEnd,\n\t\t\t// compute the playbackRate based on the detune\n\t\t\tplaybackRate: intervalToFrequencyRatio(this.detune / 100)\n\t\t}).connect(this.output);\n\n\t\tsource.start(time, this._grainSize * ticks);\n\t\tsource.stop(time + this._grainSize / this.playbackRate);\n\n\t\t// add it to the active sources\n\t\tthis._activeSources.push(source);\n\t\t// remove it when it's done\n\t\tsource.onended = () => {\n\t\t\tconst index = this._activeSources.indexOf(source);\n\t\t\tif (index !== -1) {\n\t\t\t\tthis._activeSources.splice(index, 1);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * The playback rate of the sample\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tassertRange(rate, 0.001);\n\t\tthis._playbackRate = rate;\n\t\tthis.grainSize = this._grainSize;\n\t}\n\n\t/**\n\t * The loop start time.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(time) {\n\t\tif (this.buffer.loaded) {\n\t\t\tassertRange(this.toSeconds(time), 0, this.buffer.duration);\n\t\t}\n\t\tthis._loopStart = this.toSeconds(time);\n\t}\n\n\t/**\n\t * The loop end time.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(time) {\n\t\tif (this.buffer.loaded) {\n\t\t\tassertRange(this.toSeconds(time), 0, this.buffer.duration);\n\t\t}\n\t\tthis._loopEnd = this.toSeconds(time);\n\t}\n\n\t/**\n\t * The direction the buffer should play in\n\t */\n\tget reverse() {\n\t\treturn this.buffer.reverse;\n\t}\n\n\tset reverse(rev) {\n\t\tthis.buffer.reverse = rev;\n\t}\n\n\t/**\n\t * The size of each chunk of audio that the\n\t * buffer is chopped into and played back at.\n\t */\n\tget grainSize(): Time {\n\t\treturn this._grainSize;\n\t}\n\tset grainSize(size) {\n\t\tthis._grainSize = this.toSeconds(size);\n\t\tthis._clock.frequency.setValueAtTime(this._playbackRate / this._grainSize, this.now());\n\t}\n\n\t/**\n\t * The duration of the cross-fade between successive grains.\n\t */\n\tget overlap(): Time {\n\t\treturn this._overlap;\n\t}\n\tset overlap(time) {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tassertRange(computedTime, 0);\n\t\tthis._overlap = computedTime;\n\t}\n\n\t/**\n\t * If all the buffer is loaded\n\t */\n\tget loaded(): boolean {\n\t\treturn this.buffer.loaded;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.buffer.dispose();\n\t\tthis._clock.dispose();\n\t\tthis._activeSources.forEach((source) => source.dispose());\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n * Return the absolute value of an incoming signal.\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst abs = new Tone.Abs().toDestination();\n * \tconst signal = new Tone.Signal(1);\n * \tsignal.rampTo(-1, 0.5);\n * \tsignal.connect(abs);\n * }, 0.5, 1);\n * @category Signal\n */\nexport class Abs extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"Abs\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _abs = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: val => {\n\t\t\tif (Math.abs(val) < 0.001) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn Math.abs(val);\n\t\t\t}\n\t\t},\n\t});\n\n\t/**\n\t * The AudioRange input [-1, 1]\n\t */\n\tinput = this._abs;\n\n\t/**\n\t * The output range [0, 1]\n\t */\n\toutput = this._abs;\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._abs.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n * GainToAudio converts an input in NormalRange [0,1] to AudioRange [-1,1].\n * See [[AudioToGain]].\n * @category Signal\n */\nexport class GainToAudio extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"GainToAudio\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _norm = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: x => Math.abs(x) * 2 - 1,\n\t});\n\n\t/**\n\t * The NormalRange input [0, 1]\n\t */\n\tinput = this._norm;\n\n\t/**\n\t * The AudioRange output [-1, 1]\n\t */\n\toutput = this._norm;\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._norm.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Multiply } from \"./Multiply\";\nimport { SignalOperator } from \"./SignalOperator\";\n\n/**\n * Negate the incoming signal. i.e. an input signal of 10 will output -10\n *\n * @example\n * const neg = new Tone.Negate();\n * const sig = new Tone.Signal(-2).connect(neg);\n * // output of neg is positive 2.\n * @category Signal\n */\nexport class Negate extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"Negate\";\n\n\t/**\n\t * negation is done by multiplying by -1\n\t */\n\tprivate _multiply: Multiply = new Multiply({\n\t\tcontext: this.context,\n\t\tvalue: -1,\n\t});\n\n\t/**\n\t * The input and output are equal to the multiply node\n\t */\n\tinput = this._multiply;\n\toutput = this._multiply;\n\n\t/**\n\t * clean up\n\t * @returns {Negate} this\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._multiply.dispose();\n\t\treturn this;\n\t}\n}\n","import { connectSeries } from \"../core/context/ToneAudioNode\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Negate } from \"../signal/Negate\";\nimport { Signal, SignalOptions } from \"../signal/Signal\";\n\n/**\n * Subtract the signal connected to the input is subtracted from the signal connected\n * The subtrahend.\n *\n * @example\n * // subtract a scalar from a signal\n * const sub = new Tone.Subtract(1);\n * const sig = new Tone.Signal(4).connect(sub);\n * // the output of sub is 3.\n * @example\n * // subtract two signals\n * const sub = new Tone.Subtract();\n * const sigA = new Tone.Signal(10);\n * const sigB = new Tone.Signal(2.5);\n * sigA.connect(sub);\n * sigB.connect(sub.subtrahend);\n * // output of sub is 7.5\n * @category Signal\n */\nexport class Subtract extends Signal {\n\n\toverride = false;\n\n\treadonly name: string = \"Subtract\";\n\n\t/**\n\t * the summing node\n\t */\n\tprivate _sum: Gain = new Gain({ context: this.context });\n\treadonly input: Gain = this._sum;\n\treadonly output: Gain = this._sum;\n\n\t/**\n\t * Negate the input of the second input before connecting it to the summing node.\n\t */\n\tprivate _neg: Negate = new Negate({ context: this.context });\n\n\t/**\n\t * The value which is subtracted from the main signal\n\t */\n\tsubtrahend: Param<\"number\"> = this._param;\n\n\t/**\n\t * @param value The value to subtract from the incoming signal. If the value\n\t *             is omitted, it will subtract the second signal from the first.\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<SignalOptions<\"number\">>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Subtract.getDefaults(), arguments, [\"value\"])));\n\n\t\tconnectSeries(this._constantSource, this._neg, this._sum);\n\t}\n\n\tstatic getDefaults(): SignalOptions<\"number\"> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._neg.dispose();\n\t\tthis._sum.dispose();\n\t\treturn this;\n\t}\n}\n","import { SignalOperator, SignalOperatorOptions } from \"./SignalOperator\";\nimport { Multiply } from \"./Multiply\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { WaveShaper } from \"./WaveShaper\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\n\nexport type GreaterThanZeroOptions = SignalOperatorOptions\n\n/**\n * GreaterThanZero outputs 1 when the input is strictly greater than zero\n * @example\n * return Tone.Offline(() => {\n * \tconst gt0 = new Tone.GreaterThanZero().toDestination();\n * \tconst sig = new Tone.Signal(0.5).connect(gt0);\n * \tsig.setValueAtTime(-1, 0.05);\n * }, 0.1, 1);\n */\nexport class GreaterThanZero extends SignalOperator<GreaterThanZeroOptions> {\n\n\treadonly name: string = \"GreaterThanZero\";\n\n\t/**\n\t * The waveshaper\n\t */\n\tprivate _thresh: WaveShaper;\n\n\t/**\n\t * Scale the first thresholded signal by a large value.\n\t * this will help with values which are very close to 0\n\t */\n\tprivate _scale: Multiply;\n\n\treadonly output: ToneAudioNode;\n\treadonly input: ToneAudioNode;\n\n\tconstructor(options?: Partial<GreaterThanZeroOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(GreaterThanZero.getDefaults(), arguments)));\n\n\t\tthis._thresh = this.output = new WaveShaper({\n\t\t\tcontext: this.context,\n\t\t\tlength: 127,\n\t\t\tmapping: (val) => {\n\t\t\t\tif (val <= 0) {\n\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t\tthis._scale = this.input = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: 10000\n\t\t});\n\n\t\t// connections\n\t\tthis._scale.connect(this._thresh);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._scale.dispose();\n\t\tthis._thresh.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Subtract } from \"./Subtract\";\nimport { Signal, SignalOptions } from \"./Signal\";\nimport { GreaterThanZero } from \"./GreaterThanZero\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Param } from \"../core/context/Param\";\n\nexport type GreaterThanOptions = SignalOptions<\"number\">;\n\n/**\n * Output 1 if the signal is greater than the value, otherwise outputs 0.\n * can compare two signals or a signal and a number.\n * \n * @example\n * return Tone.Offline(() => {\n * \tconst gt = new Tone.GreaterThan(2).toDestination();\n * \tconst sig = new Tone.Signal(4).connect(gt);\n * }, 0.1, 1);\n */\nexport class GreaterThan extends Signal<\"number\"> {\n\n\treadonly name: string = \"GreaterThan\"\n\n\treadonly override: boolean = false;\n\n\treadonly input: ToneAudioNode;\n\treadonly output: ToneAudioNode;\n\n\t/**\n\t * compare that amount to zero after subtracting\n\t */\n\tprivate _gtz: GreaterThanZero;\n\n\t/**\n\t * Subtract the value from the input node\n\t */\n\tprivate _subtract: Subtract;\n\n\t/**\n\t * The signal to compare to the incoming signal against.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \t// change the comparison value\n\t * \tconst gt = new Tone.GreaterThan(1.5).toDestination();\n\t * \tconst signal = new Tone.Signal(1).connect(gt);\n\t * \tgt.comparator.setValueAtTime(0.5, 0.1);\n\t * }, 0.5, 1);\n\t */\n\treadonly comparator: Param<\"number\">\n\n\t/**\n\t * @param value The value to compare to\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<GreaterThanOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(GreaterThan.getDefaults(), arguments, [\"value\"])));\n\t\tconst options = optionsFromArguments(GreaterThan.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis._subtract = this.input = new Subtract({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.value\n\t\t});\n\t\tthis._gtz = this.output = new GreaterThanZero({ context: this.context });\n\n\t\tthis.comparator = this._param = this._subtract.subtrahend;\n\t\treadOnly(this, \"comparator\");\n\n\t\t// connect\n\t\tthis._subtract.connect(this._gtz);\n\t}\n\n\tstatic getDefaults(): GreaterThanOptions {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gtz.dispose();\n\t\tthis._subtract.dispose();\n\t\tthis.comparator.dispose();\n\t\treturn this;\n\t}\n}\n","import { WaveShaper, WaveShaperMappingFn } from \"./WaveShaper\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\n\nexport interface PowOptions extends ToneAudioNodeOptions {\n\tvalue: number;\n}\n\n/**\n * Pow applies an exponent to the incoming signal. The incoming signal must be AudioRange [-1, 1]\n *\n * @example\n * const pow = new Tone.Pow(2);\n * const sig = new Tone.Signal(0.5).connect(pow);\n * // output of pow is 0.25. \n * @category Signal\n */\nexport class Pow extends SignalOperator<PowOptions> {\n\n\treadonly name: string = \"Pow\";\n\n\tprivate _exponent: number;\n\n\tprivate _exponentScaler: WaveShaper;\n\n\tinput: WaveShaper;\n\n\toutput: WaveShaper;\n\n\t/**\n\t * @param value Constant exponent value to use\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<PowOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Pow.getDefaults(), arguments, [\"value\"])));\n\t\tconst options = optionsFromArguments(Pow.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis._exponentScaler = this.input = this.output = new WaveShaper({\n\t\t\tcontext: this.context,\n\t\t\tmapping: this._expFunc(options.value),\n\t\t\tlength: 8192,\n\t\t});\n\n\t\tthis._exponent = options.value;\n\t}\n\n\tstatic getDefaults(): PowOptions {\n\t\treturn Object.assign(SignalOperator.getDefaults(), {\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\t/**\n\t * the function which maps the waveshaper\n\t * @param exponent exponent value\n\t */\n\tprivate _expFunc(exponent: number): WaveShaperMappingFn {\n\t\treturn (val: number) => {\n\t\t\treturn Math.pow(Math.abs(val), exponent);\n\t\t};\n\t}\n\n\t/**\n\t * The value of the exponent.\n\t */\n\tget value(): number {\n\t\treturn this._exponent;\n\t}\n\tset value(exponent: number) {\n\t\tthis._exponent = exponent;\n\t\tthis._exponentScaler.setMap(this._expFunc(this._exponent));\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._exponentScaler.dispose();\n\t\treturn this;\n\t}\n}\n","import { Scale, ScaleOptions } from \"./Scale\";\nimport { Positive } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Pow } from \"./Pow\";\n\nexport interface ScaleExpOptions extends ScaleOptions {\n\texponent: Positive;\n}\n\n/**\n * Performs an exponential scaling on an input signal.\n * Scales a NormalRange value [0,1] exponentially\n * to the output range of outputMin to outputMax.\n * @example\n * const scaleExp = new Tone.ScaleExp(0, 100, 2);\n * const signal = new Tone.Signal(0.5).connect(scaleExp);\n */\nexport class ScaleExp extends Scale<ScaleExpOptions> {\n\n\treadonly name: string = \"ScaleExp\";\n\n\t/**\n\t * The exponent scaler\n\t */\n\tprivate _exp: Pow;\n\n\t/**\n\t * @param min The output value when the input is 0.\n\t * @param max The output value when the input is 1.\n\t * @param exponent The exponent which scales the incoming signal.\n\t */\n\tconstructor(min?: number, max?: number, exponent?: number);\n\tconstructor(options?: Partial<ScaleExpOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(ScaleExp.getDefaults(), arguments, [\"min\", \"max\", \"exponent\"])));\n\t\tconst options = optionsFromArguments(ScaleExp.getDefaults(), arguments, [\"min\", \"max\", \"exponent\"]);\n\n\t\tthis.input = this._exp = new Pow({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.exponent,\n\t\t});\n\t\tthis._exp.connect(this._mult);\n\t}\n\n\tstatic getDefaults(): ScaleExpOptions {\n\t\treturn Object.assign(Scale.getDefaults(), {\n\t\t\texponent: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Instead of interpolating linearly between the [[min]] and\n\t * [[max]] values, setting the exponent will interpolate between\n\t * the two values with an exponential curve.\n\t */\n\tget exponent(): Positive {\n\t\treturn this._exp.value;\n\t}\n\tset exponent(exp) {\n\t\tthis._exp.value = exp;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._exp.dispose();\n\t\treturn this;\n\t}\n}\n","import { Signal, SignalOptions } from \"./Signal\";\nimport { NormalRange, Seconds, Time, TransportTime, UnitMap, UnitName } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { ToneConstantSource } from \"./ToneConstantSource\";\nimport { OutputNode } from \"../core/context/ToneAudioNode\";\n\n/**\n * Adds the ability to synchronize the signal to the [[Transport]]\n */\nexport class SyncedSignal<TypeName extends UnitName = \"number\"> extends Signal<TypeName> {\n\n\treadonly name: string = \"SyncedSignal\";\n\t\n\t/**\n\t * Don't override when something is connected to the input\n\t */\n\treadonly override = false;\n\n\treadonly output: OutputNode;\n\n\t/**\n\t * Keep track of the last value as an optimization.\n\t */\n\tprivate _lastVal: UnitMap[TypeName];\n\n\t/**\n\t * The ID returned from scheduleRepeat\n\t */\n\tprivate _synced: number;\n\n\t/**\n\t * Remember the callback value\n\t */\n\tprivate _syncedCallback: () => void;\n\n\t/**\n\t * @param value Initial value of the signal\n\t * @param units The unit name, e.g. \"frequency\"\n\t */\n\tconstructor(value?: UnitMap[TypeName], units?: TypeName);\n\tconstructor(options?: Partial<SignalOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n\t\tconst options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]) as SignalOptions<TypeName>;\n\n\t\tthis._lastVal = options.value;\n\t\tthis._synced = this.context.transport.scheduleRepeat(this._onTick.bind(this), \"1i\");\n\n\t\tthis._syncedCallback = this._anchorValue.bind(this);\n\t\tthis.context.transport.on(\"start\", this._syncedCallback);\n\t\tthis.context.transport.on(\"pause\", this._syncedCallback);\n\t\tthis.context.transport.on(\"stop\", this._syncedCallback);\n\n\t\t// disconnect the constant source from the output and replace it with another one\n\t\tthis._constantSource.disconnect();\n\t\tthis._constantSource.stop(0);\n\n\t\t// create a new one\n\t\tthis._constantSource = this.output = new ToneConstantSource<TypeName>({ \n\t\t\tcontext: this.context,\n\t\t\toffset: options.value,\n\t\t\tunits: options.units,\n\t\t}).start(0);\n\t\tthis.setValueAtTime(options.value, 0);\n\t}\n\n\t/**\n\t * Callback which is invoked every tick.\n\t */\n\tprivate _onTick(time: Seconds): void {\n\t\tconst val = super.getValueAtTime(this.context.transport.seconds);\n\t\t// approximate ramp curves with linear ramps\n\t\tif (this._lastVal !== val) {\n\t\t\tthis._lastVal = val;\n\t\t\tthis._constantSource.offset.setValueAtTime(val, time);\n\t\t}\n\t}\n\n\t/**\n\t * Anchor the value at the start and stop of the Transport\n\t */\n\tprivate _anchorValue(time: Seconds): void {\n\t\tconst val = super.getValueAtTime(this.context.transport.seconds);\n\t\tthis._lastVal = val;\n\t\tthis._constantSource.offset.cancelAndHoldAtTime(time);\n\t\tthis._constantSource.offset.setValueAtTime(val, time);\n\t}\n\n\tgetValueAtTime(time: TransportTime): UnitMap[TypeName] {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\treturn super.getValueAtTime(computedTime);\n\t}\n\t\n\tsetValueAtTime(value: UnitMap[TypeName], time: TransportTime) {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.setValueAtTime(value, computedTime);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], time: TransportTime) {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.linearRampToValueAtTime(value, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], time: TransportTime) {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.exponentialRampToValueAtTime(value, computedTime);\n\t\treturn this;\n\t}\n\n\tsetTargetAtTime(value, startTime: TransportTime, timeConstant: number): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.setTargetAtTime(value, computedTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(startTime: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.cancelScheduledValues(computedTime);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(values: UnitMap[TypeName][], startTime: TransportTime, duration: Time, scaling: NormalRange): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tduration = this.toSeconds(duration);\n\t\tsuper.setValueCurveAtTime(values, computedTime, duration, scaling);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.cancelAndHoldAtTime(computedTime);\n\t\treturn this;\n\t}\n\t\n\tsetRampPoint(time: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.setRampPoint(computedTime);\n\t\treturn this;\n\t}\n\t\n\texponentialRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.exponentialRampTo(value, rampTime, computedTime);\n\t\treturn this;\n\t}\n\t\n\tlinearRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.linearRampTo(value, rampTime, computedTime);\n\t\treturn this;\n\t}\n\n\ttargetRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.targetRampTo(value, rampTime, computedTime);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.context.transport.clear(this._synced);\n\t\tthis.context.transport.off(\"start\", this._syncedCallback);\n\t\tthis.context.transport.off(\"pause\", this._syncedCallback);\n\t\tthis.context.transport.off(\"stop\", this._syncedCallback);\n\t\tthis._constantSource.dispose();\n\t\treturn this;\n\t}\n}\n","import { InputNode, OutputNode } from \"../../core/context/ToneAudioNode\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\nimport { assert } from \"../../core/util/Debug\";\nimport { range, timeRange } from \"../../core/util/Decorator\";\n\ntype BasicEnvelopeCurve = \"linear\" | \"exponential\";\ntype InternalEnvelopeCurve = BasicEnvelopeCurve | number[];\nexport type EnvelopeCurve = EnvelopeCurveName | number[];\n\nexport interface EnvelopeOptions extends ToneAudioNodeOptions {\n\tattack: Time;\n\tdecay: Time;\n\tsustain: NormalRange;\n\trelease: Time;\n\tattackCurve: EnvelopeCurve;\n\treleaseCurve: EnvelopeCurve;\n\tdecayCurve: BasicEnvelopeCurve;\n}\n\n/**\n * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n * envelope generator. Envelope outputs a signal which\n * can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst env = new Tone.Envelope({\n * \t\tattack: 0.1,\n * \t\tdecay: 0.2,\n * \t\tsustain: 0.5,\n * \t\trelease: 0.8,\n * \t}).toDestination();\n * \tenv.triggerAttackRelease(0.5);\n * }, 1.5, 1);\n * @category Component\n */\nexport class Envelope extends ToneAudioNode<EnvelopeOptions> {\n\n\treadonly name: string = \"Envelope\";\n\n\t/**\n\t * When triggerAttack is called, the attack time is the amount of\n\t * time it takes for the envelope to reach it's maximum value.\n\t * ```\n\t *           /\\\n\t *          /X \\\n\t *         /XX  \\\n\t *        /XXX   \\\n\t *       /XXXX    \\___________\n\t *      /XXXXX                \\\n\t *     /XXXXXX                 \\\n\t *    /XXXXXXX                  \\\n\t *   /XXXXXXXX                   \\\n\t * ```\n\t * @min 0\n\t * @max 2\n\t */\n\t@timeRange(0)\n\tattack: Time;\n\n\t/**\n\t * After the attack portion of the envelope, the value will fall\n\t * over the duration of the decay time to it's sustain value.\n\t * ```\n\t *           /\\\n\t *          / X\\\n\t *         /  XX\\\n\t *        /   XXX\\\n\t *       /    XXXX\\___________\n\t *      /     XXXXX           \\\n\t *     /      XXXXX            \\\n\t *    /       XXXXX             \\\n\t *   /        XXXXX              \\\n\t * ```\n\t * @min 0\n\t * @max 2\n\t */\n\t@timeRange(0)\n\tdecay: Time;\n\n\t/**\n\t * The sustain value is the value\n\t * which the envelope rests at after triggerAttack is\n\t * called, but before triggerRelease is invoked.\n\t * ```\n\t *           /\\\n\t *          /  \\\n\t *         /    \\\n\t *        /      \\\n\t *       /        \\___________\n\t *      /          XXXXXXXXXXX\\\n\t *     /           XXXXXXXXXXX \\\n\t *    /            XXXXXXXXXXX  \\\n\t *   /             XXXXXXXXXXX   \\\n\t * ```\n\t */\n\t@range(0, 1)\n\tsustain: NormalRange;\n\n\t/**\n\t * After triggerRelease is called, the envelope's\n\t * value will fall to it's miminum value over the\n\t * duration of the release time.\n\t * ```\n\t *           /\\\n\t *          /  \\\n\t *         /    \\\n\t *        /      \\\n\t *       /        \\___________\n\t *      /                    X\\\n\t *     /                     XX\\\n\t *    /                      XXX\\\n\t *   /                       XXXX\\\n\t * ```\n\t * @min 0\n\t * @max 5\n\t */\n\t@timeRange(0)\n\trelease: Time;\n\n\t/**\n\t * The automation curve type for the attack\n\t */\n\tprivate _attackCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t * The automation curve type for the decay\n\t */\n\tprivate _decayCurve!: BasicEnvelopeCurve;\n\n\t/**\n\t * The automation curve type for the release\n\t */\n\tprivate _releaseCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t * the signal which is output.\n\t */\n\tprotected _sig: Signal<\"normalRange\"> = new Signal({\n\t\tcontext: this.context,\n\t\tvalue: 0,\n\t});\n\n\t/**\n\t * The output signal of the envelope\n\t */\n\toutput: OutputNode = this._sig;\n\n\t/**\n\t * Envelope has no input\n\t */\n\tinput: InputNode | undefined = undefined;\n\n\t/**\n\t * @param attack The amount of time it takes for the envelope to go from\n\t *                        0 to it's maximum value.\n\t * @param decay\tThe period of time after the attack that it takes for the envelope\n\t *                      \tto fall to the sustain value. Value must be greater than 0.\n\t * @param sustain\tThe percent of the maximum value that the envelope rests at until\n\t *                               \tthe release is triggered.\n\t * @param release\tThe amount of time after the release is triggered it takes to reach 0.\n\t *                        \tValue must be greater than 0.\n\t */\n\tconstructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);\n\tconstructor(options?: Partial<EnvelopeOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n\t\tconst options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n\n\t\tthis.attack = options.attack;\n\t\tthis.decay = options.decay;\n\t\tthis.sustain = options.sustain;\n\t\tthis.release = options.release;\n\t\tthis.attackCurve = options.attackCurve;\n\t\tthis.releaseCurve = options.releaseCurve;\n\t\tthis.decayCurve = options.decayCurve;\n\t}\n\n\tstatic getDefaults(): EnvelopeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tattack: 0.01,\n\t\t\tattackCurve: \"linear\" as EnvelopeCurveName,\n\t\t\tdecay: 0.1,\n\t\t\tdecayCurve: \"exponential\" as BasicEnvelopeCurve,\n\t\t\trelease: 1,\n\t\t\treleaseCurve: \"exponential\" as EnvelopeCurveName,\n\t\t\tsustain: 0.5,\n\t\t});\n\t}\n\n\t/**\n\t * Read the current value of the envelope. Useful for\n\t * synchronizing visual output to the envelope.\n\t */\n\tget value(): NormalRange {\n\t\treturn this.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t * Get the curve\n\t * @param  curve\n\t * @param  direction  In/Out\n\t * @return The curve name\n\t */\n\tprivate _getCurve(curve: InternalEnvelopeCurve, direction: EnvelopeDirection): EnvelopeCurve {\n\t\tif (isString(curve)) {\n\t\t\treturn curve;\n\t\t} else {\n\t\t\t// look up the name in the curves array\n\t\t\tlet curveName: EnvelopeCurveName;\n\t\t\tfor (curveName in EnvelopeCurves) {\n\t\t\t\tif (EnvelopeCurves[curveName][direction] === curve) {\n\t\t\t\t\treturn curveName;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// return the custom curve\n\t\t\treturn curve;\n\t\t}\n\t}\n\n\t/**\n\t * Assign a the curve to the given name using the direction\n\t * @param  name\n\t * @param  direction In/Out\n\t * @param  curve\n\t */\n\tprivate _setCurve(\n\t\tname: \"_attackCurve\" | \"_decayCurve\" | \"_releaseCurve\",\n\t\tdirection: EnvelopeDirection,\n\t\tcurve: EnvelopeCurve,\n\t): void {\n\t\t// check if it's a valid type\n\t\tif (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n\t\t\tconst curveDef = EnvelopeCurves[curve];\n\t\t\tif (isObject(curveDef)) {\n\t\t\t\tif (name !== \"_decayCurve\") {\n\t\t\t\t\tthis[name] = curveDef[direction];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis[name] = curveDef;\n\t\t\t}\n\t\t} else if (isArray(curve) && name !== \"_decayCurve\") {\n\t\t\tthis[name] = curve;\n\t\t} else {\n\t\t\tthrow new Error(\"Envelope: invalid curve: \" + curve);\n\t\t}\n\t}\n\n\t/**\n\t * The shape of the attack.\n\t * Can be any of these strings:\n\t * * \"linear\"\n\t * * \"exponential\"\n\t * * \"sine\"\n\t * * \"cosine\"\n\t * * \"bounce\"\n\t * * \"ripple\"\n\t * * \"step\"\n\t *\n\t * Can also be an array which describes the curve. Values\n\t * in the array are evenly subdivided and linearly\n\t * interpolated over the duration of the attack.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst env = new Tone.Envelope(0.4).toDestination();\n\t * \tenv.attackCurve = \"linear\";\n\t * \tenv.triggerAttack();\n\t * }, 1, 1);\n\t */\n\tget attackCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._attackCurve, \"In\");\n\t}\n\tset attackCurve(curve) {\n\t\tthis._setCurve(\"_attackCurve\", \"In\", curve);\n\t}\n\n\t/**\n\t * The shape of the release. See the attack curve types.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst env = new Tone.Envelope({\n\t * \t\trelease: 0.8\n\t * \t}).toDestination();\n\t * \tenv.triggerAttack();\n\t * \t// release curve could also be defined by an array\n\t * \tenv.releaseCurve = [1, 0.3, 0.4, 0.2, 0.7, 0];\n\t * \tenv.triggerRelease(0.2);\n\t * }, 1, 1);\n\t */\n\tget releaseCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._releaseCurve, \"Out\");\n\t}\n\tset releaseCurve(curve) {\n\t\tthis._setCurve(\"_releaseCurve\", \"Out\", curve);\n\t}\n\n\t/**\n\t * The shape of the decay either \"linear\" or \"exponential\"\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst env = new Tone.Envelope({\n\t * \t\tsustain: 0.1,\n\t * \t\tdecay: 0.5\n\t * \t}).toDestination();\n\t * \tenv.decayCurve = \"linear\";\n\t * \tenv.triggerAttack();\n\t * }, 1, 1);\n\t */\n\tget decayCurve(): BasicEnvelopeCurve {\n\t\treturn this._decayCurve;\n\t}\n\tset decayCurve(curve) {\n\t\tassert([\"linear\", \"exponential\"].some(c => c === curve), `Invalid envelope curve: ${curve}`);\n\t\tthis._decayCurve = curve;\n\t}\n\n\t/**\n\t * Trigger the attack/decay portion of the ADSR envelope.\n\t * @param  time When the attack should start.\n\t * @param velocity The velocity of the envelope scales the vales.\n\t *                             number between 0-1\n\t * @example\n\t * const env = new Tone.AmplitudeEnvelope().toDestination();\n\t * const osc = new Tone.Oscillator().connect(env).start();\n\t * // trigger the attack 0.5 seconds from now with a velocity of 0.2\n\t * env.triggerAttack(\"+0.5\", 0.2);\n\t */\n\ttriggerAttack(time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", time, velocity);\n\t\ttime = this.toSeconds(time);\n\t\tconst originalAttack = this.toSeconds(this.attack);\n\t\tlet attack = originalAttack;\n\t\tconst decay = this.toSeconds(this.decay);\n\t\t// check if it's not a complete attack\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\t// subtract the current value from the attack time\n\t\t\tconst attackRate = 1 / attack;\n\t\t\tconst remainingDistance = 1 - currentValue;\n\t\t\t// the attack is now the remaining time\n\t\t\tattack = remainingDistance / attackRate;\n\t\t}\n\t\t// attack\n\t\tif (attack < this.sampleTime) {\n\t\t\tthis._sig.cancelScheduledValues(time);\n\t\t\t// case where the attack time is 0 should set instantly\n\t\t\tthis._sig.setValueAtTime(velocity, time);\n\t\t} else if (this._attackCurve === \"linear\") {\n\t\t\tthis._sig.linearRampTo(velocity, attack, time);\n\t\t} else if (this._attackCurve === \"exponential\") {\n\t\t\tthis._sig.targetRampTo(velocity, attack, time);\n\t\t} else {\n\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\tlet curve = this._attackCurve;\n\t\t\t// find the starting position in the curve\n\t\t\tfor (let i = 1; i < curve.length; i++) {\n\t\t\t\t// the starting index is between the two values\n\t\t\t\tif (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n\t\t\t\t\tcurve = this._attackCurve.slice(i);\n\t\t\t\t\t// the first index is the current value\n\t\t\t\t\tcurve[0] = currentValue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._sig.setValueCurveAtTime(curve, time, attack, velocity);\n\t\t}\n\t\t// decay\n\t\tif (decay && this.sustain < 1) {\n\t\t\tconst decayValue = velocity * this.sustain;\n\t\t\tconst decayStart = time + attack;\n\t\t\tthis.log(\"decay\", decayStart);\n\t\t\tif (this._decayCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampToValueAtTime(decayValue, decay + decayStart);\n\t\t\t} else {\n\t\t\t\tthis._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Triggers the release of the envelope.\n\t * @param  time When the release portion of the envelope should start.\n\t * @example\n\t * const env = new Tone.AmplitudeEnvelope().toDestination();\n\t * const osc = new Tone.Oscillator({\n\t * \ttype: \"sawtooth\"\n\t * }).connect(env).start();\n\t * env.triggerAttack();\n\t * // trigger the release half a second after the attack\n\t * env.triggerRelease(\"+0.5\");\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\ttime = this.toSeconds(time);\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\tconst release = this.toSeconds(this.release);\n\t\t\tif (release < this.sampleTime) {\n\t\t\t\tthis._sig.setValueAtTime(0, time);\n\t\t\t} else if (this._releaseCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampTo(0, release, time);\n\t\t\t} else if (this._releaseCurve === \"exponential\") {\n\t\t\t\tthis._sig.targetRampTo(0, release, time);\n\t\t\t} else {\n\t\t\t\tassert(isArray(this._releaseCurve), \"releaseCurve must be either 'linear', 'exponential' or an array\");\n\t\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\t\tthis._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the scheduled value at the given time. This will\n\t * return the unconverted (raw) value.\n\t * @example\n\t * const env = new Tone.Envelope(0.5, 1, 0.4, 2);\n\t * env.triggerAttackRelease(2);\n\t * setInterval(() => console.log(env.getValueAtTime), 100);\n\t */\n\tgetValueAtTime(time: Time): NormalRange {\n\t\treturn this._sig.getValueAtTime(time);\n\t}\n\n\t/**\n\t * triggerAttackRelease is shorthand for triggerAttack, then waiting\n\t * some duration, then triggerRelease.\n\t * @param duration The duration of the sustain.\n\t * @param time When the attack should be triggered.\n\t * @param velocity The velocity of the envelope.\n\t * @example\n\t * const env = new Tone.AmplitudeEnvelope().toDestination();\n\t * const osc = new Tone.Oscillator().connect(env).start();\n\t * // trigger the release 0.5 seconds after the attack\n\t * env.triggerAttackRelease(0.5);\n\t */\n\ttriggerAttackRelease(duration: Time, time?: Time, velocity: NormalRange = 1): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis.triggerAttack(time, velocity);\n\t\tthis.triggerRelease(time + this.toSeconds(duration));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancels all scheduled envelope changes after the given time.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._sig.cancelScheduledValues(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the envelope to a destination node.\n\t */\n\tconnect(destination: InputNode, outputNumber = 0, inputNumber = 0): this {\n\t\tconnectSignal(this, destination, outputNumber, inputNumber);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Render the envelope curve to an array of the given length. \n\t * Good for visualizing the envelope curve. Rescales the duration of the\n\t * envelope to fit the length.\n\t */\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\tconst duration = length / this.context.sampleRate;\n\t\tconst context = new OfflineContext(1, duration, this.context.sampleRate);\n\t\t// normalize the ADSR for the given duration with 20% sustain time\n\t\tconst attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);\n\t\tconst envelopeDuration = attackPortion + this.toSeconds(this.release);\n\t\tconst sustainTime = envelopeDuration * 0.1;\n\t\tconst totalDuration = envelopeDuration + sustainTime;\n\t\t// @ts-ignore\n\t\tconst clone = new this.constructor(Object.assign(this.get(), {\n\t\t\tattack: duration * this.toSeconds(this.attack) / totalDuration,\n\t\t\tdecay: duration * this.toSeconds(this.decay) / totalDuration,\n\t\t\trelease: duration * this.toSeconds(this.release) / totalDuration,\n\t\t\tcontext\n\t\t})) as Envelope;\n\t\tclone._sig.toDestination();\n\t\tclone.triggerAttackRelease(duration * (attackPortion + sustainTime) / totalDuration, 0);\n\t\tconst buffer = await context.render();\n\t\treturn buffer.getChannelData(0);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sig.dispose();\n\t\treturn this;\n\t}\n}\n\ninterface EnvelopeCurveObject {\n\tIn: number[];\n\tOut: number[];\n}\n\ntype EnvelopeDirection = keyof EnvelopeCurveObject;\n\ninterface EnvelopeCurveMap {\n\tlinear: \"linear\";\n\texponential: \"exponential\";\n\tbounce: EnvelopeCurveObject;\n\tcosine: EnvelopeCurveObject;\n\tsine: EnvelopeCurveObject;\n\tripple: EnvelopeCurveObject;\n\tstep: EnvelopeCurveObject;\n}\n\ntype EnvelopeCurveName = keyof EnvelopeCurveMap;\n\n/**\n * Generate some complex envelope curves.\n */\nconst EnvelopeCurves: EnvelopeCurveMap = (() => {\n\n\tconst curveLen = 128;\n\n\tlet i: number;\n\tlet k: number;\n\n\t// cosine curve\n\tconst cosineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tcosineCurve[i] = Math.sin((i / (curveLen - 1)) * (Math.PI / 2));\n\t}\n\n\t// ripple curve\n\tconst rippleCurve: number[] = [];\n\tconst rippleCurveFreq = 6.4;\n\tfor (i = 0; i < curveLen - 1; i++) {\n\t\tk = (i / (curveLen - 1));\n\t\tconst sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n\t\trippleCurve[i] = sineWave / 10 + k * 0.83;\n\t}\n\trippleCurve[curveLen - 1] = 1;\n\n\t// stairs curve\n\tconst stairsCurve: number[] = [];\n\tconst steps = 5;\n\tfor (i = 0; i < curveLen; i++) {\n\t\tstairsCurve[i] = Math.ceil((i / (curveLen - 1)) * steps) / steps;\n\t}\n\n\t// in-out easing curve\n\tconst sineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tsineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n\t}\n\n\t// a bounce curve\n\tconst bounceCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tconst freq = Math.pow(k, 3) * 4 + 0.2;\n\t\tconst val = Math.cos(freq * Math.PI * 2 * k);\n\t\tbounceCurve[i] = Math.abs(val * (1 - k));\n\t}\n\n\t/**\n\t * Invert a value curve to make it work for the release\n\t */\n\tfunction invertCurve(curve: number[]): number[] {\n\t\tconst out = new Array(curve.length);\n\t\tfor (let j = 0; j < curve.length; j++) {\n\t\t\tout[j] = 1 - curve[j];\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t * reverse the curve\n\t */\n\tfunction reverseCurve(curve: number[]): number[] {\n\t\treturn curve.slice(0).reverse();\n\t}\n\n\t/**\n\t * attack and release curve arrays\n\t */\n\treturn {\n\t\tbounce: {\n\t\t\tIn: invertCurve(bounceCurve),\n\t\t\tOut: bounceCurve,\n\t\t},\n\t\tcosine: {\n\t\t\tIn: cosineCurve,\n\t\t\tOut: reverseCurve(cosineCurve),\n\t\t},\n\t\texponential: \"exponential\" as \"exponential\",\n\t\tlinear: \"linear\" as \"linear\",\n\t\tripple: {\n\t\t\tIn: rippleCurve,\n\t\t\tOut: invertCurve(rippleCurve),\n\t\t},\n\t\tsine: {\n\t\t\tIn: sineCurve,\n\t\t\tOut: invertCurve(sineCurve),\n\t\t},\n\t\tstep: {\n\t\t\tIn: stairsCurve,\n\t\t\tOut: invertCurve(stairsCurve),\n\t\t},\n\t};\n})();\n","import { Volume } from \"../component/channel/Volume\";\nimport { Param } from \"../core/context/Param\";\nimport { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels, Frequency, NormalRange, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface InstrumentOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n}\n\n/**\n * Base-class for all instruments\n */\nexport abstract class Instrument<Options extends InstrumentOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t * The output and volume triming node\n\t */\n\tprivate _volume: Volume;\n\toutput: OutputNode;\n\n\t/**\n\t * The instrument only has an output\n\t */\n\tinput: undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * const amSynth = new Tone.AMSynth().toDestination();\n\t * amSynth.volume.value = -6;\n\t * amSynth.triggerAttackRelease(\"G#3\", 0.2);\n\t */\n\tvolume: Param<\"decibels\">;\n\n\t/**\n\t * Keep track of all events scheduled to the transport\n\t * when the instrument is 'synced'\n\t */\n\tprivate _scheduledEvents: number[] = [];\n\n\t/**\n\t * If the instrument is currently synced\n\t */\n\tprivate _synced = false;\n\n\tconstructor(options?: Partial<InstrumentOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Instrument.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Instrument.getDefaults(), arguments);\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t}\n\n\tstatic getDefaults(): InstrumentOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Sync the instrument to the Transport. All subsequent calls of\n\t * [[triggerAttack]] and [[triggerRelease]] will be scheduled along the transport.\n\t * @example\n\t * const fmSynth = new Tone.FMSynth().toDestination();\n\t * fmSynth.volume.value = -6;\n\t * fmSynth.sync();\n\t * // schedule 3 notes when the transport first starts\n\t * fmSynth.triggerAttackRelease(\"C4\", \"8n\", 0);\n\t * fmSynth.triggerAttackRelease(\"E4\", \"8n\", \"8n\");\n\t * fmSynth.triggerAttackRelease(\"G4\", \"8n\", \"4n\");\n\t * // start the transport to hear the notes\n\t * Tone.Transport.start();\n\t */\n\tsync(): this {\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\t\tthis._syncMethod(\"triggerRelease\", 0);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Wrap the given method so that it can be synchronized\n\t * @param method Which method to wrap and sync\n\t * @param  timePosition What position the time argument appears in\n\t */\n\tprotected _syncMethod(method: string, timePosition: number): void {\n\t\tconst originalMethod = this[\"_original_\" + method] = this[method];\n\t\tthis[method] = (...args: any[]) => {\n\t\t\tconst time = args[timePosition];\n\t\t\tconst id = this.context.transport.schedule((t) => {\n\t\t\t\targs[timePosition] = t;\n\t\t\t\toriginalMethod.apply(this, args);\n\t\t\t}, time);\n\t\t\tthis._scheduledEvents.push(id);\n\t\t};\n\t}\n\n\t/**\n\t * Unsync the instrument from the Transport\n\t */\n\tunsync(): this {\n\t\tthis._scheduledEvents.forEach(id => this.context.transport.clear(id));\n\t\tthis._scheduledEvents = [];\n\t\tif (this._synced) {\n\t\t\tthis._synced = false;\n\t\t\tthis.triggerAttack = this._original_triggerAttack;\n\t\t\tthis.triggerRelease = this._original_triggerRelease;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the attack and then the release after the duration.\n\t * @param  note     The note to trigger.\n\t * @param  duration How long the note should be held for before\n\t *                         triggering the release. This value must be greater than 0.\n\t * @param time  When the note should be triggered.\n\t * @param  velocity The velocity the note should be triggered at.\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * // trigger \"C4\" for the duration of an 8th note\n\t * synth.triggerAttackRelease(\"C4\", \"8n\");\n\t */\n\ttriggerAttackRelease(note: Frequency, duration: Time, time?: Time, velocity?: NormalRange): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tthis.triggerAttack(note, computedTime, velocity);\n\t\tthis.triggerRelease(computedTime + computedDuration);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the instrument's note.\n\t * @param note the note to trigger\n\t * @param time the time to trigger the ntoe\n\t * @param velocity the velocity to trigger the note (betwee 0-1)\n\t */\n\tabstract triggerAttack(note: Frequency, time?: Time, velocity?: NormalRange): this;\n\tprivate _original_triggerAttack = this.triggerAttack;\n\n\t/**\n\t * Trigger the release phase of the current note.\n\t * @param time when to trigger the release\n\t */\n\tabstract triggerRelease(...args: any[]): this;\n\tprivate _original_triggerRelease = this.triggerRelease;\n\n\t/**\n\t * clean up\n\t * @returns {Instrument} this\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._volume.dispose();\n\t\tthis.unsync();\n\t\tthis._scheduledEvents = [];\n\t\treturn this;\n\t}\n}\n","import { FrequencyClass } from \"../core/type/Frequency\";\nimport { Cents, Frequency, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument\";\nimport { Signal } from \"../signal/Signal\";\nimport { timeRange } from \"../core/util/Decorator\";\n\ntype onSilenceCallback = (instrument: Monophonic<any>) => void;\n\nexport interface MonophonicOptions extends InstrumentOptions {\n\tportamento: Seconds;\n\tonsilence: onSilenceCallback;\n\tdetune: Cents;\n}\n\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\nexport abstract class Monophonic<Options extends MonophonicOptions> extends Instrument<Options> {\n\n\t/**\n\t * The glide time between notes.\n\t */\n\t@timeRange(0)\n\tportamento: Seconds;\n\n\t/**\n\t * Invoked when the release has finished and the output is silent.\n\t */\n\tonsilence: onSilenceCallback;\n\n\t/**\n\t * The instrument's frequency signal.\n\t */\n\tabstract readonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The instrument's detune control signal.\n\t */\n\tabstract readonly detune: Signal<\"cents\">;\n\n\tconstructor(options?: Partial<MonophonicOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Monophonic.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n\n\t\tthis.portamento = options.portamento;\n\t\tthis.onsilence = options.onsilence;\n\t}\n\n\tstatic getDefaults(): MonophonicOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tonsilence: noOp,\n\t\t\tportamento: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack of the note optionally with a given velocity.\n\t * @param  note The note to trigger.\n\t * @param  time When the note should start.\n\t * @param  velocity The velocity scaler determines how \"loud\" the note will be triggered.\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * // trigger the note a half second from now at half velocity\n\t * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n\t */\n\ttriggerAttack(note: Frequency | FrequencyClass, time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", note, time, velocity);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeAttack(seconds, velocity);\n\t\tthis.setNote(note, seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release portion of the envelope\n\t * @param  time If no time is given, the release happens immediatly\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * synth.triggerAttack(\"C4\");\n\t * // trigger the release a second from now\n\t * synth.triggerRelease(\"+1\");\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeRelease(seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal method which starts the envelope attack\n\t */\n\tprotected abstract _triggerEnvelopeAttack(time: Seconds, velocity: NormalRange): void;\n\n\t/**\n\t * Internal method which starts the envelope release\n\t */\n\tprotected abstract _triggerEnvelopeRelease(time: Seconds): void;\n\n\t/**\n\t * Get the level of the output at the given time. Measures\n\t * the envelope(s) value at the time.\n\t * @param time The time to query the envelope value\n\t * @return The output level between 0-1\n\t */\n\tabstract getLevelAtTime(time: Time): NormalRange;\n\n\t/**\n\t * Set the note at the given time. If no time is given, the note\n\t * will set immediately.\n\t * @param note The note to change to.\n\t * @param  time The time when the note should be set.\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * synth.triggerAttack(\"C4\");\n\t * // change to F#6 in one quarter note from now.\n\t * synth.setNote(\"F#6\", \"+4n\");\n\t */\n\tsetNote(note: Frequency | FrequencyClass, time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n\t\tif (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n\t\t\tconst portTime = this.toSeconds(this.portamento);\n\t\t\tthis.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n\t\t} else {\n\t\t\tthis.frequency.setValueAtTime(computedFrequency, computedTime);\n\t\t}\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Envelope, EnvelopeOptions } from \"./Envelope\";\n\n/**\n * AmplitudeEnvelope is a Tone.Envelope connected to a gain node.\n * Unlike Tone.Envelope, which outputs the envelope's value, AmplitudeEnvelope accepts\n * an audio signal as the input and will apply the envelope to the amplitude\n * of the signal.\n * Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst ampEnv = new Tone.AmplitudeEnvelope({\n * \t\tattack: 0.1,\n * \t\tdecay: 0.2,\n * \t\tsustain: 1.0,\n * \t\trelease: 0.8\n * \t}).toDestination();\n * \t// create an oscillator and connect it\n * \tconst osc = new Tone.Oscillator().connect(ampEnv).start();\n * \t// trigger the envelopes attack and release \"8t\" apart\n * \tampEnv.triggerAttackRelease(\"8t\");\n * }, 1.5, 1);\n * @category Component\n */\nexport class AmplitudeEnvelope extends Envelope {\n\n\treadonly name: string = \"AmplitudeEnvelope\";\n\n\tprivate _gainNode: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\toutput: Gain = this._gainNode;\n\tinput: Gain = this._gainNode;\n\n\t/**\n\t * @param attack The amount of time it takes for the envelope to go from 0 to it's maximum value.\n\t * @param decay\tThe period of time after the attack that it takes for the envelope\n\t *                      \tto fall to the sustain value. Value must be greater than 0.\n\t * @param sustain\tThe percent of the maximum value that the envelope rests at until\n\t *                               \tthe release is triggered.\n\t * @param release\tThe amount of time after the release is triggered it takes to reach 0.\n\t *                        \tValue must be greater than 0.\n\t */\n\tconstructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);\n\tconstructor(options?: Partial<EnvelopeOptions>)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(AmplitudeEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n\t\tthis._sig.connect(this._gainNode.gain);\n\t\tthis.output = this._gainNode;\n\t\tthis.input = this._gainNode;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.dispose();\n\t\treturn this;\n\t}\n}\n","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Signal } from \"../signal/Signal\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { OmniOscillatorSynthOptions } from \"../source/oscillator/OscillatorInterface\";\nimport { Source } from \"../source/Source\";\nimport { Monophonic, MonophonicOptions } from \"./Monophonic\";\n\nexport interface SynthOptions extends MonophonicOptions {\n\toscillator: OmniOscillatorSynthOptions;\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * Synth is composed simply of a [[OmniOscillator]] routed through an [[AmplitudeEnvelope]].\n * ```\n * +----------------+   +-------------------+\n * | OmniOscillator +>--> AmplitudeEnvelope +>--> Output\n * +----------------+   +-------------------+\n * ```\n * @example\n * const synth = new Tone.Synth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\nexport class Synth<Options extends SynthOptions = SynthOptions> extends Monophonic<Options> {\n\n\treadonly name: string = \"Synth\";\n\n\t/**\n\t * The oscillator.\n\t */\n\treadonly oscillator: OmniOscillator<any>;\n\n\t/**\n\t * The frequency signal\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune signal\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The envelope\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\t/**\n\t * @param options the options available for the synth.\n\t */\n\tconstructor(options?: RecursivePartial<SynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Synth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Synth.getDefaults(), arguments);\n\n\t\tthis.oscillator = new OmniOscillator(Object.assign({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tonstop: () => this.onsilence(this),\n\t\t}, options.oscillator));\n\n\t\tthis.frequency = this.oscillator.frequency;\n\t\tthis.detune = this.oscillator.detune;\n\n\t\tthis.envelope = new AmplitudeEnvelope(Object.assign({\n\t\t\tcontext: this.context,\n\t\t}, options.envelope));\n\n\t\t// connect the oscillators to the output\n\t\tthis.oscillator.chain(this.envelope, this.output);\n\t\treadOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): SynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.005,\n\t\t\t\t\tdecay: 0.1,\n\t\t\t\t\trelease: 1,\n\t\t\t\t\tsustain: 0.3,\n\t\t\t\t},\n\t\t\t),\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), \"frequency\", \"detune\"]),\n\t\t\t\t{\n\t\t\t\t\ttype: \"triangle\",\n\t\t\t\t},\n\t\t\t),\n\t\t});\n\t}\n\n\t/**\n\t * start the attack portion of the envelope\n\t * @param time the time the attack should start\n\t * @param velocity the velocity of the note (0-1)\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: number): void {\n\t\t// the envelopes\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\tthis.oscillator.start(time);\n\t\t// if there is no release portion, stop the oscillator\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tconst computedAttack = this.toSeconds(this.envelope.attack);\n\t\t\tconst computedDecay = this.toSeconds(this.envelope.decay);\n\t\t\tthis.oscillator.stop(time + computedAttack + computedDecay);\n\t\t}\n\t}\n\n\t/**\n\t * start the release portion of the envelope\n\t * @param time the time the release should start\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds): void {\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.oscillator.stop(time + this.toSeconds(this.envelope.release));\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.oscillator.dispose();\n\t\tthis.envelope.dispose();\n\t\treturn this;\n\t}\n}\n","import { Signal } from \"../signal/Signal\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Gain } from \"../core/context/Gain\";\nimport { NormalRange, Positive, Seconds, Time } from \"../core/type/Units\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Monophonic } from \"./Monophonic\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { OmniOscillatorSynthOptions } from \"../source/oscillator/OscillatorInterface\";\nimport { Source } from \"../source/Source\";\nimport { Synth, SynthOptions } from \"./Synth\";\nimport { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\n\nexport interface ModulationSynthOptions extends SynthOptions {\n\tharmonicity: Positive;\n\tmodulationEnvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tmodulation: OmniOscillatorSynthOptions;\n}\n/**\n * Base class for both AM and FM synths\n */\nexport abstract class ModulationSynth<Options extends ModulationSynthOptions> extends Monophonic<Options> {\n\n\treadonly name: string = \"ModulationSynth\";\n\n\t/**\n\t * The carrier voice.\n\t */\n\tprotected _carrier: Synth;\n\n\t/**\n\t * The modulator voice.\n\t */\n\n\tprotected _modulator: Synth;\n\n\t/**\n\t * The carrier's oscillator\n\t */\n\treadonly oscillator: OmniOscillator<any>;\n\n\t/**\n\t * The carrier's envelope\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\t/**\n\t * The modulator's oscillator which is applied to the amplitude of the oscillator\n\t */\n\treadonly modulation: OmniOscillator<any>;\n\n\t/**\n\t * The modulator's envelope\n\t */\n\treadonly modulationEnvelope: AmplitudeEnvelope;\n\n\t/**\n\t * The frequency control\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune in cents\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * Harmonicity is the ratio between the two voices. A harmonicity of\n\t * 1 is no change. Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * const amSynth = new Tone.AMSynth().toDestination();\n\t * // pitch the modulator an octave below oscillator\n\t * amSynth.harmonicity.value = 0.5;\n\t * amSynth.triggerAttackRelease(\"C5\", \"4n\");\n\t */\n\treadonly harmonicity: Multiply;\n\n\t/**\n\t * The node where the modulation happens\n\t */\n\tprotected _modulationNode: Gain;\n\n\tconstructor(options?: RecursivePartial<ModulationSynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(ModulationSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(ModulationSynth.getDefaults(), arguments);\n\n\t\tthis._carrier = new Synth({\n\t\t\tcontext: this.context,\n\t\t\toscillator: options.oscillator,\n\t\t\tenvelope: options.envelope,\n\t\t\tonsilence: () => this.onsilence(this),\n\t\t\tvolume: -10,\n\t\t});\n\t\tthis._modulator = new Synth({\n\t\t\tcontext: this.context,\n\t\t\toscillator: options.modulation,\n\t\t\tenvelope: options.modulationEnvelope,\n\t\t\tvolume: -10,\n\t\t});\n\n\t\tthis.oscillator = this._carrier.oscillator;\n\t\tthis.envelope = this._carrier.envelope;\n\t\tthis.modulation = this._modulator.oscillator;\n\t\tthis.modulationEnvelope = this._modulator.envelope;\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.detune,\n\t\t\tunits: \"cents\"\n\t\t});\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.harmonicity,\n\t\t\tminValue: 0,\n\t\t});\n\t\tthis._modulationNode = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: 0,\n\t\t});\n\n\t\treadOnly(this, [\"frequency\", \"harmonicity\", \"oscillator\", \"envelope\", \"modulation\", \"modulationEnvelope\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): ModulationSynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tharmonicity: 3,\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), [\n\t\t\t\t\t...Object.keys(Source.getDefaults()),\n\t\t\t\t\t\"frequency\",\n\t\t\t\t\t\"detune\"\n\t\t\t\t]),\n\t\t\t\t{\n\t\t\t\t\ttype: \"sine\"\n\t\t\t\t}\n\t\t\t),\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tEnvelope.getDefaults(),\n\t\t\t\t\tObject.keys(ToneAudioNode.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.01,\n\t\t\t\t\tdecay: 0.01,\n\t\t\t\t\tsustain: 1,\n\t\t\t\t\trelease: 0.5\n\t\t\t\t}\n\t\t\t),\n\t\t\tmodulation: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), [\n\t\t\t\t\t...Object.keys(Source.getDefaults()),\n\t\t\t\t\t\"frequency\",\n\t\t\t\t\t\"detune\"\n\t\t\t\t]),\n\t\t\t\t{\n\t\t\t\t\ttype: \"square\"\n\t\t\t\t}\n\t\t\t),\n\t\t\tmodulationEnvelope: Object.assign(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tEnvelope.getDefaults(),\n\t\t\t\t\tObject.keys(ToneAudioNode.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.5,\n\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\tsustain: 1,\n\t\t\t\t\trelease: 0.5\n\t\t\t\t}\n\t\t\t)\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack portion of the note\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: number): void {\n\t\t// @ts-ignore\n\t\tthis._carrier._triggerEnvelopeAttack(time, velocity);\n\t\t// @ts-ignore\n\t\tthis._modulator._triggerEnvelopeAttack(time, velocity);\n\t}\n\n\t/**\n\t * Trigger the release portion of the note\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds) {\n\t\t// @ts-ignore\n\t\tthis._carrier._triggerEnvelopeRelease(time);\n\t\t// @ts-ignore\n\t\tthis._modulator._triggerEnvelopeRelease(time);\n\t\treturn this;\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._modulationNode.dispose();\n\t\treturn this;\n\t}\n}\n","import { AudioToGain } from \"../signal/AudioToGain\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { ModulationSynth, ModulationSynthOptions } from \"./ModulationSynth\";\n\nexport type AMSynthOptions = ModulationSynthOptions;\n\n/**\n * AMSynth uses the output of one Tone.Synth to modulate the\n * amplitude of another Tone.Synth. The harmonicity (the ratio between\n * the two signals) affects the timbre of the output signal greatly.\n * Read more about Amplitude Modulation Synthesis on\n * [SoundOnSound](https://web.archive.org/web/20160404103653/http://www.soundonsound.com:80/sos/mar00/articles/synthsecrets.htm).\n *\n * @example\n * const synth = new Tone.AMSynth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"4n\");\n * \n * @category Instrument\n */\nexport class AMSynth extends ModulationSynth<AMSynthOptions> {\n\n\treadonly name: string = \"AMSynth\";\n\n\t/**\n\t * Scale the oscillator from -1,1 to 0-1\n\t */\n\tprivate _modulationScale: AudioToGain;\n\n\tconstructor(options?: RecursivePartial<AMSynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(AMSynth.getDefaults(), arguments));\n\n\t\tthis._modulationScale = new AudioToGain({\n\t\t\tcontext: this.context,\n\t\t});\n\n\t\t// control the two voices frequency\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.detune.fan(this._carrier.detune, this._modulator.detune);\n\t\tthis._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\t\tthis._carrier.chain(this._modulationNode, this.output);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._modulationScale.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Cents, Frequency, GainFactor } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Param } from \"../../core/context/Param\";\nimport { assert } from \"../../core/util/Debug\";\n\nexport interface BiquadFilterOptions extends ToneAudioNodeOptions {\n\tfrequency: Frequency;\n\tdetune: Cents;\n\tQ: number;\n\ttype: BiquadFilterType;\n\tgain: GainFactor;\n}\n\n/**\n * Thin wrapper around the native Web Audio [BiquadFilterNode](https://webaudio.github.io/web-audio-api/#biquadfilternode). \n * BiquadFilter is similar to [[Filter]] but doesn't have the option to set the \"rolloff\" value. \n * @category Component\n */\nexport class BiquadFilter extends ToneAudioNode<BiquadFilterOptions> {\n\treadonly name: string = \"BiquadFilter\";\n\n\treadonly input: BiquadFilterNode;\n\treadonly output: BiquadFilterNode;\n\n\t/**\n\t * The frequency of the filter\n\t */\n\treadonly frequency: Param<\"frequency\">;\n\n\t/**\n\t * A detune value, in cents, for the frequency.\n\t */\n\treadonly detune: Param<\"cents\">;\n\t\n\t/**\n\t * The Q factor of the filter.\n\t * For lowpass and highpass filters the Q value is interpreted to be in dB. \n\t * For these filters the nominal range is [−𝑄𝑙𝑖𝑚,𝑄𝑙𝑖𝑚] where 𝑄𝑙𝑖𝑚 is the largest value for which 10𝑄/20 does not overflow. This is approximately 770.63678.\n\t * For the bandpass, notch, allpass, and peaking filters, this value is a linear value. \n\t * The value is related to the bandwidth of the filter and hence should be a positive value. The nominal range is \n\t * [0,3.4028235𝑒38], the upper limit being the most-positive-single-float.\n\t * This is not used for the lowshelf and highshelf filters.\n\t */\n\treadonly Q: Param<\"number\">;\n\n\t/**\n\t * The gain of the filter. Its value is in dB units. The gain is only used for lowshelf, highshelf, and peaking filters.\n\t */\n\treadonly gain: Param<\"gain\">;\n\n\tprivate readonly _filter: BiquadFilterNode;\n\n\t/**\n\t * @param frequency The cutoff frequency of the filter.\n\t * @param type The type of filter.\n\t */\n\tconstructor(frequency?: Frequency, type?: BiquadFilterType);\n\tconstructor(options?: Partial<BiquadFilterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(BiquadFilter.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(BiquadFilter.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis._filter = this.context.createBiquadFilter();\n\t\tthis.input = this.output = this._filter;\n\n\t\tthis.Q = new Param({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"number\",\n\t\t\tvalue: options.Q,\n\t\t\tparam: this._filter.Q,\n\t\t});\n\t\t\n\t\tthis.frequency = new Param({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t\tparam: this._filter.frequency,\n\t\t});\n\t\t\n\t\tthis.detune = new Param({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t\tparam: this._filter.detune,\n\t\t});\n\t\t\n\t\tthis.gain = new Param({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"gain\",\n\t\t\tvalue: options.gain,\n\t\t\tparam: this._filter.gain,\n\t\t});\n\n\t\tthis.type = options.type;\n\t}\n\n\tstatic getDefaults(): BiquadFilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tQ: 1,\n\t\t\ttype: \"lowpass\" as const,\n\t\t\tfrequency: 350,\n\t\t\tdetune: 0,\n\t\t\tgain: 0,\n\t\t});\n\t}\n\n\t/**\n\t * The type of this BiquadFilterNode. For a complete list of types and their attributes, see the\n\t * [Web Audio API](https://webaudio.github.io/web-audio-api/#dom-biquadfiltertype-lowpass)\n\t */\n\tget type(): BiquadFilterType {\n\t\treturn this._filter.type;\n\t}\n\tset type(type) {\n\t\tconst types: BiquadFilterType[] = [\"lowpass\", \"highpass\", \"bandpass\",\n\t\t\t\"lowshelf\", \"highshelf\", \"notch\", \"allpass\", \"peaking\"];\n\t\tassert(types.indexOf(type) !== -1, `Invalid filter type: ${type}`);\n\t\tthis._filter.type = type;\n\t}\n\n\t/**\n\t * Get the frequency response curve. This curve represents how the filter\n\t * responses to frequencies between 20hz-20khz.\n\t * @param  len The number of values to return\n\t * @return The frequency response curve between 20-20kHz\n\t */\n\tgetFrequencyResponse(len = 128): Float32Array {\n\t\t// start with all 1s\n\t\tconst freqValues = new Float32Array(len);\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst norm = Math.pow(i / len, 2);\n\t\t\tconst freq = norm * (20000 - 20) + 20;\n\t\t\tfreqValues[i] = freq;\n\t\t}\n\t\tconst magValues = new Float32Array(len);\n\t\tconst phaseValues = new Float32Array(len);\n\t\t// clone the filter to remove any connections which may be changing the value\n\t\tconst filterClone = this.context.createBiquadFilter();\n\t\tfilterClone.type = this.type;\n\t\tfilterClone.Q.value = this.Q.value;\n\t\tfilterClone.frequency.value = this.frequency.value as number;\n\t\tfilterClone.gain.value = this.gain.value as number;\n\t\tfilterClone.getFrequencyResponse(freqValues, magValues, phaseValues);\n\t\treturn magValues;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._filter.disconnect();\n\t\tthis.Q.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.gain.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { connectSeries, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { Frequency } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { isNumber } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { assert } from \"../../core/util/Debug\";\nimport { BiquadFilter, BiquadFilterOptions } from \"./BiquadFilter\";\n\nexport type FilterRollOff = -12 | -24 | -48 | -96;\n\nexport type FilterOptions = BiquadFilterOptions & {\n\trolloff: FilterRollOff;\n}\n\n/**\n * Tone.Filter is a filter which allows for all of the same native methods\n * as the [BiquadFilterNode](http://webaudio.github.io/web-audio-api/#the-biquadfilternode-interface).\n * Tone.Filter has the added ability to set the filter rolloff at -12\n * (default), -24 and -48.\n * @example\n * const filter = new Tone.Filter(1500, \"highpass\").toDestination();\n * filter.frequency.rampTo(20000, 10);\n * const noise = new Tone.Noise().connect(filter).start();\n * @category Component\n */\nexport class Filter extends ToneAudioNode<FilterOptions> {\n\n\treadonly name: string = \"Filter\";\n\n\treadonly input = new Gain({ context: this.context });\n\treadonly output = new Gain({ context: this.context });\n\tprivate _filters: BiquadFilter[] = [];\n\n\t/**\n\t * the rolloff value of the filter\n\t */\n\tprivate _rolloff!: FilterRollOff;\n\tprivate _type: BiquadFilterType;\n\n\t/**\n\t * The Q or Quality of the filter\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * The cutoff frequency of the filter.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune parameter\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The gain of the filter, only used in certain filter types\n\t */\n\treadonly gain: Signal<\"decibels\">;\n\n\t/**\n\t * @param frequency The cutoff frequency of the filter.\n\t * @param type The type of filter.\n\t * @param rolloff The drop in decibels per octave after the cutoff frequency\n\t */\n\tconstructor(frequency?: Frequency, type?: BiquadFilterType, rolloff?: FilterRollOff);\n\tconstructor(options?: Partial<FilterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Filter.getDefaults(), arguments, [\"frequency\", \"type\", \"rolloff\"]));\n\t\tconst options = optionsFromArguments(Filter.getDefaults(), arguments, [\"frequency\", \"type\", \"rolloff\"]);\n\n\t\tthis._filters = [];\n\n\t\tthis.Q = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.Q,\n\t\t});\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\tthis.gain = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"decibels\",\n\t\t\tvalue: options.gain,\n\t\t});\n\t\tthis._type = options.type;\n\t\tthis.rolloff = options.rolloff;\n\t\treadOnly(this, [\"detune\", \"frequency\", \"gain\", \"Q\"]);\n\t}\n\n\tstatic getDefaults(): FilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tQ: 1,\n\t\t\tdetune: 0,\n\t\t\tfrequency: 350,\n\t\t\tgain: 0,\n\t\t\trolloff: -12 as FilterRollOff,\n\t\t\ttype: \"lowpass\" as BiquadFilterType,\n\t\t});\n\t}\n\n\t/**\n\t * The type of the filter. Types: \"lowpass\", \"highpass\",\n\t * \"bandpass\", \"lowshelf\", \"highshelf\", \"notch\", \"allpass\", or \"peaking\".\n\t */\n\tget type(): BiquadFilterType {\n\t\treturn this._type;\n\t}\n\tset type(type: BiquadFilterType) {\n\t\tconst types: BiquadFilterType[] = [\"lowpass\", \"highpass\", \"bandpass\",\n\t\t\t\"lowshelf\", \"highshelf\", \"notch\", \"allpass\", \"peaking\"];\n\t\tassert(types.indexOf(type) !== -1, `Invalid filter type: ${type}`);\n\t\tthis._type = type;\n\t\tthis._filters.forEach(filter => filter.type = type);\n\t}\n\n\t/**\n\t * The rolloff of the filter which is the drop in db\n\t * per octave. Implemented internally by cascading filters.\n\t * Only accepts the values -12, -24, -48 and -96.\n\t */\n\tget rolloff(): FilterRollOff {\n\t\treturn this._rolloff;\n\t}\n\tset rolloff(rolloff) {\n\t\tconst rolloffNum = isNumber(rolloff) ? rolloff : parseInt(rolloff, 10) as FilterRollOff;\n\t\tconst possibilities = [-12, -24, -48, -96];\n\t\tlet cascadingCount = possibilities.indexOf(rolloffNum);\n\t\t// check the rolloff is valid\n\t\tassert(cascadingCount !== -1, `rolloff can only be ${possibilities.join(\", \")}`);\n\t\tcascadingCount += 1;\n\n\t\tthis._rolloff = rolloffNum;\n\t\tthis.input.disconnect();\n\t\tthis._filters.forEach(filter => filter.disconnect());\n\n\t\tthis._filters = new Array(cascadingCount);\n\t\tfor (let count = 0; count < cascadingCount; count++) {\n\t\t\tconst filter = new BiquadFilter({\n\t\t\t\tcontext: this.context,\n\t\t\t});\n\t\t\tfilter.type = this._type;\n\t\t\tthis.frequency.connect(filter.frequency);\n\t\t\tthis.detune.connect(filter.detune);\n\t\t\tthis.Q.connect(filter.Q);\n\t\t\tthis.gain.connect(filter.gain);\n\t\t\tthis._filters[count] = filter;\n\t\t}\n\t\tthis._internalChannels = this._filters;\n\t\tconnectSeries(this.input, ...this._internalChannels, this.output);\n\t}\n\n\t/**\n\t * Get the frequency response curve. This curve represents how the filter\n\t * responses to frequencies between 20hz-20khz.\n\t * @param  len The number of values to return\n\t * @return The frequency response curve between 20-20kHz\n\t */\n\tgetFrequencyResponse(len = 128): Float32Array {\n\t\tconst filterClone = new BiquadFilter({\n\t\t\tfrequency: this.frequency.value,\n\t\t\tgain: this.gain.value,\n\t\t\tQ: this.Q.value,\n\t\t\ttype: this._type,\n\t\t\tdetune: this.detune.value,\n\t\t});\n\t\t// start with all 1s\n\t\tconst totalResponse = new Float32Array(len).map(() => 1);\n\t\tthis._filters.forEach(() => {\n\t\t\tconst response = filterClone.getFrequencyResponse(len);\n\t\t\tresponse.forEach((val, i) => totalResponse[i] *= val);\n\t\t});\n\t\tfilterClone.dispose();\n\t\treturn totalResponse;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._filters.forEach(filter => {\n\t\t\tfilter.dispose();\n\t\t});\n\t\twritable(this, [\"detune\", \"frequency\", \"gain\", \"Q\"]);\n\t\tthis.frequency.dispose();\n\t\tthis.Q.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.gain.dispose();\n\t\treturn this;\n\t}\n}\n","import { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Frequency, Hertz, NormalRange, Positive, Time } from \"../../core/type/Units\";\nimport { Envelope, EnvelopeOptions } from \"./Envelope\";\nimport { Scale } from \"../../signal/Scale\";\nimport { Pow } from \"../../signal/Pow\";\nimport { assertRange } from \"../../core/util/Debug\";\n\nexport interface FrequencyEnvelopeOptions extends EnvelopeOptions {\n\tbaseFrequency: Frequency;\n\toctaves: number;\n\texponent: number;\n}\n/**\n * FrequencyEnvelope is an [[Envelope]] which ramps between [[baseFrequency]]\n * and [[octaves]]. It can also have an optional [[exponent]] to adjust the curve\n * which it ramps. \n * @example\n * const oscillator = new Tone.Oscillator().toDestination().start();\n * const freqEnv = new Tone.FrequencyEnvelope({\n * \tattack: 0.2,\n * \tbaseFrequency: \"C2\",\n * \toctaves: 4\n * });\n * freqEnv.connect(oscillator.frequency);\n * freqEnv.triggerAttack();\n */\nexport class FrequencyEnvelope extends Envelope {\n\n\treadonly name: string = \"FrequencyEnvelope\";\n\n\t/**\n\t * Private reference to the base frequency as a number\n\t */\n\tprivate _baseFrequency: Hertz;\n\n\t/**\n\t * The number of octaves\n\t */\n\tprivate _octaves: Positive;\n\n\t/**\n\t * Internal scaler from 0-1 to the final output range\n\t */\n\tprivate _scale: Scale;\n\n\t/**\n\t * Apply a power curve to the output\n\t */\n\tprivate _exponent: Pow;\n\n\t/**\n\t * @param attack\tthe attack time in seconds\n\t * @param decay\t\tthe decay time in seconds\n\t * @param sustain \ta percentage (0-1) of the full amplitude\n\t * @param release\tthe release time in seconds\n\t */\n\tconstructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);\n\tconstructor(options?: Partial<FrequencyEnvelopeOptions>)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(FrequencyEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n\t\tconst options = optionsFromArguments(FrequencyEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n\n\t\tthis._octaves = options.octaves;\n\t\tthis._baseFrequency = this.toFrequency(options.baseFrequency);\n\n\t\tthis._exponent = this.input = new Pow({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.exponent\n\t\t});\n\t\tthis._scale = this.output = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmin: this._baseFrequency,\n\t\t\tmax: this._baseFrequency * Math.pow(2, this._octaves),\n\t\t});\n\t\tthis._sig.chain(this._exponent, this._scale);\n\t}\n\n\tstatic getDefaults(): FrequencyEnvelopeOptions {\n\t\treturn Object.assign(Envelope.getDefaults(), {\n\t\t\tbaseFrequency: 200,\n\t\t\texponent: 1,\n\t\t\toctaves: 4,\n\t\t});\n\t}\n\n\t/**\n\t * The envelope's minimum output value. This is the value which it\n\t * starts at.\n\t */\n\tget baseFrequency(): Frequency {\n\t\treturn this._baseFrequency;\n\t}\n\tset baseFrequency(min) {\n\t\tconst freq = this.toFrequency(min);\n\t\tassertRange(freq, 0);\n\t\tthis._baseFrequency = freq;\n\t\tthis._scale.min = this._baseFrequency;\n\t\t// update the max value when the min changes\n\t\tthis.octaves = this._octaves;\n\t}\n\n\t/**\n\t * The number of octaves above the baseFrequency that the\n\t * envelope will scale to.\n\t */\n\tget octaves(): Positive {\n\t\treturn this._octaves;\n\t}\n\tset octaves(octaves: Positive) {\n\t\tassertRange(octaves, 0);\n\t\tthis._octaves = octaves;\n\t\tthis._scale.max = this._baseFrequency * Math.pow(2, octaves);\n\t}\n\n\t/**\n\t * The envelope's exponent value.\n\t */\n\tget exponent(): number {\n\t\treturn this._exponent.value;\n\t}\n\tset exponent(exponent) {\n\t\tthis._exponent.value = exponent;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._exponent.dispose();\n\t\tthis._scale.dispose();\n\t\treturn this;\n\t}\n}\n","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { Filter, FilterOptions } from \"../component/filter/Filter\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface\";\nimport { Monophonic, MonophonicOptions } from \"../instrument/Monophonic\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { Source } from \"../source/Source\";\nimport { FrequencyEnvelope, FrequencyEnvelopeOptions } from \"../component/envelope/FrequencyEnvelope\";\nimport { NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { Signal } from \"../signal/Signal\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { OmniOscillatorSynthOptions } from \"../source/oscillator/OscillatorInterface\";\n\nexport interface MonoSynthOptions extends MonophonicOptions {\n\toscillator: OmniOscillatorSynthOptions;\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tfilterEnvelope: Omit<FrequencyEnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tfilter: Omit<FilterOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * MonoSynth is composed of one `oscillator`, one `filter`, and two `envelopes`.\n * The amplitude of the Oscillator and the cutoff frequency of the\n * Filter are controlled by Envelopes.\n * <img src=\"https://docs.google.com/drawings/d/1gaY1DF9_Hzkodqf8JI1Cg2VZfwSElpFQfI94IQwad38/pub?w=924&h=240\">\n * @example\n * const synth = new Tone.MonoSynth({\n * \toscillator: {\n * \t\ttype: \"square\"\n * \t},\n * \tenvelope: {\n * \t\tattack: 0.1\n * \t}\n * }).toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\nexport class MonoSynth extends Monophonic<MonoSynthOptions> {\n\n\treadonly name = \"MonoSynth\";\n\n\t/**\n\t * The oscillator.\n\t */\n\treadonly oscillator: OmniOscillator<any>;\n\n\t/**\n\t * The frequency control.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune control.\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The filter.\n\t */\n\treadonly filter: Filter;\n\n\t/**\n\t * The filter envelope.\n\t */\n\treadonly filterEnvelope: FrequencyEnvelope;\n\n\t/**\n\t * The amplitude envelope.\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\tconstructor(options?: RecursivePartial<MonoSynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MonoSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(MonoSynth.getDefaults(), arguments);\n\n\t\tthis.oscillator = new OmniOscillator(Object.assign(options.oscillator, {\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tonstop: () => this.onsilence(this),\n\t\t}));\n\t\tthis.frequency = this.oscillator.frequency;\n\t\tthis.detune = this.oscillator.detune;\n\t\tthis.filter = new Filter(Object.assign(options.filter, { context: this.context }));\n\t\tthis.filterEnvelope = new FrequencyEnvelope(Object.assign(options.filterEnvelope, { context: this.context }));\n\t\tthis.envelope = new AmplitudeEnvelope(Object.assign(options.envelope, { context: this.context }));\n\n\t\t// connect the oscillators to the output\n\t\tthis.oscillator.chain(this.filter, this.envelope, this.output);\n\n\t\t// connect the filter envelope\n\t\tthis.filterEnvelope.connect(this.filter.frequency);\n\n\t\treadOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"filter\", \"filterEnvelope\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): MonoSynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.005,\n\t\t\t\t\tdecay: 0.1,\n\t\t\t\t\trelease: 1,\n\t\t\t\t\tsustain: 0.9,\n\t\t\t\t},\n\t\t\t),\n\t\t\tfilter: Object.assign(\n\t\t\t\tomitFromObject(Filter.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tQ: 1,\n\t\t\t\t\trolloff: -12,\n\t\t\t\t\ttype: \"lowpass\",\n\t\t\t\t},\n\t\t\t),\n\t\t\tfilterEnvelope: Object.assign(\n\t\t\t\tomitFromObject(FrequencyEnvelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.6,\n\t\t\t\t\tbaseFrequency: 200,\n\t\t\t\t\tdecay: 0.2,\n\t\t\t\t\texponent: 2,\n\t\t\t\t\toctaves: 3,\n\t\t\t\t\trelease: 2,\n\t\t\t\t\tsustain: 0.5,\n\t\t\t\t}\n\t\t\t),\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), Object.keys(Source.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\ttype: \"sawtooth\",\n\t\t\t\t},\n\t\t\t),\n\t\t});\n\t}\n\n\t/**\n\t * start the attack portion of the envelope\n\t * @param time the time the attack should start\n\t * @param velocity the velocity of the note (0-1)\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity = 1): void {\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\tthis.filterEnvelope.triggerAttack(time);\n\t\tthis.oscillator.start(time);\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tconst computedAttack = this.toSeconds(this.envelope.attack);\n\t\t\tconst computedDecay = this.toSeconds(this.envelope.decay);\n\t\t\tthis.oscillator.stop(time + computedAttack + computedDecay);\n\t\t}\n\t}\n\n\t/**\n\t * start the release portion of the envelope\n\t * @param time the time the release should start\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds): void {\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.filterEnvelope.triggerRelease(time);\n\t\tthis.oscillator.stop(time + this.toSeconds(this.envelope.release));\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.oscillator.dispose();\n\t\tthis.envelope.dispose();\n\t\tthis.filterEnvelope.dispose();\n\t\tthis.filter.dispose();\n\t\treturn this;\n\t}\n}\n","import { Monophonic, MonophonicOptions } from \"./Monophonic\";\nimport { MonoSynth, MonoSynthOptions } from \"./MonoSynth\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Gain, } from \"../core/context/Gain\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Frequency, NormalRange, Positive, Seconds, Time } from \"../core/type/Units\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { Param } from \"../core/context/Param\";\n\nexport interface DuoSynthOptions extends MonophonicOptions {\n\tvoice0: Omit<MonoSynthOptions, keyof MonophonicOptions>;\n\tvoice1: Omit<MonoSynthOptions, keyof MonophonicOptions>;\n\tharmonicity: Positive;\n\tvibratoRate: Frequency;\n\tvibratoAmount: Positive;\n}\n\n/**\n * DuoSynth is a monophonic synth composed of two [[MonoSynths]] run in parallel with control over the\n * frequency ratio between the two voices and vibrato effect.\n * @example\n * const duoSynth = new Tone.DuoSynth().toDestination();\n * duoSynth.triggerAttackRelease(\"C4\", \"2n\");\n * @category Instrument\n */\nexport class DuoSynth extends Monophonic<DuoSynthOptions> {\n\n\treadonly name: string = \"DuoSynth\";\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * the first voice\n\t */\n\treadonly voice0: MonoSynth;\n\n\t/**\n\t * the second voice\n\t */\n\treadonly voice1: MonoSynth;\n\n\t/**\n\t * The amount of vibrato\n\t */\n\tpublic vibratoAmount: Param<\"normalRange\">;\n\n\t/**\n\t * the vibrato frequency\n\t */\n\tpublic vibratoRate: Signal<\"frequency\">;\n\n\t/**\n\t * Harmonicity is the ratio between the two voices. A harmonicity of\n\t * 1 is no change. Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * const duoSynth = new Tone.DuoSynth().toDestination();\n\t * duoSynth.triggerAttackRelease(\"C4\", \"2n\");\n\t * // pitch voice1 an octave below voice0\n\t * duoSynth.harmonicity.value = 0.5;\n\t */\n\tpublic harmonicity: Signal<\"positive\">;\n\n\t/**\n\t * The vibrato LFO.\n\t */\n\tprivate _vibrato: LFO;\n\n\t/**\n\t * the vibrato gain\n\t */\n\tprivate _vibratoGain: Gain<\"normalRange\">;\n\n\tconstructor(options?: RecursivePartial<DuoSynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(DuoSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(DuoSynth.getDefaults(), arguments);\n\n\t\tthis.voice0 = new MonoSynth(Object.assign(options.voice0, {\n\t\t\tcontext: this.context,\n\t\t\tonsilence: () => this.onsilence(this)\n\t\t}));\n\t\tthis.voice1 = new MonoSynth(Object.assign(options.voice1, {\n\t\t\tcontext: this.context,\n\t\t}));\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\tthis._vibrato = new LFO({\n\t\t\tfrequency: options.vibratoRate,\n\t\t\tcontext: this.context,\n\t\t\tmin: -50,\n\t\t\tmax: 50\n\t\t});\n\t\t// start the vibrato immediately\n\t\tthis._vibrato.start();\n\t\tthis.vibratoRate = this._vibrato.frequency;\n\t\tthis._vibratoGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"normalRange\",\n\t\t\tgain: options.vibratoAmount\n\t\t});\n\t\tthis.vibratoAmount = this._vibratoGain.gain;\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: 440\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune\n\t\t});\n\n\t\t// control the two voices frequency\n\t\tthis.frequency.connect(this.voice0.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this.voice1.frequency);\n\n\t\tthis._vibrato.connect(this._vibratoGain);\n\t\tthis._vibratoGain.fan(this.voice0.detune, this.voice1.detune);\n\n\t\tthis.detune.fan(this.voice0.detune, this.voice1.detune);\n\n\t\tthis.voice0.connect(this.output);\n\t\tthis.voice1.connect(this.output);\n\n\t\treadOnly(this, [\"voice0\", \"voice1\", \"frequency\", \"vibratoAmount\", \"vibratoRate\"]);\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.voice0.envelope.getValueAtTime(time) + this.voice1.envelope.getValueAtTime(time);\n\t}\n\n\tstatic getDefaults(): DuoSynthOptions {\n\t\treturn deepMerge(Monophonic.getDefaults(), {\n\t\t\tvibratoAmount: 0.5,\n\t\t\tvibratoRate: 5,\n\t\t\tharmonicity: 1.5,\n\t\t\tvoice0: deepMerge(\n\t\t\t\tomitFromObject(MonoSynth.getDefaults(), Object.keys(Monophonic.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tfilterEnvelope: {\n\t\t\t\t\t\tattack: 0.01,\n\t\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\t\tsustain: 1,\n\t\t\t\t\t\trelease: 0.5\n\t\t\t\t\t},\n\t\t\t\t\tenvelope: {\n\t\t\t\t\t\tattack: 0.01,\n\t\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\t\tsustain: 1,\n\t\t\t\t\t\trelease: 0.5\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\tvoice1: deepMerge(\n\t\t\t\tomitFromObject(MonoSynth.getDefaults(), Object.keys(Monophonic.getDefaults())),\n\t\t\t\t{\n\n\t\t\t\t\tfilterEnvelope: {\n\t\t\t\t\t\tattack: 0.01,\n\t\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\t\tsustain: 1,\n\t\t\t\t\t\trelease: 0.5\n\t\t\t\t\t},\n\t\t\t\t\tenvelope: {\n\t\t\t\t\t\tattack: 0.01,\n\t\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\t\tsustain: 1,\n\t\t\t\t\t\trelease: 0.5\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t}) as DuoSynthOptions;\n\t}\n\t/**\n\t * Trigger the attack portion of the note\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: number): void {\n\t\t// @ts-ignore\n\t\tthis.voice0._triggerEnvelopeAttack(time, velocity);\n\t\t// @ts-ignore\n\t\tthis.voice1._triggerEnvelopeAttack(time, velocity);\n\t}\n\n\t/**\n\t * Trigger the release portion of the note\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds) {\n\t\t// @ts-ignore\n\t\tthis.voice0._triggerEnvelopeRelease(time);\n\t\t// @ts-ignore\n\t\tthis.voice1._triggerEnvelopeRelease(time);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.voice0.dispose();\n\t\tthis.voice1.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._vibrato.dispose();\n\t\tthis.vibratoRate.dispose();\n\t\tthis._vibratoGain.dispose();\n\t\tthis.harmonicity.dispose();\n\t\treturn this;\n\t}\n}\n\n","import { Positive } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { ModulationSynth, ModulationSynthOptions } from \"./ModulationSynth\";\n\nexport interface FMSynthOptions extends ModulationSynthOptions {\n\tmodulationIndex: Positive;\n}\n\n/**\n * FMSynth is composed of two Tone.Synths where one Tone.Synth modulates\n * the frequency of a second Tone.Synth. A lot of spectral content\n * can be explored using the modulationIndex parameter. Read more about\n * frequency modulation synthesis on Sound On Sound: [Part 1](https://web.archive.org/web/20160403123704/http://www.soundonsound.com/sos/apr00/articles/synthsecrets.htm), [Part 2](https://web.archive.org/web/20160403115835/http://www.soundonsound.com/sos/may00/articles/synth.htm).\n *\n * @example\n * const fmSynth = new Tone.FMSynth().toDestination();\n * fmSynth.triggerAttackRelease(\"C5\", \"4n\");\n * \n * @category Instrument\n */\n\nexport class FMSynth extends ModulationSynth<FMSynthOptions> {\n\treadonly name: string = \"FMSynth\";\n\n\t/**\n\t * The modulation index which essentially the depth or amount of the modulation. It is the\n\t * ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t * modulating signal (ma) -- as in ma/mf.\n\t */\n\treadonly modulationIndex: Multiply;\n\n\tconstructor(options?: RecursivePartial<FMSynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(FMSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(FMSynth.getDefaults(), arguments);\n\n\t\tthis.modulationIndex = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.modulationIndex,\n\t\t});\n\n\t\t// control the two voices frequency\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.frequency.chain(this.modulationIndex, this._modulationNode);\n\t\tthis.detune.fan(this._carrier.detune, this._modulator.detune);\n\t\tthis._modulator.connect(this._modulationNode.gain);\n\t\tthis._modulationNode.connect(this._carrier.frequency);\n\t\tthis._carrier.connect(this.output);\n\t}\n\n\tstatic getDefaults(): FMSynthOptions {\n\t\treturn Object.assign(ModulationSynth.getDefaults(), {\n\t\t\tmodulationIndex: 10,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.modulationIndex.dispose();\n\t\treturn this;\n\t}\n}\n","import { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { Filter } from \"../component/filter/Filter\";\nimport { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Frequency, NormalRange, Positive, Seconds, Time } from \"../core/type/Units\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp, RecursivePartial } from \"../core/util/Interface\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Scale } from \"../signal/Scale\";\nimport { Signal } from \"../signal/Signal\";\nimport { FMOscillator } from \"../source/oscillator/FMOscillator\";\nimport { Monophonic, MonophonicOptions } from \"./Monophonic\";\n\nexport interface MetalSynthOptions extends MonophonicOptions {\n\tharmonicity: Positive;\n\tmodulationIndex: Positive;\n\toctaves: number;\n\tresonance: Frequency;\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * Inharmonic ratio of frequencies based on the Roland TR-808\n * Taken from https://ccrma.stanford.edu/papers/tr-808-cymbal-physically-informed-circuit-bendable-digital-model\n */\nconst inharmRatios: number[] = [1.0, 1.483, 1.932, 2.546, 2.630, 3.897];\n\n/**\n * A highly inharmonic and spectrally complex source with a highpass filter\n * and amplitude envelope which is good for making metallophone sounds.\n * Based on CymbalSynth by [@polyrhythmatic](https://github.com/polyrhythmatic).\n * Inspiration from [Sound on Sound](https://shorturl.at/rSZ12).\n * @category Instrument\n */\nexport class MetalSynth extends Monophonic<MetalSynthOptions> {\n\n\treadonly name: string = \"MetalSynth\";\n\n\t/**\n\t * The frequency of the cymbal\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune applied to the oscillators\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The array of FMOscillators\n\t */\n\tprivate _oscillators: FMOscillator[] = [];\n\n\t/**\n\t * The frequency multipliers\n\t */\n\tprivate _freqMultipliers: Multiply[] = [];\n\n\t/**\n\t * The gain node for the envelope.\n\t */\n\tprivate _amplitude: Gain;\n\n\t/**\n\t * Highpass the output\n\t */\n\tprivate _highpass: Filter;\n\n\t/**\n\t * The number of octaves the highpass\n\t * filter frequency ramps\n\t */\n\tprivate _octaves: number;\n\n\t/**\n\t * Scale the body envelope for the highpass filter\n\t */\n\tprivate _filterFreqScaler: Scale;\n\n\t/**\n\t * The envelope which is connected both to the\n\t * amplitude and a highpass filter's cutoff frequency.\n\t * The lower-limit of the filter is controlled by the [[resonance]]\n\t */\n\treadonly envelope: Envelope;\n\n\tconstructor(options?: RecursivePartial<MetalSynthOptions>)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MetalSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(MetalSynth.getDefaults(), arguments);\n\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t});\n\n\t\tthis._amplitude = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: 0,\n\t\t}).connect(this.output);\n\n\t\tthis._highpass = new Filter({\n\t\t\t// Q: -3.0102999566398125,\n\t\t\tQ: 0,\n\t\t\tcontext: this.context,\n\t\t\ttype: \"highpass\",\n\t\t}).connect(this._amplitude);\n\n\t\tfor (let i = 0; i < inharmRatios.length; i++) {\n\t\t\tconst osc = new FMOscillator({\n\t\t\t\tcontext: this.context,\n\t\t\t\tharmonicity: options.harmonicity,\n\t\t\t\tmodulationIndex: options.modulationIndex,\n\t\t\t\tmodulationType: \"square\",\n\t\t\t\tonstop: i === 0 ? () => this.onsilence(this) : noOp,\n\t\t\t\ttype: \"square\",\n\t\t\t});\n\t\t\tosc.connect(this._highpass);\n\t\t\tthis._oscillators[i] = osc;\n\n\t\t\tconst mult = new Multiply({\n\t\t\t\tcontext: this.context,\n\t\t\t\tvalue: inharmRatios[i],\n\t\t\t});\n\t\t\tthis._freqMultipliers[i] = mult;\n\t\t\tthis.frequency.chain(mult, osc.frequency);\n\t\t\tthis.detune.connect(osc.detune);\n\t\t}\n\n\t\tthis._filterFreqScaler = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmax: 7000,\n\t\t\tmin: this.toFrequency(options.resonance),\n\t\t});\n\n\t\tthis.envelope = new Envelope({\n\t\t\tattack: options.envelope.attack,\n\t\t\tattackCurve: \"linear\",\n\t\t\tcontext: this.context,\n\t\t\tdecay: options.envelope.decay,\n\t\t\trelease: options.envelope.release,\n\t\t\tsustain: 0,\n\t\t});\n\n\t\tthis.envelope.chain(this._filterFreqScaler, this._highpass.frequency);\n\t\tthis.envelope.connect(this._amplitude.gain);\n\t\t// set the octaves\n\t\tthis._octaves = options.octaves;\n\t\tthis.octaves = options.octaves;\n\t}\n\n\tstatic getDefaults(): MetalSynthOptions {\n\t\treturn deepMerge(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.001,\n\t\t\t\t\tdecay: 1.4,\n\t\t\t\t\trelease: 0.2,\n\t\t\t\t},\n\t\t\t),\n\t\t\tharmonicity: 5.1,\n\t\t\tmodulationIndex: 32,\n\t\t\toctaves: 1.5,\n\t\t\tresonance: 4000,\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack.\n\t * @param time When the attack should be triggered.\n\t * @param velocity The velocity that the envelope should be triggered at.\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: NormalRange = 1): this {\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\tthis._oscillators.forEach(osc => osc.start(time));\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tthis._oscillators.forEach(osc => {\n\t\t\t\tosc.stop(time + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay));\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Trigger the release of the envelope.\n\t * @param time When the release should be triggered.\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds): this {\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis._oscillators.forEach(osc => osc.stop(time + this.toSeconds(this.envelope.release)));\n\t\treturn this;\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\t/**\n\t * The modulationIndex of the oscillators which make up the source.\n\t * see [[FMOscillator.modulationIndex]]\n\t * @min 1\n\t * @max 100\n\t */\n\tget modulationIndex(): number {\n\t\treturn this._oscillators[0].modulationIndex.value;\n\t}\n\tset modulationIndex(val) {\n\t\tthis._oscillators.forEach(osc => (osc.modulationIndex.value = val));\n\t}\n\n\t/**\n\t * The harmonicity of the oscillators which make up the source.\n\t * see Tone.FMOscillator.harmonicity\n\t * @min 0.1\n\t * @max 10\n\t */\n\tget harmonicity(): number {\n\t\treturn this._oscillators[0].harmonicity.value;\n\t}\n\tset harmonicity(val) {\n\t\tthis._oscillators.forEach(osc => (osc.harmonicity.value = val));\n\t}\n\n\t/**\n\t * The lower level of the highpass filter which is attached to the envelope.\n\t * This value should be between [0, 7000]\n\t * @min 0\n\t * @max 7000\n\t */\n\tget resonance(): Frequency {\n\t\treturn this._filterFreqScaler.min;\n\t}\n\tset resonance(val) {\n\t\tthis._filterFreqScaler.min = this.toFrequency(val);\n\t\tthis.octaves = this._octaves;\n\t}\n\n\t/**\n\t * The number of octaves above the \"resonance\" frequency\n\t * that the filter ramps during the attack/decay envelope\n\t * @min 0\n\t * @max 8\n\t */\n\tget octaves(): number {\n\t\treturn this._octaves;\n\t}\n\tset octaves(val) {\n\t\tthis._octaves = val;\n\t\tthis._filterFreqScaler.max = this._filterFreqScaler.min * Math.pow(2, val);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._oscillators.forEach(osc => osc.dispose());\n\t\tthis._freqMultipliers.forEach(freqMult => freqMult.dispose());\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._filterFreqScaler.dispose();\n\t\tthis._amplitude.dispose();\n\t\tthis.envelope.dispose();\n\t\tthis._highpass.dispose();\n\t\treturn this;\n\t}\n}\n","import { FrequencyClass } from \"../core/type/Frequency\";\nimport { Frequency, Positive, Time } from \"../core/type/Units\";\nimport { deepMerge, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth, SynthOptions } from \"./Synth\";\nimport { range, timeRange } from \"../core/util/Decorator\";\n\nexport interface MembraneSynthOptions extends SynthOptions {\n\tpitchDecay: Time;\n\toctaves: Positive;\n}\n\n/**\n * MembraneSynth makes kick and tom sounds using a single oscillator\n * with an amplitude envelope and frequency ramp. A Tone.OmniOscillator\n * is routed through a Tone.AmplitudeEnvelope to the output. The drum\n * quality of the sound comes from the frequency envelope applied\n * during MembraneSynth.triggerAttack(note). The frequency envelope\n * starts at <code>note * .octaves</code> and ramps to <code>note</code>\n * over the duration of <code>.pitchDecay</code>.\n * @example\n * const synth = new Tone.MembraneSynth().toDestination();\n * synth.triggerAttackRelease(\"C2\", \"8n\");\n * @category Instrument\n */\nexport class MembraneSynth extends Synth<MembraneSynthOptions> {\n\n\treadonly name: string = \"MembraneSynth\";\n\n\t/**\n\t * The number of octaves the pitch envelope ramps.\n\t * @min 0.5\n\t * @max 8\n\t */\n\t@range(0)\n\toctaves: Positive;\n\n\t/**\n\t * The amount of time the frequency envelope takes.\n\t * @min 0\n\t * @max 0.5\n\t */\n\t@timeRange(0)\n\tpitchDecay: Time;\n\n\t/**\n\t * Portamento is ignored in this synth. use pitch decay instead.\n\t */\n\treadonly portamento = 0;\n\n\t/**\n\t * @param options the options available for the synth see defaults\n\t */\n\tconstructor(options?: RecursivePartial<MembraneSynthOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(MembraneSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(MembraneSynth.getDefaults(), arguments);\n\n\t\tthis.pitchDecay = options.pitchDecay;\n\t\tthis.octaves = options.octaves;\n\t\treadOnly(this, [\"oscillator\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): MembraneSynthOptions {\n\t\treturn deepMerge(Monophonic.getDefaults(), Synth.getDefaults(), {\n\t\t\tenvelope: {\n\t\t\t\tattack: 0.001,\n\t\t\t\tattackCurve: \"exponential\",\n\t\t\t\tdecay: 0.4,\n\t\t\t\trelease: 1.4,\n\t\t\t\tsustain: 0.01,\n\t\t\t},\n\t\t\toctaves: 10,\n\t\t\toscillator: {\n\t\t\t\ttype: \"sine\",\n\t\t\t},\n\t\t\tpitchDecay: 0.05,\n\t\t});\n\t}\n\n\tsetNote(note: Frequency | FrequencyClass, time?: Time): this {\n\t\tconst seconds = this.toSeconds(time);\n\t\tconst hertz = this.toFrequency(note instanceof FrequencyClass ? note.toFrequency() : note);\n\t\tconst maxNote = hertz * this.octaves;\n\t\tthis.oscillator.frequency.setValueAtTime(maxNote, seconds);\n\t\tthis.oscillator.frequency.exponentialRampToValueAtTime(hertz, seconds + this.toSeconds(this.pitchDecay));\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\treturn this;\n\t}\n}\n","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { NormalRange, Time } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Noise, NoiseOptions } from \"../source/Noise\";\nimport { Instrument, InstrumentOptions } from \"./Instrument\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { Source } from \"../source/Source\";\n\nexport interface NoiseSynthOptions extends InstrumentOptions {\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tnoise: Omit<NoiseOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * Tone.NoiseSynth is composed of [[Noise]] through an [[AmplitudeEnvelope]]. \n * ```\n * +-------+   +-------------------+\n * | Noise +>--> AmplitudeEnvelope +>--> Output\n * +-------+   +-------------------+\n * ```\n * @example\n * const noiseSynth = new Tone.NoiseSynth().toDestination();\n * noiseSynth.triggerAttackRelease(\"8n\", 0.05);\n * @category Instrument\n */\nexport class NoiseSynth extends Instrument<NoiseSynthOptions> {\n\n\treadonly name = \"NoiseSynth\";\n\n\t/**\n\t * The noise source.\n\t */\n\treadonly noise: Noise;\n\n\t/**\n\t * The amplitude envelope.\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\tconstructor(options?: RecursivePartial<NoiseSynthOptions>)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(NoiseSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(NoiseSynth.getDefaults(), arguments);\n\t\tthis.noise = new Noise(Object.assign({\n\t\t\tcontext: this.context,\n\t\t}, options.noise));\n\n\t\tthis.envelope = new AmplitudeEnvelope(Object.assign({\n\t\t\tcontext: this.context,\n\t\t}, options.envelope));\n\n\t\t// connect the noise to the output\n\t\tthis.noise.chain(this.envelope, this.output);\n\t}\n\n\tstatic getDefaults(): NoiseSynthOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tdecay: 0.1,\n\t\t\t\t\tsustain: 0.0,\n\t\t\t\t},\n\t\t\t),\n\t\t\tnoise: Object.assign(\n\t\t\t\tomitFromObject(Noise.getDefaults(), Object.keys(Source.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\ttype: \"white\",\n\t\t\t\t},\n\t\t\t),\n\t\t});\n\t}\n\n\t/**\n\t * Start the attack portion of the envelopes. Unlike other\n\t * instruments, Tone.NoiseSynth doesn't have a note.\n\t * @example\n\t * const noiseSynth = new Tone.NoiseSynth().toDestination();\n\t * noiseSynth.triggerAttack();\n\t */\n\ttriggerAttack(time?: Time, velocity: NormalRange = 1): this {\n\t\ttime = this.toSeconds(time);\n\t\t// the envelopes\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\t// start the noise\n\t\tthis.noise.start(time);\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tthis.noise.stop(time + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the release portion of the envelopes.\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.noise.stop(time + this.toSeconds(this.envelope.release));\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tthis._syncMethod(\"triggerAttack\", 0);\n\t\tthis._syncMethod(\"triggerRelease\", 0);\n\t\treturn this;\n\t}\n\n\ttriggerAttackRelease(duration: Time, time?: Time, velocity: NormalRange = 1): this {\n\t\ttime = this.toSeconds(time);\n\t\tduration = this.toSeconds(duration);\n\t\tthis.triggerAttack(time, velocity);\n\t\tthis.triggerRelease(time + duration);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.noise.dispose();\n\t\tthis.envelope.dispose();\n\t\treturn this;\n\t}\n}\n","/**\n * All of the classes or functions which are loaded into the AudioWorkletGlobalScope\n */\nconst workletContext: Set<string> = new Set();\n\n/**\n * Add a class to the AudioWorkletGlobalScope\n */\nexport function addToWorklet(classOrFunction: string) {\n\tworkletContext.add(classOrFunction);\n}\n\n/**\n * Register a processor in the AudioWorkletGlobalScope with the given name\n */\nexport function registerProcessor(name: string, classDesc: string) {\n\tconst processor = /* javascript */`registerProcessor(\"${name}\", ${classDesc})`;\n\tworkletContext.add(processor);\n}\n\n/**\n * Get all of the modules which have been registered to the AudioWorkletGlobalScope\n */\nexport function getWorkletGlobalScope(): string {\n\treturn Array.from(workletContext).join(\"\\n\");\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../context/ToneAudioNode\";\nimport { noOp } from \"../util/Interface\";\nimport { getWorkletGlobalScope } from \"./WorkletGlobalScope\";\n\nexport type ToneAudioWorkletOptions = ToneAudioNodeOptions;\n\nexport abstract class ToneAudioWorklet<Options extends ToneAudioWorkletOptions> extends ToneAudioNode<Options> {\n\n\treadonly name: string = \"ToneAudioWorklet\";\n\n\t/**\n\t * The processing node\n\t */\n\tprotected _worklet!: AudioWorkletNode;\n\n\t/**\n\t * A dummy gain node to create a dummy audio param from\n\t */\n\tprivate _dummyGain: GainNode;\n\n\t/**\n\t * A dummy audio param to use when creating Params\n\t */\n\tprotected _dummyParam: AudioParam;\n\n\t/**\n\t * The constructor options for the node\n\t */\n\tprotected workletOptions: Partial<AudioWorkletNodeOptions> = {};\n\n\t/**\n\t * Get the name of the audio worklet\n\t */\n\tprotected abstract _audioWorkletName(): string;\n\n\t/**\n\t * Invoked when the module is loaded and the node is created\n\t */\n\tprotected abstract onReady(node: AudioWorkletNode): void;\n\n\t/**\n\t * Callback which is invoked when there is an error in the processing\n\t */\n\tonprocessorerror: (e: string) => void = noOp;\n\n\tconstructor(options: Options) {\n\t\tsuper(options);\n\n\t\tconst blobUrl = URL.createObjectURL(new Blob([getWorkletGlobalScope()], { type: \"text/javascript\" }));\n\t\tconst name = this._audioWorkletName();\n\n\t\tthis._dummyGain = this.context.createGain();\n\t\tthis._dummyParam = this._dummyGain.gain;\n\n\t\t// Register the processor\n\t\tthis.context.addAudioWorkletModule(blobUrl, name).then(() => {\n\t\t\t// create the worklet when it's read\n\t\t\tif (!this.disposed) {\n\t\t\t\tthis._worklet = this.context.createAudioWorkletNode(name, this.workletOptions);\n\t\t\t\tthis._worklet.onprocessorerror = this.onprocessorerror.bind(this);\n\t\t\t\tthis.onReady(this._worklet);\n\t\t\t}\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dummyGain.disconnect();\n\t\tif (this._worklet) {\n\t\t\tthis._worklet.port.postMessage(\"dispose\");\n\t\t\tthis._worklet.disconnect();\n\t\t}\n\t\treturn this;\n\t}\n\n}\n","import { addToWorklet } from \"./WorkletGlobalScope\";\n\nconst toneAudioWorkletProcessor = /* javascript */ `\n\t/**\n\t * The base AudioWorkletProcessor for use in Tone.js. Works with the [[ToneAudioWorklet]]. \n\t */\n\tclass ToneAudioWorkletProcessor extends AudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\t\n\t\t\tsuper(options);\n\t\t\t/**\n\t\t\t * If the processor was disposed or not. Keep alive until it's disposed.\n\t\t\t */\n\t\t\tthis.disposed = false;\n\t\t   \t/** \n\t\t\t * The number of samples in the processing block\n\t\t\t */\n\t\t\tthis.blockSize = 128;\n\t\t\t/**\n\t\t\t * the sample rate\n\t\t\t */\n\t\t\tthis.sampleRate = sampleRate;\n\n\t\t\tthis.port.onmessage = (event) => {\n\t\t\t\t// when it receives a dispose \n\t\t\t\tif (event.data === \"dispose\") {\n\t\t\t\t\tthis.disposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n`;\n\naddToWorklet(toneAudioWorkletProcessor);\n","import \"./ToneAudioWorkletProcessor.worklet\";\nimport { addToWorklet } from \"./WorkletGlobalScope\";\n\nexport const singleIOProcess = /* javascript */ `\n\t/**\n\t * Abstract class for a single input/output processor. \n\t * has a 'generate' function which processes one sample at a time\n\t */\n\tclass SingleIOProcessor extends ToneAudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(Object.assign(options, {\n\t\t\t\tnumberOfInputs: 1,\n\t\t\t\tnumberOfOutputs: 1\n\t\t\t}));\n\t\t\t/**\n\t\t\t * Holds the name of the parameter and a single value of that\n\t\t\t * parameter at the current sample\n\t\t\t * @type { [name: string]: number }\n\t\t\t */\n\t\t\tthis.params = {}\n\t\t}\n\n\t\t/**\n\t\t * Generate an output sample from the input sample and parameters\n\t\t * @abstract\n\t\t * @param input number\n\t\t * @param channel number\n\t\t * @param parameters { [name: string]: number }\n\t\t * @returns number\n\t\t */\n\t\tgenerate(){}\n\n\t\t/**\n\t\t * Update the private params object with the \n\t\t * values of the parameters at the given index\n\t\t * @param parameters { [name: string]: Float32Array },\n\t\t * @param index number\n\t\t */\n\t\tupdateParams(parameters, index) {\n\t\t\tfor (const paramName in parameters) {\n\t\t\t\tconst param = parameters[paramName];\n\t\t\t\tif (param.length > 1) {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][index];\n\t\t\t\t} else {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Process a single frame of the audio\n\t\t * @param inputs Float32Array[][]\n\t\t * @param outputs Float32Array[][]\n\t\t */\n\t\tprocess(inputs, outputs, parameters) {\n\t\t\tconst input = inputs[0];\n\t\t\tconst output = outputs[0];\n\t\t\t// get the parameter values\n\t\t\tconst channelCount = Math.max(input && input.length || 0, output.length);\n\t\t\tfor (let sample = 0; sample < this.blockSize; sample++) {\n\t\t\t\tthis.updateParams(parameters, sample);\n\t\t\t\tfor (let channel = 0; channel < channelCount; channel++) {\n\t\t\t\t\tconst inputSample = input && input.length ? input[channel][sample] : 0;\n\t\t\t\t\toutput[channel][sample] = this.generate(inputSample, channel, this.params);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn !this.disposed;\n\t\t}\n\t};\n`;\n\naddToWorklet(singleIOProcess);\n","import { addToWorklet } from \"./WorkletGlobalScope\";\n\nconst delayLine = /* javascript */ `\n\t/**\n\t * A multichannel buffer for use within an AudioWorkletProcessor as a delay line\n\t */\n\tclass DelayLine {\n\t\t\n\t\tconstructor(size, channels) {\n\t\t\tthis.buffer = [];\n\t\t\tthis.writeHead = []\n\t\t\tthis.size = size;\n\n\t\t\t// create the empty channels\n\t\t\tfor (let i = 0; i < channels; i++) {\n\t\t\t\tthis.buffer[i] = new Float32Array(this.size);\n\t\t\t\tthis.writeHead[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Push a value onto the end\n\t\t * @param channel number\n\t\t * @param value number\n\t\t */\n\t\tpush(channel, value) {\n\t\t\tthis.writeHead[channel] += 1;\n\t\t\tif (this.writeHead[channel] > this.size) {\n\t\t\t\tthis.writeHead[channel] = 0;\n\t\t\t}\n\t\t\tthis.buffer[channel][this.writeHead[channel]] = value;\n\t\t}\n\n\t\t/**\n\t\t * Get the recorded value of the channel given the delay\n\t\t * @param channel number\n\t\t * @param delay number delay samples\n\t\t */\n\t\tget(channel, delay) {\n\t\t\tlet readHead = this.writeHead[channel] - Math.floor(delay);\n\t\t\tif (readHead < 0) {\n\t\t\t\treadHead += this.size;\n\t\t\t}\n\t\t\treturn this.buffer[channel][readHead];\n\t\t}\n\t}\n`;\n\naddToWorklet(delayLine);\n","import \"../../core/worklet/SingleIOProcessor.worklet\";\nimport \"../../core/worklet/DelayLine.worklet\";\nimport { registerProcessor } from \"../../core/worklet/WorkletGlobalScope\";\n\nexport const workletName = \"feedback-comb-filter\";\n\nconst feedbackCombFilter = /* javascript */`\n\tclass FeedbackCombFilterWorklet extends SingleIOProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(options);\n\t\t\tthis.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);\n\t\t}\n\n\t\tstatic get parameterDescriptors() {\n\t\t\treturn [{\n\t\t\t\tname: \"delayTime\",\n\t\t\t\tdefaultValue: 0.1,\n\t\t\t\tminValue: 0,\n\t\t\t\tmaxValue: 1,\n\t\t\t\tautomationRate: \"k-rate\"\n\t\t\t}, {\n\t\t\t\tname: \"feedback\",\n\t\t\t\tdefaultValue: 0.5,\n\t\t\t\tminValue: 0,\n\t\t\t\tmaxValue: 0.9999,\n\t\t\t\tautomationRate: \"k-rate\"\n\t\t\t}];\n\t\t}\n\n\t\tgenerate(input, channel, parameters) {\n\t\t\tconst delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);\n\t\t\tthis.delayLine.push(channel, input + delayedSample * parameters.feedback);\n\t\t\treturn delayedSample;\n\t\t}\n\t}\n`;\n\nregisterProcessor(workletName, feedbackCombFilter);\n","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { connectSeries, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, RecursivePartial } from \"../../core/util/Interface\";\nimport { ToneAudioWorklet } from \"../../core/worklet/ToneAudioWorklet\";\nimport { workletName } from \"./FeedbackCombFilter.worklet\";\n\nexport interface FeedbackCombFilterOptions extends ToneAudioNodeOptions {\n\tdelayTime: Time;\n\tresonance: NormalRange;\n}\n\n/**\n * Comb filters are basic building blocks for physical modeling. Read more\n * about comb filters on [CCRMA's website](https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html).\n * \n * This comb filter is implemented with the AudioWorkletNode which allows it to have feedback delays less than the \n * Web Audio processing block of 128 samples. There is a polyfill for browsers that don't yet support the \n * AudioWorkletNode, but it will add some latency and have slower performance than the AudioWorkletNode. \n * @category Component\n */\nexport class FeedbackCombFilter extends ToneAudioWorklet<FeedbackCombFilterOptions> {\n\n\treadonly name = \"FeedbackCombFilter\";\n\n\t/**\n\t * The amount of delay of the comb filter.\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\t/**\n\t * The amount of feedback of the delayed signal.\n\t */\n\treadonly resonance: Param<\"normalRange\">;\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\t/**\n\t * @param delayTime The delay time of the filter.\n\t * @param resonance The amount of feedback the filter has.\n\t */\n\tconstructor(delayTime?: Time, resonance?: NormalRange);\n\tconstructor(options?: RecursivePartial<FeedbackCombFilterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(FeedbackCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\"]));\n\t\tconst options = optionsFromArguments(FeedbackCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\"]);\n\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis.output = new Gain({ context: this.context });\n\n\t\tthis.delayTime = new Param<\"time\">({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.delayTime,\n\t\t\tunits: \"time\",\n\t\t\tminValue: 0,\n\t\t\tmaxValue: 1,\n\t\t\tparam: this._dummyParam,\n\t\t\tswappable: true,\n\t\t});\n\n\t\tthis.resonance = new Param<\"normalRange\">({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.resonance,\n\t\t\tunits: \"normalRange\",\n\t\t\tparam: this._dummyParam,\n\t\t\tswappable: true,\n\t\t});\n\n\t\treadOnly(this, [\"resonance\", \"delayTime\"]);\n\t}\n\n\tprotected _audioWorkletName(): string {\n\t\treturn workletName;\n\t}\n\n\t/**\n\t * The default parameters\n\t */\n\tstatic getDefaults(): FeedbackCombFilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdelayTime: 0.1,\n\t\t\tresonance: 0.5,\n\t\t});\n\t}\n\n\tonReady(node: AudioWorkletNode) {\n\t\tconnectSeries(this.input, node, this.output);\n\t\tconst delayTime = node.parameters.get(\"delayTime\") as AudioParam;;\n\t\tthis.delayTime.setParam(delayTime);\n\t\tconst feedback = node.parameters.get(\"feedback\") as AudioParam;;\n\t\tthis.resonance.setParam(feedback);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis.delayTime.dispose();\n\t\tthis.resonance.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Frequency } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Gain } from \"../../core/context/Gain\";\n\nexport type OnePoleFilterType = \"highpass\" | \"lowpass\";\n\nexport interface OnePoleFilterOptions extends ToneAudioNodeOptions {\n\tfrequency: Frequency;\n\ttype: OnePoleFilterType;\n}\n\n/**\n * A one pole filter with 6db-per-octave rolloff. Either \"highpass\" or \"lowpass\". \n * Note that changing the type or frequency may result in a discontinuity which\n * can sound like a click or pop. \n * References: \n * * http://www.earlevel.com/main/2012/12/15/a-one-pole-filter/  \n * * http://www.dspguide.com/ch19/2.htm\n * * https://github.com/vitaliy-bobrov/js-rocks/blob/master/src/app/audio/effects/one-pole-filters.ts\n * @category Component\n */\nexport class OnePoleFilter extends ToneAudioNode<OnePoleFilterOptions> {\n\t\n\treadonly name: string = \"OnePoleFilter\";\n\n\t/**\n\t * Hold the current frequency\n\t */\n\tprivate _frequency: Frequency;\n\n\t/**\n\t * the current one pole type\n\t */\n\tprivate _type: OnePoleFilterType;\n\n\t/**\n\t * the current one pole filter\n\t */\n\tprivate _filter!: IIRFilterNode;\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\t/**\n\t * @param frequency The frequency\n\t * @param type The  filter type, either \"lowpass\" or \"highpass\"\n\t */\n\tconstructor(frequency?: Frequency, type?: OnePoleFilterType);\n\tconstructor(options?: Partial<OnePoleFilterOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(OnePoleFilter.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(OnePoleFilter.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis._frequency = options.frequency;\n\t\tthis._type = options.type;\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis.output = new Gain({ context: this.context });\n\t\tthis._createFilter();\n\t}\n\n\tstatic getDefaults(): OnePoleFilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tfrequency: 880,\n\t\t\ttype: \"lowpass\" as OnePoleFilterType\n\t\t});\n\t}\n\n\t/**\n\t * Create a filter and dispose the old one\n\t */\n\tprivate _createFilter() {\n\t\tconst oldFilter = this._filter;\n\t\tconst freq = this.toFrequency(this._frequency);\n\t\tconst t = 1 / (2 * Math.PI * freq);\n\t\tif (this._type === \"lowpass\") {\n\t\t\tconst a0 = 1 / (t * this.context.sampleRate);\n\t\t\tconst b1 = a0 - 1;\n\t\t\tthis._filter = this.context.createIIRFilter([a0, 0], [1, b1]);\n\t\t} else {\n\t\t\tconst b1 = 1 / (t * this.context.sampleRate) - 1;\n\t\t\tthis._filter = this.context.createIIRFilter([1, -1], [1, b1]);\n\t\t}\n\t\t\n\t\tthis.input.chain(this._filter, this.output);\n\t\tif (oldFilter) {\n\t\t\t// dispose it on the next block\n\t\t\tthis.context.setTimeout(() => {\n\t\t\t\tif (!this.disposed) {\n\t\t\t\t\tthis.input.disconnect(oldFilter);\n\t\t\t\t\toldFilter.disconnect();\n\t\t\t\t}\n\t\t\t}, this.blockTime);\n\t\t}\n\t}\n\n\t/**\n\t * The frequency value. \n\t */\n\tget frequency(): Frequency {\n\t\treturn this._frequency;\n\t}\n\tset frequency(fq) {\n\t\tthis._frequency = fq;\n\t\tthis._createFilter();\n\t}\n\t\n\t/**\n\t * The OnePole Filter type, either \"highpass\" or \"lowpass\"\n\t */\n\tget type(): OnePoleFilterType {\n\t\treturn this._type;\n\t}\n\tset type(t) {\n\t\tthis._type = t;\n\t\tthis._createFilter();\n\t}\n\n\t/**\n\t * Get the frequency response curve. This curve represents how the filter\n\t * responses to frequencies between 20hz-20khz.\n\t * @param  len The number of values to return\n\t * @return The frequency response curve between 20-20kHz\n\t */\n\tgetFrequencyResponse(len = 128): Float32Array {\n\t\tconst freqValues = new Float32Array(len);\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst norm = Math.pow(i / len, 2);\n\t\t\tconst freq = norm * (20000 - 20) + 20;\n\t\t\tfreqValues[i] = freq;\n\t\t}\n\t\tconst magValues = new Float32Array(len);\n\t\tconst phaseValues = new Float32Array(len);\n\t\tthis._filter.getFrequencyResponse(freqValues, magValues, phaseValues);\n\t\treturn magValues;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis._filter.disconnect();\n\t\treturn this;\n\t}\n}\n","import { Param } from \"../../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Frequency, NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { RecursivePartial } from \"../../core/util/Interface\";\nimport { FeedbackCombFilter } from \"./FeedbackCombFilter\";\nimport { OnePoleFilter } from \"./OnePoleFilter\";\n\ninterface LowpassCombFilterOptions extends ToneAudioNodeOptions {\n\tdelayTime: Time;\n\tresonance: NormalRange;\n\tdampening: Frequency;\n}\n\n/**\n * A lowpass feedback comb filter. It is similar to\n * [[FeedbackCombFilter]], but includes a lowpass filter.\n * @category Component\n */\nexport class LowpassCombFilter extends ToneAudioNode<LowpassCombFilterOptions> {\n\n\treadonly name = \"LowpassCombFilter\";\n\n\t/**\n\t * The delay node\n\t */\n\tprivate _combFilter: FeedbackCombFilter;\n\n\t/**\n\t * The lowpass filter\n\t */\n\tprivate _lowpass: OnePoleFilter;\n\n\t/**\n\t * The delayTime of the comb filter.\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\t/**\n\t * The amount of feedback of the delayed signal.\n\t */\n\treadonly resonance: Param<\"normalRange\">;\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * @param delayTime The delay time of the comb filter\n\t * @param resonance The resonance (feedback) of the comb filter\n\t * @param dampening The cutoff of the lowpass filter dampens the signal as it is fedback.\n\t */\n\tconstructor(delayTime?: Time, resonance?: NormalRange, dampening?: Frequency);\n\tconstructor(options?: RecursivePartial<LowpassCombFilterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(LowpassCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\", \"dampening\"]));\n\t\tconst options = optionsFromArguments(LowpassCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\", \"dampening\"]);\n\n\t\tthis._combFilter = this.output = new FeedbackCombFilter({\n\t\t\tcontext: this.context,\n\t\t\tdelayTime: options.delayTime,\n\t\t\tresonance: options.resonance,\n\t\t});\n\t\tthis.delayTime = this._combFilter.delayTime;\n\t\tthis.resonance = this._combFilter.resonance;\n\n\t\tthis._lowpass = this.input = new OnePoleFilter({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.dampening,\n\t\t\ttype: \"lowpass\",\n\t\t});\n\n\t\t// connections\n\t\tthis._lowpass.connect(this._combFilter);\n\t}\n\n\tstatic getDefaults(): LowpassCombFilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdampening: 3000,\n\t\t\tdelayTime: 0.1,\n\t\t\tresonance: 0.5,\n\t\t});\n\t}\n\t\n\t/**\n\t * The dampening control of the feedback\n\t */\n\tget dampening(): Frequency {\n\t\treturn this._lowpass.frequency;\n\t}\n\tset dampening(fq) {\n\t\tthis._lowpass.frequency = fq;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._combFilter.dispose();\n\t\tthis._lowpass.dispose();\n\t\treturn this;\n\t}\n}\n","import { Frequency, NormalRange, Time } from \"../core/type/Units\";\nimport { LowpassCombFilter } from \"../component/filter/LowpassCombFilter\";\nimport { deepMerge } from \"../core/util/Defaults\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Noise } from \"../source/Noise\";\nimport { Instrument, InstrumentOptions } from \"./Instrument\";\n\nexport interface PluckSynthOptions extends InstrumentOptions {\n\tattackNoise: number;\n\tdampening: Frequency;\n\tresonance: NormalRange;\n\trelease: Time;\n}\n\n/**\n * Karplus-String string synthesis.\n * @example\n * const plucky = new Tone.PluckSynth().toDestination();\n * plucky.triggerAttack(\"C4\", \"+0.5\");\n * plucky.triggerAttack(\"C3\", \"+1\");\n * plucky.triggerAttack(\"C2\", \"+1.5\");\n * plucky.triggerAttack(\"C1\", \"+2\");\n * @category Instrument\n */\nexport class PluckSynth extends Instrument<PluckSynthOptions> {\n\n\treadonly name = \"PluckSynth\";\n\n\t/**\n\t * Noise burst at the beginning\n\t */\n\tprivate _noise: Noise;\n\tprivate _lfcf: LowpassCombFilter;\n\n\t/**\n\t * The amount of noise at the attack.\n\t * Nominal range of [0.1, 20]\n\t * @min 0.1\n\t * @max 20\n\t */\n\tattackNoise: number;\n\n\t/**\n\t * The amount of resonance of the pluck. Also correlates to the sustain duration.\n\t */\n\tresonance: NormalRange;\n\n\t/**\n\t * The release time which corresponds to a resonance ramp down to 0\n\t */\n\trelease: Time;\n\n\tconstructor(options?: RecursivePartial<PluckSynthOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PluckSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(PluckSynth.getDefaults(), arguments);\n\n\t\tthis._noise = new Noise({\n\t\t\tcontext: this.context,\n\t\t\ttype: \"pink\"\n\t\t});\n\n\t\tthis.attackNoise = options.attackNoise;\n\n\t\tthis._lfcf = new LowpassCombFilter({\n\t\t\tcontext: this.context,\n\t\t\tdampening: options.dampening,\n\t\t\tresonance: options.resonance,\n\t\t});\n\n\t\tthis.resonance = options.resonance;\n\t\tthis.release = options.release;\n\n\t\tthis._noise.connect(this._lfcf);\n\t\tthis._lfcf.connect(this.output);\n\t}\n\n\tstatic getDefaults(): PluckSynthOptions {\n\t\treturn deepMerge(Instrument.getDefaults(), {\n\t\t\tattackNoise: 1,\n\t\t\tdampening: 4000,\n\t\t\tresonance: 0.7,\n\t\t\trelease: 1,\n\t\t});\n\t}\n\n\t/**\n\t * The dampening control. i.e. the lowpass filter frequency of the comb filter\n\t * @min 0\n\t * @max 7000\n\t */\n\tget dampening(): Frequency {\n\t\treturn this._lfcf.dampening;\n\t}\n\tset dampening(fq) {\n\t\tthis._lfcf.dampening = fq;\n\t}\n\n\ttriggerAttack(note: Frequency, time?: Time): this {\n\t\tconst freq = this.toFrequency(note);\n\t\ttime = this.toSeconds(time);\n\t\tconst delayAmount = 1 / freq;\n\t\tthis._lfcf.delayTime.setValueAtTime(delayAmount, time);\n\t\tthis._noise.start(time);\n\t\tthis._noise.stop(time + delayAmount * this.attackNoise);\n\t\tthis._lfcf.resonance.cancelScheduledValues(time);\n\t\tthis._lfcf.resonance.setValueAtTime(this.resonance, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Ramp down the [[resonance]] to 0 over the duration of the release time.\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis._lfcf.resonance.linearRampTo(0, this.release, time);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._noise.dispose();\n\t\tthis._lfcf.dispose();\n\t\treturn this;\n\t}\n}\n","import { MidiClass } from \"../core/type/Midi\";\nimport { Frequency, MidiNote, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument, InstrumentOptions } from \"./Instrument\";\nimport { MembraneSynth, MembraneSynthOptions } from \"./MembraneSynth\";\nimport { FMSynth, FMSynthOptions } from \"./FMSynth\";\nimport { AMSynth, AMSynthOptions } from \"./AMSynth\";\nimport { MonoSynth, MonoSynthOptions } from \"./MonoSynth\";\nimport { MetalSynth, MetalSynthOptions } from \"./MetalSynth\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth, SynthOptions } from \"./Synth\";\nimport { assert, warn } from \"../core/util/Debug\";\n\ntype VoiceConstructor<V> = {\n\tgetDefaults: () => VoiceOptions<V>;\n} & (new (...args: any[]) => V);\n\ntype OmitMonophonicOptions<T> = Omit<T, \"context\" | \"onsilence\">;\n\ntype VoiceOptions<T> =\n\tT extends MembraneSynth ? MembraneSynthOptions :\n\t\tT extends MetalSynth ? MetalSynthOptions :\n\t\t\tT extends FMSynth ? FMSynthOptions :\n\t\t\t\tT extends MonoSynth ? MonoSynthOptions :\n\t\t\t\t\tT extends AMSynth ? AMSynthOptions :\n\t\t\t\t\t\tT extends Synth ? SynthOptions :\n\t\t\t\t\t\t\tnever;\n\n/**\n * The settable synth options. excludes monophonic options.\n */\ntype PartialVoiceOptions<T> = RecursivePartial<OmitMonophonicOptions<VoiceOptions<T>>>;\n\nexport interface PolySynthOptions<Voice> extends InstrumentOptions {\n\tmaxPolyphony: number;\n\tvoice: VoiceConstructor<Voice>;\n\toptions: PartialVoiceOptions<Voice>;\n}\n\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\nexport class PolySynth<Voice extends Monophonic<any> = Synth> extends Instrument<VoiceOptions<Voice>> {\n\n\treadonly name: string = \"PolySynth\";\n\n\t/**\n\t * The voices which are not currently in use\n\t */\n\tprivate _availableVoices: Voice[] = [];\n\n\t/**\n\t * The currently active voices\n\t */\n\tprivate _activeVoices: Array<{ midi: MidiNote; voice: Voice; released: boolean }> = [];\n\n\t/**\n\t * All of the allocated voices for this synth.\n\t */\n\tprivate _voices: Voice[] = [];\n\n\t/**\n\t * The options that are set on the synth.\n\t */\n\tprivate options: VoiceOptions<Voice>;\n\n\t/**\n\t * The polyphony limit.\n\t */\n\tmaxPolyphony: number;\n\n\t/**\n\t * The voice constructor\n\t */\n\tprivate readonly voice: VoiceConstructor<Voice>;\n\n\t/**\n\t * A voice used for holding the get/set values\n\t */\n\tprivate _dummyVoice: Voice;\n\n\t/**\n\t * The GC timeout. Held so that it could be cancelled when the node is disposed.\n\t */\n\tprivate _gcTimeout = -1;\n\n\t/**\n\t * A moving average of the number of active voices\n\t */\n\tprivate _averageActiveVoices = 0;\n\n\t/**\n\t * @param voice The constructor of the voices\n\t * @param options\tThe options object to set the synth voice\n\t */\n\tconstructor(\n\t\tvoice?: VoiceConstructor<Voice>,\n\t\toptions?: PartialVoiceOptions<Voice>,\n\t);\n\tconstructor(options?: Partial<PolySynthOptions<Voice>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]));\n\t\tconst options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]);\n\n\t\t// check against the old API (pre 14.3.0)\n\t\tassert(!isNumber(options.voice), \"DEPRECATED: The polyphony count is no longer the first argument.\");\n\n\t\tconst defaults = options.voice.getDefaults();\n\t\tthis.options = Object.assign(defaults, options.options) as VoiceOptions<Voice>;\n\t\tthis.voice = options.voice as unknown as VoiceConstructor<Voice>;\n\t\tthis.maxPolyphony = options.maxPolyphony;\n\n\t\t// create the first voice\n\t\tthis._dummyVoice = this._getNextAvailableVoice() as Voice;\n\t\t// remove it from the voices list\n\t\tconst index = this._voices.indexOf(this._dummyVoice);\n\t\tthis._voices.splice(index, 1);\n\t\t// kick off the GC interval\n\t\tthis._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);\n\t}\n\n\tstatic getDefaults(): PolySynthOptions<Synth> {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tmaxPolyphony: 32,\n\t\t\toptions: {},\n\t\t\tvoice: Synth,\n\t\t});\n\t}\n\n\t/**\n\t * The number of active voices.\n\t */\n\tget activeVoices(): number {\n\t\treturn this._activeVoices.length;\n\t}\n\n\t/**\n\t * Invoked when the source is done making sound, so that it can be\n\t * readded to the pool of available voices\n\t */\n\tprivate _makeVoiceAvailable(voice: Voice): void {\n\t\tthis._availableVoices.push(voice);\n\t\t// remove the midi note from 'active voices'\n\t\tconst activeVoiceIndex = this._activeVoices.findIndex((e) => e.voice === voice);\n\t\tthis._activeVoices.splice(activeVoiceIndex, 1);\n\t}\n\n\t/**\n\t * Get an available voice from the pool of available voices.\n\t * If one is not available and the maxPolyphony limit is reached,\n\t * steal a voice, otherwise return null.\n\t */\n\tprivate _getNextAvailableVoice(): Voice | undefined {\n\t\t// if there are available voices, return the first one\n\t\tif (this._availableVoices.length) {\n\t\t\treturn this._availableVoices.shift();\n\t\t} else if (this._voices.length < this.maxPolyphony) {\n\t\t\t// otherwise if there is still more maxPolyphony, make a new voice\n\t\t\tconst voice = new this.voice(Object.assign(this.options, {\n\t\t\t\tcontext: this.context,\n\t\t\t\tonsilence: this._makeVoiceAvailable.bind(this),\n\t\t\t}));\n\t\t\tvoice.connect(this.output);\n\t\t\tthis._voices.push(voice);\n\t\t\treturn voice;\n\t\t} else {\n\t\t\twarn(\"Max polyphony exceeded. Note dropped.\");\n\t\t}\n\t}\n\n\t/**\n\t * Occasionally check if there are any allocated voices which can be cleaned up.\n\t */\n\tprivate _collectGarbage(): void {\n\t\tthis._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n\t\tif (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {\n\t\t\t// take off an available note\n\t\t\tconst firstAvail = this._availableVoices.shift() as Voice;\n\t\t\tconst index = this._voices.indexOf(firstAvail);\n\t\t\tthis._voices.splice(index, 1);\n\t\t\tif (!this.context.isOffline) {\n\t\t\t\tfirstAvail.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Internal method which triggers the attack\n\t */\n\tprivate _triggerAttack(notes: Frequency[], time: Seconds, velocity?: NormalRange): void {\n\t\tnotes.forEach(note => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\tconst voice = this._getNextAvailableVoice();\n\t\t\tif (voice) {\n\t\t\t\tvoice.triggerAttack(note, time, velocity);\n\t\t\t\tthis._activeVoices.push({\n\t\t\t\t\tmidi: midiNote, voice, released: false,\n\t\t\t\t});\n\t\t\t\tthis.log(\"triggerAttack\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Internal method which triggers the release\n\t */\n\tprivate _triggerRelease(notes: Frequency[], time: Seconds): void {\n\t\tnotes.forEach(note => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\tconst event = this._activeVoices.find(({ midi, released }) => midi === midiNote && !released);\n\t\t\tif (event) {\n\t\t\t\t// trigger release on that note\n\t\t\t\tevent.voice.triggerRelease(time);\n\t\t\t\t// mark it as released\n\t\t\t\tevent.released = true;\n\t\t\t\tthis.log(\"triggerRelease\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n\t * to wait for just-in-time scheduling\n\t */\n\tprivate _scheduleEvent(type: \"attack\" | \"release\", notes: Frequency[], time: Seconds, velocity?: NormalRange): void {\n\t\tassert(!this.disposed, \"Synth was already disposed\");\n\t\t// if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n\t\tif (time <= this.now()) {\n\t\t\t// do it immediately\n\t\t\tif (type === \"attack\") {\n\t\t\t\tthis._triggerAttack(notes, time, velocity);\n\t\t\t} else {\n\t\t\t\tthis._triggerRelease(notes, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// schedule it to start in the future\n\t\t\tthis.context.setTimeout(() => {\n\t\t\t\tthis._scheduleEvent(type, notes, time, velocity);\n\t\t\t}, time - this.now());\n\t\t}\n\t}\n\n\t/**\n\t * Trigger the attack portion of the note\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  The start time of the note.\n\t * @param velocity The velocity of the note.\n\t * @example\n\t * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();\n\t * // trigger a chord immediately with a velocity of 0.2\n\t * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], Tone.now(), 0.2);\n\t */\n\ttriggerAttack(notes: Frequency | Frequency[], time?: Time, velocity?: NormalRange): this {\n\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"attack\", notes, computedTime, velocity);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release of the note. Unlike monophonic instruments,\n\t * a note (or array of notes) needs to be passed in as the first argument.\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  When the release will be triggered.\n\t * @example\n\t * @example\n\t * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n\t * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n\t * // trigger the release of the given notes. \n\t * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n\t * poly.triggerRelease(\"F5\", \"+3\");\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"release\", notes, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the attack and release after the specified duration\n\t * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n\t * @param  duration the duration of the note\n\t * @param  time  if no time is given, defaults to now\n\t * @param  velocity the velocity of the attack (0-1)\n\t * @example\n\t * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n\t * // can pass in an array of durations as well\n\t * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency | Frequency[],\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity?: NormalRange,\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tassert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n\t\t\tnotes = notes as Frequency[];\n\t\t\tfor (let i = 0; i < notes.length; i++) {\n\t\t\t\tconst d = duration[Math.min(i, duration.length - 1)];\n\t\t\t\tconst durationSeconds = this.toSeconds(d);\n\t\t\t\tassert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\t\tthis.triggerRelease(notes[i], computedTime + durationSeconds);\n\t\t\t}\n\t\t} else {\n\t\t\tconst durationSeconds = this.toSeconds(duration);\n\t\t\tassert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\tthis.triggerRelease(notes, computedTime + durationSeconds);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\tthis._syncMethod(\"triggerRelease\", 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set a member/attribute of the voices\n\t * @example\n\t * const poly = new Tone.PolySynth().toDestination();\n\t * // set all of the voices using an options object for the synth type\n\t * poly.set({\n\t * \tenvelope: {\n\t * \t\tattack: 0.25\n\t * \t}\n\t * });\n\t * poly.triggerAttackRelease(\"Bb3\", 0.2);\n\t */\n\tset(options: RecursivePartial<VoiceOptions<Voice>>): this {\n\t\t// remove options which are controlled by the PolySynth\n\t\tconst sanitizedOptions = omitFromObject(options, [\"onsilence\", \"context\"]);\n\t\t// store all of the options\n\t\tthis.options = deepMerge(this.options, sanitizedOptions);\n\t\tthis._voices.forEach(voice => voice.set(sanitizedOptions));\n\t\tthis._dummyVoice.set(sanitizedOptions);\n\t\treturn this;\n\t}\n\n\tget(): VoiceOptions<Voice> {\n\t\treturn this._dummyVoice.get();\n\t}\n\n\t/**\n\t * Trigger the release portion of all the currently active voices immediately.\n\t * Useful for silencing the synth.\n\t */\n\treleaseAll(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeVoices.forEach(({ voice }) => {\n\t\t\tvoice.triggerRelease(computedTime);\n\t\t});\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dummyVoice.dispose();\n\t\tthis._voices.forEach(v => v.dispose());\n\t\tthis._activeVoices = [];\n\t\tthis._availableVoices = [];\n\t\tthis.context.clearInterval(this._gcTimeout);\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers\";\nimport { ftomf, intervalToFrequencyRatio } from \"../core/type/Conversions\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { Frequency, Interval, MidiNote, NormalRange, Note, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument\";\nimport { ToneBufferSource, ToneBufferSourceCurve } from \"../source/buffer/ToneBufferSource\";\nimport { timeRange } from \"../core/util/Decorator\";\nimport { assert } from \"../core/util/Debug\";\n\ninterface SamplesMap {\n\t[note: string]: ToneAudioBuffer | AudioBuffer | string;\n\t[midi: number]: ToneAudioBuffer | AudioBuffer | string;\n}\n\nexport interface SamplerOptions extends InstrumentOptions {\n\tattack: Time;\n\trelease: Time;\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n\tbaseUrl: string;\n\tcurve: ToneBufferSourceCurve;\n\turls: SamplesMap;\n}\n\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use [[Player]].\n * @example\n * const sampler = new Tone.Sampler({\n * \turls: {\n * \t\tA1: \"A1.mp3\",\n * \t\tA2: \"A2.mp3\",\n * \t},\n * \tbaseUrl: \"https://tonejs.github.io/audio/casio/\",\n * \tonload: () => {\n * \t\tsampler.triggerAttackRelease([\"C1\", \"E1\", \"G1\", \"B1\"], 0.5);\n * \t}\n * }).toDestination();\n * @category Instrument\n */\nexport class Sampler extends Instrument<SamplerOptions> {\n\n\treadonly name: string = \"Sampler\";\n\n\t/**\n\t * The stored and loaded buffers\n\t */\n\tprivate _buffers: ToneAudioBuffers;\n\n\t/**\n\t * The object of all currently playing BufferSources\n\t */\n\tprivate _activeSources: Map<MidiNote, ToneBufferSource[]> = new Map();\n\n\t/**\n\t * The envelope applied to the beginning of the sample.\n\t * @min 0\n\t * @max 1\n\t */\n\t@timeRange(0)\n\tattack: Time;\n\n\t/**\n\t * The envelope applied to the end of the envelope.\n\t * @min 0\n\t * @max 1\n\t */\n\t@timeRange(0)\n\trelease: Time;\n\n\t/**\n\t * The shape of the attack/release curve.\n\t * Either \"linear\" or \"exponential\"\n\t */\n\tcurve: ToneBufferSourceCurve;\n\n\t/**\n\t * @param samples An object of samples mapping either Midi Note Numbers or\n\t * \t\t\tScientific Pitch Notation to the url of that sample.\n\t * @param onload The callback to invoke when all of the samples are loaded.\n\t * @param baseUrl The root URL of all of the samples, which is prepended to all the URLs.\n\t */\n\tconstructor(samples?: SamplesMap, onload?: () => void, baseUrl?: string);\n\t/**\n\t * @param samples An object of samples mapping either Midi Note Numbers or\n\t * \t\t\tScientific Pitch Notation to the url of that sample.\n\t * @param options The remaining options associated with the sampler\n\t */\n\tconstructor(samples?: SamplesMap, options?: Partial<Omit<SamplerOptions, \"urls\">>);\n\tconstructor(options?: Partial<SamplerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\"));\n\t\tconst options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n\n\t\tconst urlMap = {};\n\t\tObject.keys(options.urls).forEach((note) => {\n\t\t\tconst noteNumber = parseInt(note, 10);\n\t\t\tassert(isNote(note)\n\t\t\t\t|| (isNumber(noteNumber) && isFinite(noteNumber)), `url key is neither a note or midi pitch: ${note}`);\n\t\t\tif (isNote(note)) {\n\t\t\t\t// convert the note name to MIDI\n\t\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\t\turlMap[mid] = options.urls[note];\n\t\t\t} else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n\t\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\t\turlMap[noteNumber] = options.urls[noteNumber];\n\t\t\t}\n\t\t});\n\n\t\tthis._buffers = new ToneAudioBuffers({\n\t\t\turls: urlMap,\n\t\t\tonload: options.onload,\n\t\t\tbaseUrl: options.baseUrl,\n\t\t\tonerror: options.onerror,\n\t\t});\n\t\tthis.attack = options.attack;\n\t\tthis.release = options.release;\n\t\tthis.curve = options.curve;\n\n\t\t// invoke the callback if it's already loaded\n\t\tif (this._buffers.loaded) {\n\t\t\t// invoke onload deferred\n\t\t\tPromise.resolve().then(options.onload);\n\t\t}\n\t}\n\n\tstatic getDefaults(): SamplerOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tattack: 0,\n\t\t\tbaseUrl: \"\",\n\t\t\tcurve: \"exponential\" as \"exponential\",\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\trelease: 0.1,\n\t\t\turls: {},\n\t\t});\n\t}\n\n\t/**\n\t * Returns the difference in steps between the given midi note at the closets sample.\n\t */\n\tprivate _findClosest(midi: MidiNote): Interval {\n\t\t// searches within 8 octaves of the given midi note\n\t\tconst MAX_INTERVAL = 96;\n\t\tlet interval = 0;\n\t\twhile (interval < MAX_INTERVAL) {\n\t\t\t// check above and below\n\t\t\tif (this._buffers.has(midi + interval)) {\n\t\t\t\treturn -interval;\n\t\t\t} else if (this._buffers.has(midi - interval)) {\n\t\t\t\treturn interval;\n\t\t\t}\n\t\t\tinterval++;\n\t\t}\n\t\tthrow new Error(`No available buffers for note: ${midi}`);\n\t}\n\n\t/**\n\t * @param  notes\tThe note to play, or an array of notes.\n\t * @param  time     When to play the note\n\t * @param  velocity The velocity to play the sample back.\n\t */\n\ttriggerAttack(notes: Frequency | Frequency[], time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", notes, time, velocity);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach(note => {\n\t\t\tconst midiFloat = ftomf(new FrequencyClass(this.context, note).toFrequency());\n\t\t\tconst midi = Math.round(midiFloat) as MidiNote;\n\t\t\tconst remainder = midiFloat - midi;\n\t\t\t// find the closest note pitch\n\t\t\tconst difference = this._findClosest(midi);\n\t\t\tconst closestNote = midi - difference;\n\t\t\tconst buffer = this._buffers.get(closestNote);\n\t\t\tconst playbackRate = intervalToFrequencyRatio(difference + remainder);\n\t\t\t// play that note\n\t\t\tconst source = new ToneBufferSource({\n\t\t\t\turl: buffer,\n\t\t\t\tcontext: this.context,\n\t\t\t\tcurve: this.curve,\n\t\t\t\tfadeIn: this.attack,\n\t\t\t\tfadeOut: this.release,\n\t\t\t\tplaybackRate,\n\t\t\t}).connect(this.output);\n\t\t\tsource.start(time, 0, buffer.duration / playbackRate, velocity);\n\t\t\t// add it to the active sources\n\t\t\tif (!isArray(this._activeSources.get(midi))) {\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t\t(this._activeSources.get(midi) as ToneBufferSource[]).push(source);\n\n\t\t\t// remove it when it's done\n\t\t\tsource.onended = () => {\n\t\t\t\tif (this._activeSources && this._activeSources.has(midi)) {\n\t\t\t\t\tconst sources = this._activeSources.get(midi) as ToneBufferSource[];\n\t\t\t\t\tconst index = sources.indexOf(source);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tsources.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param  notes\tThe note to release, or an array of notes.\n\t * @param  time     \tWhen to release the note.\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tthis.log(\"triggerRelease\", notes, time);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach(note => {\n\t\t\tconst midi = new FrequencyClass(this.context, note).toMidi();\n\t\t\t// find the note\n\t\t\tif (this._activeSources.has(midi) && (this._activeSources.get(midi) as ToneBufferSource[]).length) {\n\t\t\t\tconst sources = this._activeSources.get(midi) as ToneBufferSource[];\n\t\t\t\ttime = this.toSeconds(time);\n\t\t\t\tsources.forEach(source => {\n\t\t\t\t\tsource.stop(time);\n\t\t\t\t});\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Release all currently active notes.\n\t * @param  time     \tWhen to release the notes.\n\t */\n\treleaseAll(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeSources.forEach(sources => {\n\t\t\twhile (sources.length) {\n\t\t\t\tconst source = sources.shift() as ToneBufferSource;\n\t\t\t\tsource.stop(computedTime);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\tthis._syncMethod(\"triggerRelease\", 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the attack phase, then after the duration, invoke the release.\n\t * @param  notes\tThe note to play and release, or an array of notes.\n\t * @param  duration The time the note should be held\n\t * @param  time     When to start the attack\n\t * @param  velocity The velocity of the attack\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency[] | Frequency,\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity: NormalRange = 1,\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tassert(isArray(notes), \"notes must be an array when duration is array\");\n\t\t\t(notes as Frequency[]).forEach((note, index) => {\n\t\t\t\tconst d = duration[Math.min(index, duration.length - 1)];\n\t\t\t\tthis.triggerRelease(note, computedTime + this.toSeconds(d));\n\t\t\t});\n\t\t} else {\n\t\t\tthis.triggerRelease(notes, computedTime + this.toSeconds(duration));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a note to the sampler.\n\t * @param  note      The buffer's pitch.\n\t * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n\t * @param  callback  The callback to invoke when the url is loaded.\n\t */\n\tadd(note: Note | MidiNote, url: string | ToneAudioBuffer | AudioBuffer, callback?: () => void): this {\n\t\tassert(isNote(note) || isFinite(note), `note must be a pitch or midi: ${note}`);\n\t\tif (isNote(note)) {\n\t\t\t// convert the note name to MIDI\n\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\tthis._buffers.add(mid, url, callback);\n\t\t} else {\n\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\tthis._buffers.add(note, url, callback);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffers.loaded;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffers.dispose();\n\t\tthis._activeSources.forEach(sources => {\n\t\t\tsources.forEach(source => source.dispose());\n\t\t});\n\t\tthis._activeSources.clear();\n\t\treturn this;\n\t}\n}\n","import \"../core/clock/Transport\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../core/context/ToneWithContext\";\nimport { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { BasicPlaybackState, StateTimeline } from \"../core/util/StateTimeline\";\nimport { isBoolean, isNumber } from \"../core/util/TypeCheck\";\n\nexport type ToneEventCallback<T> = (time: Seconds, value: T) => void;\n\nexport interface ToneEventOptions<T> extends ToneWithContextOptions {\n\tcallback: ToneEventCallback<T>;\n\tloop: boolean | number;\n\tloopEnd: Time;\n\tloopStart: Time;\n\tplaybackRate: Positive;\n\tvalue?: T;\n\tprobability: NormalRange;\n\tmute: boolean;\n\thumanize: boolean | Time;\n}\n\n/**\n * ToneEvent abstracts away this.context.transport.schedule and provides a schedulable\n * callback for a single or repeatable events along the timeline.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * const chordEvent = new Tone.ToneEvent(((time, chord) => {\n * \t// the chord as well as the exact time of the event\n * \t// are passed in as arguments to the callback function\n * \tsynth.triggerAttackRelease(chord, 0.5, time);\n * }), [\"D4\", \"E4\", \"F4\"]);\n * // start the chord at the beginning of the transport timeline\n * chordEvent.start();\n * // loop it every measure for 8 measures\n * chordEvent.loop = 8;\n * chordEvent.loopEnd = \"1m\";\n * @category Event\n */\nexport class ToneEvent<ValueType = any> extends ToneWithContext<ToneEventOptions<ValueType>> {\n\n\treadonly name: string = \"ToneEvent\";\n\n\t/**\n\t * Loop value\n\t */\n\tprotected _loop: boolean | number;\n\n\t/**\n\t * The callback to invoke.\n\t */\n\tcallback: ToneEventCallback<ValueType>;\n\n\t/**\n\t * The value which is passed to the\n\t * callback function.\n\t */\n\tvalue: ValueType;\n\n\t/**\n\t * When the note is scheduled to start.\n\t */\n\tprotected _loopStart: Ticks;\n\n\t/**\n\t * When the note is scheduled to start.\n\t */\n\tprotected _loopEnd: Ticks;\n\n\t/**\n\t * Tracks the scheduled events\n\t */\n\tprotected _state: StateTimeline<{\n\t\tid: number;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The playback speed of the note. A speed of 1\n\t * is no change.\n\t */\n\tprotected _playbackRate: Positive;\n\n\t/**\n\t * A delay time from when the event is scheduled to start\n\t */\n\tprotected _startOffset: Ticks = 0;\n\n\t/**\n\t * private holder of probability value\n\t */\n\tprotected _probability: NormalRange;\n\n\t/**\n\t * the amount of variation from the given time.\n\t */\n\tprotected _humanize: boolean | Time;\n\n\t/**\n\t * If mute is true, the callback won't be invoked.\n\t */\n\tmute: boolean;\n\n\t/**\n\t * @param callback The callback to invoke at the time.\n\t * @param value The value or values which should be passed to the callback function on invocation.\n\t */\n\tconstructor(callback?: ToneEventCallback<ValueType>, value?: ValueType);\n\tconstructor(options?: Partial<ToneEventOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneEvent.getDefaults(), arguments, [\"callback\", \"value\"]));\n\t\tconst options = optionsFromArguments(ToneEvent.getDefaults(), arguments, [\"callback\", \"value\"]);\n\n\t\tthis._loop = options.loop;\n\t\tthis.callback = options.callback;\n\t\tthis.value = options.value;\n\t\tthis._loopStart = this.toTicks(options.loopStart);\n\t\tthis._loopEnd = this.toTicks(options.loopEnd);\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis._probability = options.probability;\n\t\tthis._humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis._state.increasing = true;\n\t\t// schedule the events for the first time\n\t\tthis._rescheduleEvents();\n\t}\n\n\tstatic getDefaults(): ToneEventOptions<any> {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp,\n\t\t\thumanize: false,\n\t\t\tloop: false,\n\t\t\tloopEnd: \"1m\",\n\t\t\tloopStart: 0,\n\t\t\tmute: false,\n\t\t\tplaybackRate: 1,\n\t\t\tprobability: 1,\n\t\t\tvalue: null,\n\t\t});\n\t}\n\n\t/**\n\t * Reschedule all of the events along the timeline\n\t * with the updated values.\n\t * @param after Only reschedules events after the given time.\n\t */\n\tprivate _rescheduleEvents(after: Ticks = -1): void {\n\t\t// if no argument is given, schedules all of the events\n\t\tthis._state.forEachFrom(after, event => {\n\t\t\tlet duration;\n\t\t\tif (event.state === \"started\") {\n\t\t\t\tif (event.id !== -1) {\n\t\t\t\t\tthis.context.transport.clear(event.id);\n\t\t\t\t}\n\t\t\t\tconst startTick = event.time + Math.round(this.startOffset / this._playbackRate);\n\t\t\t\tif (this._loop === true || isNumber(this._loop) && this._loop > 1) {\n\t\t\t\t\tduration = Infinity;\n\t\t\t\t\tif (isNumber(this._loop)) {\n\t\t\t\t\t\tduration = (this._loop) * this._getLoopDuration();\n\t\t\t\t\t}\n\t\t\t\t\tconst nextEvent = this._state.getAfter(startTick);\n\t\t\t\t\tif (nextEvent !== null) {\n\t\t\t\t\t\tduration = Math.min(duration, nextEvent.time - startTick);\n\t\t\t\t\t}\n\t\t\t\t\tif (duration !== Infinity) {\n\t\t\t\t\t\t// schedule a stop since it's finite duration\n\t\t\t\t\t\tthis._state.setStateAtTime(\"stopped\", startTick + duration + 1, { id: -1 });\n\t\t\t\t\t\tduration = new TicksClass(this.context, duration);\n\t\t\t\t\t}\n\t\t\t\t\tconst interval = new TicksClass(this.context, this._getLoopDuration());\n\t\t\t\t\tevent.id = this.context.transport.scheduleRepeat(\n\t\t\t\t\t\tthis._tick.bind(this), interval, new TicksClass(this.context, startTick), duration);\n\t\t\t\t} else {\n\t\t\t\t\tevent.id = this.context.transport.schedule(this._tick.bind(this), new TicksClass(this.context, startTick));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the note, either \"started\" or \"stopped\".\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._state.getValueAtTime(this.context.transport.ticks) as BasicPlaybackState;\n\t}\n\n\t/**\n\t * The start from the scheduled start time.\n\t */\n\tget startOffset(): Ticks {\n\t\treturn this._startOffset;\n\t}\n\tset startOffset(offset) {\n\t\tthis._startOffset = offset;\n\t}\n\n\t/**\n\t * The probability of the notes being triggered.\n\t */\n\tget probability(): NormalRange {\n\t\treturn this._probability;\n\t}\n\tset probability(prob) {\n\t\tthis._probability = prob;\n\t}\n\n\t/**\n\t * If set to true, will apply small random variation\n\t * to the callback time. If the value is given as a time, it will randomize\n\t * by that amount.\n\t * @example\n\t * const event = new Tone.ToneEvent();\n\t * event.humanize = true;\n\t */\n\tget humanize(): Time | boolean {\n\t\treturn this._humanize;\n\t}\n\n\tset humanize(variation) {\n\t\tthis._humanize = variation;\n\t}\n\n\t/**\n\t * Start the note at the given time.\n\t * @param  time  When the event should start.\n\t */\n\tstart(time?: TransportTime | TransportTimeClass): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) === \"stopped\") {\n\t\t\tthis._state.add({\n\t\t\t\tid: -1,\n\t\t\t\tstate: \"started\",\n\t\t\t\ttime: ticks,\n\t\t\t});\n\t\t\tthis._rescheduleEvents(ticks);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the Event at the given time.\n\t * @param  time  When the event should stop.\n\t */\n\tstop(time?: TransportTime | TransportTimeClass): this {\n\t\tthis.cancel(time);\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"stopped\", ticks, { id: -1 });\n\t\t\tconst previousEvent = this._state.getBefore(ticks);\n\t\t\tlet reschedulTime = ticks;\n\t\t\tif (previousEvent !== null) {\n\t\t\t\treschedulTime = previousEvent.time;\n\t\t\t}\n\t\t\tthis._rescheduleEvents(reschedulTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel all scheduled events greater than or equal to the given time\n\t * @param  time  The time after which events will be cancel.\n\t */\n\tcancel(time?: TransportTime | TransportTimeClass): this {\n\t\ttime = defaultArg(time, -Infinity);\n\t\tconst ticks = this.toTicks(time);\n\t\tthis._state.forEachFrom(ticks, event => {\n\t\t\tthis.context.transport.clear(event.id);\n\t\t});\n\t\tthis._state.cancel(ticks);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The callback function invoker. Also\n\t * checks if the Event is done playing\n\t * @param  time  The time of the event in seconds\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tconst ticks = this.context.transport.getTicksAtTime(time);\n\t\tif (!this.mute && this._state.getValueAtTime(ticks) === \"started\") {\n\t\t\tif (this.probability < 1 && Math.random() > this.probability) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.humanize) {\n\t\t\t\tlet variation = 0.02;\n\t\t\t\tif (!isBoolean(this.humanize)) {\n\t\t\t\t\tvariation = this.toSeconds(this.humanize);\n\t\t\t\t}\n\t\t\t\ttime += (Math.random() * 2 - 1) * variation;\n\t\t\t}\n\t\t\tthis.callback(time, this.value);\n\t\t}\n\t}\n\n\t/**\n\t * Get the duration of the loop.\n\t */\n\tprotected _getLoopDuration(): Ticks {\n\t\treturn Math.round((this._loopEnd - this._loopStart) / this._playbackRate);\n\t}\n\n\t/**\n\t * If the note should loop or not\n\t * between ToneEvent.loopStart and\n\t * ToneEvent.loopEnd. If set to true,\n\t * the event will loop indefinitely,\n\t * if set to a number greater than 1\n\t * it will play a specific number of\n\t * times, if set to false, 0 or 1, the\n\t * part will only play once.\n\t */\n\tget loop(): boolean | number {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t\tthis._rescheduleEvents();\n\t}\n\n\t/**\n\t * The playback rate of the note. Defaults to 1.\n\t * @example\n\t * const note = new Tone.ToneEvent();\n\t * note.loop = true;\n\t * // repeat the note twice as fast\n\t * note.playbackRate = 2;\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis._rescheduleEvents();\n\t}\n\n\t/**\n\t * The loopEnd point is the time the event will loop\n\t * if ToneEvent.loop is true.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TicksClass(this.context, this._loopEnd).toSeconds();\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = this.toTicks(loopEnd);\n\t\tif (this._loop) {\n\t\t\tthis._rescheduleEvents();\n\t\t}\n\t}\n\n\t/**\n\t * The time when the loop should start.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TicksClass(this.context, this._loopStart).toSeconds();\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = this.toTicks(loopStart);\n\t\tif (this._loop) {\n\t\t\tthis._rescheduleEvents();\n\t\t}\n\t}\n\n\t/**\n\t * The current progress of the loop interval.\n\t * Returns 0 if the event is not started yet or\n\t * it is not set to loop.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this._loop) {\n\t\t\tconst ticks = this.context.transport.ticks;\n\t\t\tconst lastEvent = this._state.get(ticks);\n\t\t\tif (lastEvent !== null && lastEvent.state === \"started\") {\n\t\t\t\tconst loopDuration = this._getLoopDuration();\n\t\t\t\tconst progress = (ticks - lastEvent.time) % loopDuration;\n\t\t\t\treturn progress / loopDuration;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.cancel();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneEvent } from \"./ToneEvent\";\nimport { NormalRange, Positive, Seconds, Time, TransportTime } from \"../core/type/Units\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../core/context/ToneWithContext\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { BasicPlaybackState } from \"../core/util/StateTimeline\";\n\nexport interface LoopOptions extends ToneWithContextOptions {\n\tcallback: (time: Seconds) => void;\n\tinterval: Time;\n\tplaybackRate: Positive;\n\titerations: number;\n\tprobability: NormalRange;\n\tmute: boolean;\n\thumanize: boolean | Time;\n}\n\n/**\n * Loop creates a looped callback at the \n * specified interval. The callback can be \n * started, stopped and scheduled along\n * the Transport's timeline. \n * @example\n * const loop = new Tone.Loop((time) => {\n * \t// triggered every eighth note. \n * \tconsole.log(time);\n * }, \"8n\").start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Loop<Options extends LoopOptions = LoopOptions> extends ToneWithContext<Options> {\n\n\treadonly name: string = \"Loop\";\n\n\t/**\n\t * The event which produces the callbacks\n\t */\n\tprivate _event: ToneEvent;\n\n\t/**\n\t * The callback to invoke with the next event in the pattern\n\t */\n\tcallback: (time: Seconds) => void\n\n\t/**\n\t * @param callback The callback to invoke at the time.\n\t * @param interval The time between successive callback calls. \n\t */\n\tconstructor(callback?: (time: Seconds) => void, interval?: Time);\n\tconstructor(options?: Partial<LoopOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]));\n\t\tconst options = optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]);\n\n\t\tthis._event = new ToneEvent({\n\t\t\tcontext: this.context,\n\t\t\tcallback: this._tick.bind(this),\n\t\t\tloop: true,\n\t\t\tloopEnd: options.interval,\n\t\t\tplaybackRate: options.playbackRate,\n\t\t\tprobability: options.probability\n\t\t});\n\n\t\tthis.callback = options.callback;\n\t\t// set the iterations\n\t\tthis.iterations = options.iterations;\n\t}\n\n\tstatic getDefaults(): LoopOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tinterval: \"4n\",\n\t\t\tcallback: noOp,\n\t\t\tplaybackRate: 1,\n\t\t\titerations: Infinity,\n\t\t\tprobability: 1,\n\t\t\tmute: false,\n\t\t\thumanize: false\n\t\t});\n\t}\n\n\t/**\n\t * Start the loop at the specified time along the Transport's timeline.\n\t * @param  time  When to start the Loop.\n\t */\n\tstart(time?: TransportTime): this {\n\t\tthis._event.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the loop at the given time.\n\t * @param  time  When to stop the Loop.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tthis._event.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel all scheduled events greater than or equal to the given time\n\t * @param  time  The time after which events will be cancel.\n\t */\n\tcancel(time?: TransportTime): this {\n\t\tthis._event.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal function called when the notes should be called\n\t * @param time  The time the event occurs\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tthis.callback(time);\n\t}\n\n\t/**\n\t * The state of the Loop, either started or stopped.\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._event.state;\n\t}\n\n\t/**\n\t * The progress of the loop as a value between 0-1. 0, when the loop is stopped or done iterating. \n\t */\n\tget progress(): NormalRange {\n\t\treturn this._event.progress;\n\t}\n\n\t/**\n\t * The time between successive callbacks. \n\t * @example\n\t * const loop = new Tone.Loop();\n\t * loop.interval = \"8n\"; // loop every 8n\n\t */\n\tget interval(): Time {\n\t\treturn this._event.loopEnd;\n\t}\n\tset interval(interval) {\n\t\tthis._event.loopEnd = interval;\n\t}\n\n\t/**\n\t * The playback rate of the loop. The normal playback rate is 1 (no change). \n\t * A `playbackRate` of 2 would be twice as fast. \n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._event.playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._event.playbackRate = rate;\n\t}\n\n\t/**\n\t * Random variation +/-0.01s to the scheduled time. \n\t * Or give it a time value which it will randomize by.\n\t */\n\tget humanize(): boolean | Time {\n\t\treturn this._event.humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._event.humanize = variation;\n\t}\n\n\t/**\n\t * The probably of the callback being invoked.\n\t */\n\tget probability(): NormalRange {\n\t\treturn this._event.probability;\n\t}\n\n\tset probability(prob) {\n\t\tthis._event.probability = prob;\n\t}\n\n\t/**\n\t * Muting the Loop means that no callbacks are invoked.\n\t */\n\tget mute(): boolean {\n\t\treturn this._event.mute;\n\t}\n\n\tset mute(mute) {\n\t\tthis._event.mute = mute;\n\t}\n\n\t/**\n\t * The number of iterations of the loop. The default value is `Infinity` (loop forever).\n\t */\n\tget iterations(): number {\n\t\tif (this._event.loop === true) {\n\t\t\treturn Infinity;\n\t\t} else {\n\t\t\treturn this._event.loop as number;\n\t\t}\n\t}\n\tset iterations(iters) {\n\t\tif (iters === Infinity) {\n\t\t\tthis._event.loop = true;\n\t\t} else {\n\t\t\tthis._event.loop = iters;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._event.dispose();\n\t\treturn this;\n\t}\n}\n","import { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isArray, isDefined, isObject, isUndef } from \"../core/util/TypeCheck\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent\";\n\ntype CallbackType<T> =\n\tT extends {\n\t\ttime: Time;\n\t\t[key: string]: any;\n\t} ? T :\n\t\tT extends ArrayLike<any> ? T[1] :\n\t\t\tT extends Time ? null : never;\n\ninterface PartOptions<T> extends Omit<ToneEventOptions<CallbackType<T>>, \"value\"> {\n\tevents: T[];\n}\n\n/**\n * Part is a collection ToneEvents which can be started/stopped and looped as a single unit.\n *\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const part = new Tone.Part(((time, note) => {\n * \t// the notes given as the second element in the array\n * \t// will be passed in as the second argument\n * \tsynth.triggerAttackRelease(note, \"8n\", time);\n * }), [[0, \"C2\"], [\"0:2\", \"C3\"], [\"0:3:2\", \"G2\"]]);\n * @example\n * const synth = new Tone.Synth().toDestination();\n * // use an array of objects as long as the object has a \"time\" attribute\n * const part = new Tone.Part(((time, value) => {\n * \t// the value is an object which contains both the note and the velocity\n * \tsynth.triggerAttackRelease(value.note, \"8n\", time, value.velocity);\n * }), [{ time: 0, note: \"C3\", velocity: 0.9 },\n * \t{ time: \"0:2\", note: \"C4\", velocity: 0.5 }\n * ]).start(0);\n * @category Event\n */\nexport class Part<ValueType = any> extends ToneEvent<ValueType> {\n\n\treadonly name: string = \"Part\";\n\n\t/**\n\t * Tracks the scheduled events\n\t */\n\tprotected _state: StateTimeline<{\n\t\tid: number;\n\t\toffset: number;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The events that belong to this part\n\t */\n\tprivate _events: Set<ToneEvent> = new Set();\n\n\t/**\n\t * @param callback The callback to invoke on each event\n\t * @param events the array of events\n\t */\n\tconstructor(callback?: ToneEventCallback<CallbackType<ValueType>>, value?: ValueType[]);\n\tconstructor(options?: Partial<PartOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]));\n\t\tconst options = optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]);\n\n\t\t// make sure things are assigned in the right order\n\t\tthis._state.increasing = true;\n\n\t\t// add the events\n\t\toptions.events.forEach(event => {\n\t\t\tif (isArray(event)) {\n\t\t\t\tthis.add(event[0], event[1]);\n\t\t\t} else {\n\t\t\t\tthis.add(event);\n\t\t\t}\n\t\t});\n\t}\n\n\tstatic getDefaults(): PartOptions<any> {\n\t\treturn Object.assign(ToneEvent.getDefaults(), {\n\t\t\tevents: [],\n\t\t});\n\t}\n\n\t/**\n\t * Start the part at the given time.\n\t * @param  time    When to start the part.\n\t * @param  offset  The offset from the start of the part to begin playing at.\n\t */\n\tstart(time?: TransportTime, offset?: Time): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) !== \"started\") {\n\t\t\toffset = defaultArg(offset, this._loop ? this._loopStart : 0);\n\t\t\tif (this._loop) {\n\t\t\t\toffset = defaultArg(offset, this._loopStart);\n\t\t\t} else {\n\t\t\t\toffset = defaultArg(offset, 0);\n\t\t\t}\n\t\t\tconst computedOffset = this.toTicks(offset);\n\t\t\tthis._state.add({\n\t\t\t\tid: -1,\n\t\t\t\toffset: computedOffset,\n\t\t\t\tstate: \"started\",\n\t\t\t\ttime: ticks,\n\t\t\t});\n\t\t\tthis._forEach(event => {\n\t\t\t\tthis._startNote(event, ticks, computedOffset);\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the event in the given event at the correct time given\n\t * the ticks and offset and looping.\n\t * @param  event\n\t * @param  ticks\n\t * @param  offset\n\t */\n\tprivate _startNote(event: ToneEvent, ticks: Ticks, offset: Ticks): void {\n\t\tticks -= offset;\n\t\tif (this._loop) {\n\t\t\tif (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {\n\t\t\t\tif (event.startOffset < offset) {\n\t\t\t\t\t// start it on the next loop\n\t\t\t\t\tticks += this._getLoopDuration();\n\t\t\t\t}\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t} else if (event.startOffset < this._loopStart && event.startOffset >= offset) {\n\t\t\t\tevent.loop = false;\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t}\n\t\t} else if (event.startOffset >= offset) {\n\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._startOffset;\n\t}\n\tset startOffset(offset) {\n\t\tthis._startOffset = offset;\n\t\tthis._forEach(event => {\n\t\t\tevent.startOffset += this._startOffset;\n\t\t});\n\t}\n\n\t/**\n\t * Stop the part at the given time.\n\t * @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tthis._state.cancel(ticks);\n\t\tthis._state.setStateAtTime(\"stopped\", ticks);\n\t\tthis._forEach(event => {\n\t\t\tevent.stop(time);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get/Set an Event's value at the given time.\n\t * If a value is passed in and no event exists at\n\t * the given time, one will be created with that value.\n\t * If two events are at the same time, the first one will\n\t * be returned.\n\t * @example\n\t * const part = new Tone.Part();\n\t * part.at(\"1m\"); // returns the part at the first measure\n\t * part.at(\"2m\", \"C2\"); // set the value at \"2m\" to C2.\n\t * // if an event didn't exist at that time, it will be created.\n\t * @param time The time of the event to get or set.\n\t * @param value If a value is passed in, the value of the event at the given time will be set to it.\n\t */\n\tat(time: Time, value?: any): ToneEvent | null {\n\t\tconst timeInTicks = new TransportTimeClass(this.context, time).toTicks();\n\t\tconst tickTime = new TicksClass(this.context, 1).toSeconds();\n\n\t\tconst iterator = this._events.values();\n\t\tlet result = iterator.next();\n\t\twhile (!result.done) {\n\t\t\tconst event = result.value;\n\t\t\tif (Math.abs(timeInTicks - event.startOffset) < tickTime) {\n\t\t\t\tif (isDefined(value)) {\n\t\t\t\t\tevent.value = value;\n\t\t\t\t}\n\t\t\t\treturn event;\n\t\t\t}\n\t\t\tresult = iterator.next();\n\t\t}\n\t\t// if there was no event at that time, create one\n\t\tif (isDefined(value)) {\n\t\t\tthis.add(time, value);\n\t\t\t// return the new event\n\t\t\treturn this.at(time);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Add a an event to the part.\n\t * @param time The time the note should start. If an object is passed in, it should\n\t * \t\thave a 'time' attribute and the rest of the object will be used as the 'value'.\n\t * @param  value\n\t * @example\n\t * const part = new Tone.Part();\n\t * part.add(\"1m\", \"C#+11\");\n\t */\n\tadd(obj: {\n\t\ttime: Time;\n\t\t[key: string]: any;\n\t}): this;\n\tadd(time: Time, value?: any): this;\n\tadd(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (time instanceof Object && Reflect.has(time, \"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\tconst ticks = this.toTicks(time);\n\t\tlet event: ToneEvent;\n\t\tif (value instanceof ToneEvent) {\n\t\t\tevent = value;\n\t\t\tevent.callback = this._tick.bind(this);\n\t\t} else {\n\t\t\tevent = new ToneEvent({\n\t\t\t\tcallback: this._tick.bind(this),\n\t\t\t\tcontext: this.context,\n\t\t\t\tvalue,\n\t\t\t});\n\t\t}\n\t\t// the start offset\n\t\tevent.startOffset = ticks;\n\n\t\t// initialize the values\n\t\tevent.set({\n\t\t\thumanize: this.humanize,\n\t\t\tloop: this.loop,\n\t\t\tloopEnd: this.loopEnd,\n\t\t\tloopStart: this.loopStart,\n\t\t\tplaybackRate: this.playbackRate,\n\t\t\tprobability: this.probability,\n\t\t});\n\n\t\tthis._events.add(event);\n\n\t\t// start the note if it should be played right now\n\t\tthis._restartEvent(event);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Restart the given event\n\t */\n\tprivate _restartEvent(event: ToneEvent): void {\n\t\tthis._state.forEach((stateEvent) => {\n\t\t\tif (stateEvent.state === \"started\") {\n\t\t\t\tthis._startNote(event, stateEvent.time, stateEvent.offset);\n\t\t\t} else {\n\t\t\t\t// stop the note\n\t\t\t\tevent.stop(new TicksClass(this.context, stateEvent.time));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Remove an event from the part. If the event at that time is a Part,\n\t * it will remove the entire part.\n\t * @param time The time of the event\n\t * @param value Optionally select only a specific event value\n\t */\n\tremove(obj: {\n\t\ttime: Time;\n\t\t[key: string]: any;\n\t}): this;\n\tremove(time: Time, value?: any): this;\n\tremove(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (isObject(time) && time.hasOwnProperty(\"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\ttime = this.toTicks(time);\n\t\tthis._events.forEach(event => {\n\t\t\tif (event.startOffset === time) {\n\t\t\t\tif (isUndef(value) || (isDefined(value) && event.value === value)) {\n\t\t\t\t\tthis._events.delete(event);\n\t\t\t\t\tevent.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove all of the notes from the group.\n\t */\n\tclear(): this {\n\t\tthis._forEach(event => event.dispose());\n\t\tthis._events.clear();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel scheduled state change events: i.e. \"start\" and \"stop\".\n\t * @param after The time after which to cancel the scheduled events.\n\t */\n\tcancel(after?: TransportTime | TransportTimeClass): this {\n\t\tthis._forEach(event => event.cancel(after));\n\t\tthis._state.cancel(this.toTicks(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over all of the events\n\t */\n\tprivate _forEach(callback: (event: ToneEvent) => void): this {\n\t\tif (this._events) {\n\t\t\tthis._events.forEach(event => {\n\t\t\t\tif (event instanceof Part) {\n\t\t\t\t\tevent._forEach(callback);\n\t\t\t\t} else {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the attribute of all of the events\n\t * @param  attr  the attribute to set\n\t * @param  value      The value to set it to\n\t */\n\tprivate _setAll(attr: string, value: any): void {\n\t\tthis._forEach(event => {\n\t\t\tevent[attr] = value;\n\t\t});\n\t}\n\n\t/**\n\t * Internal tick method\n\t * @param  time  The time of the event in seconds\n\t */\n\tprotected _tick(time: Seconds, value?: any): void {\n\t\tif (!this.mute) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t * Determine if the event should be currently looping\n\t * given the loop boundries of this Part.\n\t * @param  event  The event to test\n\t */\n\tprivate _testLoopBoundries(event: ToneEvent): void {\n\t\tif (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {\n\t\t\tevent.cancel(0);\n\t\t} else if (event.state === \"stopped\") {\n\t\t\t// reschedule it if it's stopped\n\t\t\tthis._restartEvent(event);\n\t\t}\n\t}\n\n\tget probability(): NormalRange {\n\t\treturn this._probability;\n\t}\n\tset probability(prob) {\n\t\tthis._probability = prob;\n\t\tthis._setAll(\"probability\", prob);\n\t}\n\n\tget humanize(): boolean | Time {\n\t\treturn this._humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._humanize = variation;\n\t\tthis._setAll(\"humanize\", variation);\n\t}\n\n\t/**\n\t * If the part should loop or not\n\t * between Part.loopStart and\n\t * Part.loopEnd. If set to true,\n\t * the part will loop indefinitely,\n\t * if set to a number greater than 1\n\t * it will play a specific number of\n\t * times, if set to false, 0 or 1, the\n\t * part will only play once.\n\t * @example\n\t * const part = new Tone.Part();\n\t * // loop the part 8 times\n\t * part.loop = 8;\n\t */\n\tget loop(): boolean | number {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t\tthis._forEach(event => {\n\t\t\tevent.loopStart = this.loopStart;\n\t\t\tevent.loopEnd = this.loopEnd;\n\t\t\tevent.loop = loop;\n\t\t\tthis._testLoopBoundries(event);\n\t\t});\n\t}\n\n\t/**\n\t * The loopEnd point determines when it will\n\t * loop if Part.loop is true.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TicksClass(this.context, this._loopEnd).toSeconds();\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = this.toTicks(loopEnd);\n\t\tif (this._loop) {\n\t\t\tthis._forEach(event => {\n\t\t\t\tevent.loopEnd = loopEnd;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * The loopStart point determines when it will\n\t * loop if Part.loop is true.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TicksClass(this.context, this._loopStart).toSeconds();\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = this.toTicks(loopStart);\n\t\tif (this._loop) {\n\t\t\tthis._forEach(event => {\n\t\t\t\tevent.loopStart = this.loopStart;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * The playback rate of the part\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis._setAll(\"playbackRate\", rate);\n\t}\n\n\t/**\n\t * The number of scheduled notes in the part.\n\t */\n\tget length(): number {\n\t\treturn this._events.size;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.clear();\n\t\treturn this;\n\t}\n}\n","import { assert } from \"../core/util/Debug\";\nimport { clamp } from \"../core/util/Math\";\n\n/**\n * The name of the patterns\n */\nexport type PatternName = \"up\" | \"down\" | \"upDown\" | \"downUp\" | \"alternateUp\" | \"alternateDown\" | \"random\" | \"randomOnce\" | \"randomWalk\";\n\n/**\n * Start at the first value and go up to the last\n */\nfunction* upPatternGen<T>(values: T[]): IterableIterator<T> {\n\tlet index = 0;\n\twhile (index < values.length) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tindex++;\n\t}\n}\n\n/**\n * Start at the last value and go down to 0\n */\nfunction* downPatternGen<T>(values: T[]): IterableIterator<T> {\n\tlet index = values.length - 1;\n\twhile (index >= 0) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tindex--;\n\t}\n}\n\n/**\n * Infinitely yield the generator\n */\nfunction* infiniteGen<T>(values: T[], gen: typeof upPatternGen): IterableIterator<T> {\n\twhile (true) {\n\t\tyield* gen(values);\n\t}\n}\n\n/**\n * Make sure that the index is in the given range\n */\nfunction clampToArraySize(index: number, values: any[]): number {\n\treturn clamp(index, 0, values.length - 1);\n}\n\n/**\n * Alternate between two generators\n */\nfunction* alternatingGenerator<T>(values: T[], directionUp: boolean): IterableIterator<T> {\n\tlet index = directionUp ? 0 : values.length - 1;\n\twhile (true) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tif (directionUp) {\n\t\t\tindex++;\n\t\t\tif (index >= values.length - 1) {\n\t\t\t\tdirectionUp = false;\n\t\t\t}\n\t\t} else {\n\t\t\tindex--;\n\t\t\tif (index <= 0) {\n\t\t\t\tdirectionUp = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Starting from the bottom move up 2, down 1\n */\nfunction* jumpUp<T>(values: T[]): IterableIterator<T> {\n\tlet index = 0;\n\tlet stepIndex = 0;\n\twhile (index < values.length) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tstepIndex++;\n\t\tindex += (stepIndex % 2 ? 2 : -1);\n\t}\n}\n\n/**\n * Starting from the top move down 2, up 1\n */\nfunction* jumpDown<T>(values: T[]): IterableIterator<T> {\n\tlet index = values.length - 1;\n\tlet stepIndex = 0;\n\twhile (index >= 0) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tstepIndex++;\n\t\tindex += (stepIndex % 2 ? -2 : 1);\n\t}\n}\n\n/**\n * Choose a random index each time\n */\nfunction* randomGen<T>(values: T[]): IterableIterator<T> {\n\twhile (true) {\n\t\tconst randomIndex = Math.floor(Math.random() * values.length);\n\t\tyield values[randomIndex];\n\t}\n}\n\n/**\n * Randomly go through all of the values once before choosing a new random order\n */\nfunction* randomOnce<T>(values: T[]): IterableIterator<T> {\n\t// create an array of indices\n\tconst copy: number[] = [];\n\tfor (let i = 0; i < values.length; i++) {\n\t\tcopy.push(i);\n\t}\n\twhile (copy.length > 0) {\n\t\t// random choose an index, and then remove it so it's not chosen again\n\t\tconst randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n\t\tconst index = clampToArraySize(randVal[0], values);\n\t\tyield values[index];\n\t}\n}\n\n/**\n * Randomly choose to walk up or down 1 index in the values array\n */\nfunction* randomWalk<T>(values: T[]): IterableIterator<T> {\n\t// randomly choose a starting index in the values array\n\tlet index = Math.floor(Math.random() * values.length);\n\twhile (true) {\n\t\tif (index === 0) {\n\t\t\tindex++; // at bottom of array, so force upward step\n\t\t} else if (index === values.length - 1) {\n\t\t\tindex--; // at top of array, so force downward step\n\t\t} else if (Math.random() < 0.5) { // else choose random downward or upward step\n\t\t\tindex--;\n\t\t} else {\n\t\t\tindex++;\n\t\t}\n\t\tyield values[index];\n\t}\n}\n\n/**\n * PatternGenerator returns a generator which will iterate over the given array\n * of values and yield the items according to the passed in pattern\n * @param values An array of values to iterate over\n * @param pattern The name of the pattern use when iterating over\n * @param index Where to start in the offset of the values array\n */\nexport function* PatternGenerator<T>(values: T[], pattern: PatternName = \"up\", index = 0): Iterator<T> {\n\t// safeguards\n\tassert(values.length > 0, \"The array must have more than one value in it\");\n\tswitch (pattern) {\n\t\tcase \"up\" :\n\t\t\tyield* infiniteGen(values, upPatternGen);\n\t\tcase \"down\" :\n\t\t\tyield* infiniteGen(values, downPatternGen);\n\t\tcase \"upDown\" :\n\t\t\tyield* alternatingGenerator(values, true);\n\t\tcase \"downUp\" :\n\t\t\tyield* alternatingGenerator(values, false);\n\t\tcase \"alternateUp\":\n\t\t\tyield* infiniteGen(values, jumpUp);\n\t\tcase \"alternateDown\":\n\t\t\tyield* infiniteGen(values, jumpDown);\n\t\tcase \"random\":\n\t\t\tyield* randomGen(values);\n\t\tcase \"randomOnce\":\n\t\t\tyield* infiniteGen(values, randomOnce);\n\t\tcase \"randomWalk\":\n\t\t\tyield* randomWalk(values);\n\t}\n}\n","import { Loop, LoopOptions } from \"./Loop\";\nimport { PatternGenerator, PatternName } from \"./PatternGenerator\";\nimport { ToneEventCallback } from \"./ToneEvent\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Seconds } from \"../core/type/Units\";\nimport { noOp } from \"../core/util/Interface\";\n\nexport interface PatternOptions<ValueType> extends LoopOptions {\n\tpattern: PatternName;\n\tvalues: ValueType[];\n\tcallback: (time: Seconds, value?: ValueType) => void;\n}\n\n/**\n * Pattern arpeggiates between the given notes\n * in a number of patterns. \n * @example\n * const pattern = new Tone.Pattern((time, note) => {\n * \t// the order of the notes passed in depends on the pattern\n * }, [\"C2\", \"D4\", \"E5\", \"A6\"], \"upDown\");\n * @category Event\n */\nexport class Pattern<ValueType> extends Loop<PatternOptions<ValueType>> {\n\n\treadonly name: string = \"Pattern\";\n\n\t/**\n\t * The pattern generator function\n\t */\n\tprivate _pattern: Iterator<ValueType>;\n\n\t/**\n\t * The current value\n\t */\n\tprivate _value?: ValueType;\n\n\t/**\n\t * Hold the pattern type\n\t */\n\tprivate _type: PatternName;\n\n\t/**\n\t * Hold the values\n\t */\n\tprivate _values: ValueType[];\n\n\t/**\n\t * The callback to be invoked at a regular interval\n\t */\n\tcallback: (time: Seconds, value?: ValueType) => void;\n\n\t/**\n\t * @param  callback The callback to invoke with the event.\n\t * @param  values The values to arpeggiate over.\n\t * @param  pattern  The name of the pattern\n\t */\n\tconstructor(\n\t\tcallback?: ToneEventCallback<ValueType>,\n\t\tvalues?: ValueType[],\n\t\tpattern?: PatternName,\n\t);\n\tconstructor(options?: Partial<PatternOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]));\n\t\tconst options = optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]);\n\n\t\tthis.callback = options.callback;\n\t\tthis._values = options.values;\n\t\tthis._pattern = PatternGenerator(options.values, options.pattern);\n\t\tthis._type = options.pattern;\n\t}\n\n\tstatic getDefaults(): PatternOptions<any> {\n\t\treturn Object.assign(Loop.getDefaults(), {\n\t\t\tpattern: \"up\" as \"up\",\n\t\t\tvalues: [],\n\t\t\tcallback: noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Internal function called when the notes should be called\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tconst value = this._pattern.next() as IteratorResult<ValueType>;\n\t\tthis._value = value.value;\n\t\tthis.callback(time, this._value);\n\t}\n\n\t/**\n\t * The array of events.\n\t */\n\tget values(): ValueType[] {\n\t\treturn this._values;\n\t}\n\tset values(val) {\n\t\tthis._values = val;\n\t\t// reset the pattern\n\t\tthis.pattern = this._type;\n\t}\n\n\t/**\n\t * The current value of the pattern.\n\t */\n\tget value(): ValueType | undefined {\n\t\treturn this._value;\n\t}\n\n\t/**\n\t * The pattern type. See Tone.CtrlPattern for the full list of patterns.\n\t */\n\tget pattern(): PatternName {\n\t\treturn this._type;\n\t}\n\tset pattern(pattern) {\n\t\tthis._type = pattern;\n\t\tthis._pattern = PatternGenerator(this._values, this._type);\n\t}\n}\n\n","import { TicksClass } from \"../core/type/Ticks\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isString } from \"../core/util/TypeCheck\";\nimport { Part } from \"./Part\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent\";\n\ntype SequenceEventDescription<T> = Array<T | Array<T | Array<T | Array<T | Array<T | T[]>>>>>;\n\ninterface SequenceOptions<T> extends Omit<ToneEventOptions<T>, \"value\"> {\n\tloopStart: number;\n\tloopEnd: number;\n\tsubdivision: Time;\n\tevents: SequenceEventDescription<T>;\n}\n\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const seq = new Tone.Sequence((time, note) => {\n * \tsynth.triggerAttackRelease(note, 0.1, time);\n * \t// subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Sequence<ValueType = any> extends ToneEvent<ValueType> {\n\n\treadonly name: string = \"Sequence\";\n\n\t/**\n\t * The subdivison of each note\n\t */\n\tprivate _subdivision: Ticks;\n\n\t/**\n\t * The object responsible for scheduling all of the events\n\t */\n\tprivate _part: Part = new Part({\n\t\tcallback: this._seqCallback.bind(this),\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * private reference to all of the sequence proxies\n\t */\n\tprivate _events: SequenceEventDescription<ValueType> = [];\n\n\t/**\n\t * The proxied array\n\t */\n\tprivate _eventsArray: SequenceEventDescription<ValueType> = [];\n\n\t/**\n\t * @param  callback  The callback to invoke with every note\n\t * @param  sequence  The sequence\n\t * @param  subdivision  The subdivision between which events are placed.\n\t */\n\tconstructor(\n\t\tcallback?: ToneEventCallback<ValueType>,\n\t\tevents?: SequenceEventDescription<ValueType>,\n\t\tsubdivision?: Time,\n\t);\n\tconstructor(options?: Partial<SequenceOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]));\n\t\tconst options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n\n\t\tthis._subdivision = this.toTicks(options.subdivision);\n\n\t\tthis.events = options.events;\n\n\t\t// set all of the values\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis.playbackRate = options.playbackRate;\n\t\tthis.probability = options.probability;\n\t\tthis.humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis.playbackRate = options.playbackRate;\n\t}\n\n\tstatic getDefaults(): SequenceOptions<any> {\n\t\treturn Object.assign(omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n\t\t\tevents: [],\n\t\t\tloop: true,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tsubdivision: \"8n\",\n\t\t});\n\t}\n\n\t/**\n\t * The internal callback for when an event is invoked\n\t */\n\tprivate _seqCallback(time: Seconds, value: any): void {\n\t\tif (value !== null) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t * The sequence\n\t */\n\tget events(): any[] {\n\t\treturn this._events;\n\t}\n\tset events(s) {\n\t\tthis.clear();\n\t\tthis._eventsArray = s;\n\t\tthis._events = this._createSequence(this._eventsArray);\n\t\tthis._eventsUpdated();\n\t}\n\n\t/**\n\t * Start the part at the given time.\n\t * @param  time    When to start the part.\n\t * @param  offset  The offset index to start at\n\t */\n\tstart(time?: TransportTime, offset?: number): this {\n\t\tthis._part.start(time, offset ? this._indexTime(offset) : offset);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the part at the given time.\n\t * @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tthis._part.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The subdivision of the sequence. This can only be\n\t * set in the constructor. The subdivision is the\n\t * interval between successive steps.\n\t */\n\tget subdivision(): Seconds {\n\t\treturn new TicksClass(this.context, this._subdivision).toSeconds();\n\t}\n\n\t/**\n\t * Create a sequence proxy which can be monitored to create subsequences\n\t */\n\tprivate _createSequence(array: any[]): any[] {\n\t\treturn new Proxy(array, {\n\t\t\tget: (target: any[], property: PropertyKey): any => {\n\t\t\t\t// property is index in this case\n\t\t\t\treturn target[property];\n\t\t\t},\n\t\t\tset: (target: any[], property: PropertyKey, value: any): boolean => {\n\t\t\t\tif (isString(property) && isFinite(parseInt(property, 10))) {\n\t\t\t\t\tif (isArray(value)) {\n\t\t\t\t\t\ttarget[property] = this._createSequence(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttarget[property] = value;\n\t\t\t\t}\n\t\t\t\tthis._eventsUpdated();\n\t\t\t\t// return true to accept the changes\n\t\t\t\treturn true;\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * When the sequence has changed, all of the events need to be recreated\n\t */\n\tprivate _eventsUpdated(): void {\n\t\tthis._part.clear();\n\t\tthis._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset);\n\t\t// update the loopEnd\n\t\tthis.loopEnd = this.loopEnd;\n\t}\n\n\t/**\n\t * reschedule all of the events that need to be rescheduled\n\t */\n\tprivate _rescheduleSequence(sequence: any[], subdivision: Ticks, startOffset: Ticks): void {\n\t\tsequence.forEach((value, index) => {\n\t\t\tconst eventOffset = index * (subdivision) + startOffset;\n\t\t\tif (isArray(value)) {\n\t\t\t\tthis._rescheduleSequence(value, subdivision / value.length, eventOffset);\n\t\t\t} else {\n\t\t\t\tconst startTime = new TicksClass(this.context, eventOffset, \"i\").toSeconds();\n\t\t\t\tthis._part.add(startTime, value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get the time of the index given the Sequence's subdivision\n\t * @param  index\n\t * @return The time of that index\n\t */\n\tprivate _indexTime(index: number): Seconds {\n\t\treturn new TicksClass(this.context, index * (this._subdivision) + this.startOffset).toSeconds();\n\t}\n\n\t/**\n\t * Clear all of the events\n\t */\n\tclear(): this {\n\t\tthis._part.clear();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._part.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// PROXY CALLS\n\t//-------------------------------------\n\n\tget loop(): boolean | number {\n\t\treturn this._part.loop;\n\t}\n\tset loop(l) {\n\t\tthis._part.loop = l;\n\t}\n\n\t/**\n\t * The index at which the sequence should start looping\n\t */\n\tget loopStart(): number {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(index) {\n\t\tthis._loopStart = index;\n\t\tthis._part.loopStart = this._indexTime(index);\n\t}\n\n\t/**\n\t * The index at which the sequence should end looping\n\t */\n\tget loopEnd(): number {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(index) {\n\t\tthis._loopEnd = index;\n\t\tif (index === 0) {\n\t\t\tthis._part.loopEnd = this._indexTime(this._eventsArray.length);\n\t\t} else {\n\t\t\tthis._part.loopEnd = this._indexTime(index);\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._part.startOffset;\n\t}\n\tset startOffset(start) {\n\t\tthis._part.startOffset = start;\n\t}\n\n\tget playbackRate(): Positive {\n\t\treturn this._part.playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._part.playbackRate = rate;\n\t}\n\n\tget probability(): NormalRange {\n\t\treturn this._part.probability;\n\t}\n\tset probability(prob) {\n\t\tthis._part.probability = prob;\n\t}\n\n\tget progress(): NormalRange {\n\t\treturn this._part.progress;\n\t}\n\n\tget humanize(): boolean | Time {\n\t\treturn this._part.humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._part.humanize = variation;\n\t}\n\n\t/**\n\t * The number of scheduled events\n\t */\n\tget length(): number {\n\t\treturn this._part.length;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { connect, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { GainToAudio } from \"../../signal/GainToAudio\";\nimport { Signal } from \"../../signal/Signal\";\n\ninterface CrossFadeOptions extends ToneAudioNodeOptions {\n\tfade: NormalRange;\n}\n\n/**\n * Tone.Crossfade provides equal power fading between two inputs.\n * More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).\n * ```\n *                                             +---------+\n *                                            +> input a +>--+\n * +-----------+   +---------------------+     |         |   |\n * | 1s signal +>--> stereoPannerNode  L +>----> gain    |   |\n * +-----------+   |                     |     +---------+   |\n *               +-> pan               R +>-+                |   +--------+\n *               | +---------------------+  |                +---> output +>\n *  +------+     |                          |  +---------+   |   +--------+\n *  | fade +>----+                          | +> input b +>--+\n *  +------+                                |  |         |\n *                                          +--> gain    |\n *                                             +---------+\n * ```\n * @example\n * const crossFade = new Tone.CrossFade().toDestination();\n * // connect two inputs Tone.to a/b\n * const inputA = new Tone.Oscillator(440, \"square\").connect(crossFade.a).start();\n * const inputB = new Tone.Oscillator(440, \"sine\").connect(crossFade.b).start();\n * // use the fade to control the mix between the two\n * crossFade.fade.value = 0.5;\n * @category Component\n */\nexport class CrossFade extends ToneAudioNode<CrossFadeOptions> {\n\n\treadonly name: string = \"CrossFade\";\n\n\t/**\n\t * The crossfading is done by a StereoPannerNode\n\t */\n\tprivate _panner: StereoPannerNode = this.context.createStereoPanner();\n\n\t/**\n\t * Split the output of the panner node into two values used to control the gains.\n\t */\n\tprivate _split: ChannelSplitterNode = this.context.createChannelSplitter(2);\n\n\t/**\n\t * Convert the fade value into an audio range value so it can be connected\n\t * to the panner.pan AudioParam\n\t */\n\tprivate _g2a: GainToAudio = new GainToAudio({ context: this.context });\n\n\t/**\n\t * The input which is at full level when fade = 0\n\t */\n\treadonly a: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The input which is at full level when fade = 1\n\t */\n\treadonly b: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The output is a mix between `a` and `b` at the ratio of `fade`\n\t */\n\treadonly output: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * CrossFade has no input, you must choose either `a` or `b`\n\t */\n\treadonly input: undefined;\n\n\t/**\n\t * The mix between the two inputs. A fade value of 0\n\t * will output 100% crossFade.a and\n\t * a value of 1 will output 100% crossFade.b.\n\t */\n\treadonly fade: Signal<\"normalRange\">;\n\n\tprotected _internalChannels = [this.a, this.b];\n\n\t/**\n\t * @param fade The initial fade value [0, 1].\n\t */\n\tconstructor(fade?: NormalRange);\n\tconstructor(options?: Partial<CrossFadeOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(CrossFade.getDefaults(), arguments, [\"fade\"])));\n\t\tconst options = optionsFromArguments(CrossFade.getDefaults(), arguments, [\"fade\"]);\n\n\t\tthis.fade = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"normalRange\",\n\t\t\tvalue: options.fade,\n\t\t});\n\t\treadOnly(this, \"fade\");\n\n\t\tthis.context.getConstant(1).connect(this._panner);\n\t\tthis._panner.connect(this._split);\n\t\t// this is necessary for standardized-audio-context\n\t\t// doesn't make any difference for the native AudioContext\n\t\t// https://github.com/chrisguttandin/standardized-audio-context/issues/647\n\t\tthis._panner.channelCount = 1;\n\t\tthis._panner.channelCountMode = \"explicit\";\n\t\tconnect(this._split, this.a.gain, 0);\n\t\tconnect(this._split, this.b.gain, 1);\n\n\t\tthis.fade.chain(this._g2a, this._panner.pan);\n\n\t\tthis.a.connect(this.output);\n\t\tthis.b.connect(this.output);\n\t}\n\n\tstatic getDefaults(): CrossFadeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tfade: 0.5,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.a.dispose();\n\t\tthis.b.dispose();\n\t\tthis.output.dispose();\n\t\tthis.fade.dispose();\n\t\tthis._g2a.dispose();\n\t\tthis._panner.disconnect();\n\t\tthis._split.disconnect();\n\t\treturn this;\n\t}\n}\n","import { CrossFade } from \"../component/channel/CrossFade\";\nimport { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Signal } from \"../signal/Signal\";\n\nexport interface EffectOptions extends ToneAudioNodeOptions {\n\twet: NormalRange;\n}\n/**\n * Effect is the base class for effects. Connect the effect between\n * the effectSend and effectReturn GainNodes, then control the amount of\n * effect which goes to the output using the wet control.\n */\nexport abstract class Effect<Options extends EffectOptions>\n\textends ToneAudioNode<Options> {\n\n\treadonly name: string = \"Effect\";\n\n\t/**\n\t * the drywet knob to control the amount of effect\n\t */\n\tprivate _dryWet: CrossFade = new CrossFade({ context: this.context });\n\n\t/**\n\t * The wet control is how much of the effected\n\t * will pass through to the output. 1 = 100% effected\n\t * signal, 0 = 100% dry signal.\n\t */\n\twet: Signal<\"normalRange\"> = this._dryWet.fade;\n\n\t/**\n\t * connect the effectSend to the input of hte effect\n\t */\n\tprotected effectSend: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * connect the output of the effect to the effectReturn\n\t */\n\tprotected effectReturn: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * The effect input node\n\t */\n\tinput: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * The effect output\n\t */\n\toutput = this._dryWet;\n\n\tconstructor(options: EffectOptions) {\n\t\tsuper(options);\n\n\t\t// connections\n\t\tthis.input.fan(this._dryWet.a, this.effectSend);\n\t\tthis.effectReturn.connect(this._dryWet.b);\n\t\tthis.wet.setValueAtTime(options.wet, 0);\n\t\tthis._internalChannels = [this.effectReturn, this.effectSend];\n\t\treadOnly(this, \"wet\");\n\t}\n\n\tstatic getDefaults(): EffectOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\twet: 1,\n\t\t});\n\t}\n\n\t/**\n\t * chains the effect in between the effectSend and effectReturn\n\t */\n\tprotected connectEffect(effect: ToneAudioNode | AudioNode): this {\n\t\t// add it to the internal channels\n\t\tthis._internalChannels.push(effect);\n\t\tthis.effectSend.chain(effect, this.effectReturn);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dryWet.dispose();\n\t\tthis.effectSend.dispose();\n\t\tthis.effectReturn.dispose();\n\t\tthis.wet.dispose();\n\t\treturn this;\n\t}\n}\n","import { Effect, EffectOptions } from \"../effect/Effect\";\nimport { Frequency, NormalRange, Time } from \"../core/type/Units\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { ToneOscillatorType } from \"../source/oscillator/OscillatorInterface\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Param } from \"../core/context/Param\";\n\nexport interface LFOEffectOptions extends EffectOptions {\n\tfrequency: Frequency;\n\ttype: ToneOscillatorType;\n\tdepth: NormalRange;\n}\n\n/**\n * Base class for LFO-based effects.\n */\nexport abstract class LFOEffect<Options extends LFOEffectOptions> extends Effect<Options> {\n\n\treadonly name: string = \"LFOEffect\";\n\n\t/**\n\t * the lfo which drives the filter cutoff\n\t */\n\tprotected _lfo: LFO;\n\n\t/**\n\t * The range of the filter modulating between the min and max frequency. \n\t * 0 = no modulation. 1 = full modulation.\n\t */\n\treadonly depth: Param<\"normalRange\">;\n\n\t/**\n\t * How fast the filter modulates between min and max. \n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\tconstructor(options: LFOEffectOptions) {\n\n\t\tsuper(options);\n\n\t\tthis._lfo = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tamplitude: options.depth,\n\t\t});\n\t\tthis.depth = this._lfo.amplitude;\n\t\tthis.frequency = this._lfo.frequency;\n\n\t\tthis.type = options.type;\n\t\treadOnly(this, [\"frequency\", \"depth\"]);\n\t}\n\n\tstatic getDefaults(): LFOEffectOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tfrequency: 1,\n\t\t\ttype: \"sine\" as ToneOscillatorType,\n\t\t\tdepth: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Start the effect.\n\t */\n\tstart(time?: Time): this {\n\t\tthis._lfo.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the lfo\n\t */\n\tstop(time?: Time): this {\n\t\tthis._lfo.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the filter to the transport. See [[LFO.sync]]\n\t */\n\tsync(): this {\n\t\tthis._lfo.sync();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the filter from the transport.\n\t */\n\tunsync(): this {\n\t\tthis._lfo.unsync();\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the LFO's oscillator: See [[Oscillator.type]]\n\t * @example\n\t * const autoFilter = new Tone.AutoFilter().start().toDestination();\n\t * const noise = new Tone.Noise().start().connect(autoFilter);\n\t * autoFilter.type = \"square\";\n\t */\n\tget type() {\n\t\treturn this._lfo.type;\n\t}\n\tset type(type) {\n\t\tthis._lfo.type = type;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._lfo.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.depth.dispose();\n\t\treturn this;\n\t}\n}\n","import { Frequency, Positive } from \"../core/type/Units\";\nimport { Filter, FilterOptions } from \"../component/filter/Filter\";\nimport { SourceOptions } from \"../source/Source\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFOEffect, LFOEffectOptions } from \"./LFOEffect\";\n\nexport interface AutoFilterOptions extends LFOEffectOptions {\n\tbaseFrequency: Frequency;\n\toctaves: Positive;\n\tfilter: Omit<FilterOptions, keyof SourceOptions | \"frequency\" | \"detune\" | \"gain\">;\n}\n\n/**\n * AutoFilter is a Tone.Filter with a Tone.LFO connected to the filter cutoff frequency.\n * Setting the LFO rate and depth allows for control over the filter modulation rate \n * and depth.\n *\n * @example\n * // create an autofilter and start it's LFO\n * const autoFilter = new Tone.AutoFilter(\"4n\").toDestination().start();\n * // route an oscillator through the filter and start it\n * const oscillator = new Tone.Oscillator().connect(autoFilter).start();\n * @category Effect\n */\nexport class AutoFilter extends LFOEffect<AutoFilterOptions> {\n\n\treadonly name: string = \"AutoFilter\";\n\n\t/**\n\t * The filter node\n\t */\n\treadonly filter: Filter;\n\n\t/**\n\t * The octaves placeholder\n\t */\n\tprivate _octaves!: Positive;\n\n\t/**\n\t * @param frequency The rate of the LFO.\n\t * @param baseFrequency The lower value of the LFOs oscillation\n\t * @param octaves The number of octaves above the baseFrequency\n\t */\n\tconstructor(frequency?: Frequency, baseFrequency?: Frequency, octaves?: Positive);\n\tconstructor(options?: Partial<AutoFilterOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(AutoFilter.getDefaults(), arguments, [\"frequency\", \"baseFrequency\", \"octaves\"]));\n\t\tconst options = optionsFromArguments(AutoFilter.getDefaults(), arguments, [\"frequency\", \"baseFrequency\", \"octaves\"]);\n\n\t\tthis.filter = new Filter(Object.assign(options.filter, {\n\t\t\tcontext: this.context,\n\t\t}));\n\n\t\t// connections\n\t\tthis.connectEffect(this.filter);\n\t\tthis._lfo.connect(this.filter.frequency);\n\t\tthis.octaves = options.octaves;\n\t\tthis.baseFrequency = options.baseFrequency;\n\t}\n\n\tstatic getDefaults(): AutoFilterOptions {\n\t\treturn Object.assign(LFOEffect.getDefaults(), {\n\t\t\tbaseFrequency: 200,\n\t\t\toctaves: 2.6,\n\t\t\tfilter: {\n\t\t\t\ttype: \"lowpass\" as \"lowpass\",\n\t\t\t\trolloff: -12 as -12,\n\t\t\t\tQ: 1,\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * The minimum value of the filter's cutoff frequency.\n\t */\n\tget baseFrequency(): Frequency {\n\t\treturn this._lfo.min;\n\t}\n\tset baseFrequency(freq) {\n\t\tthis._lfo.min = this.toFrequency(freq);\n\t\t// and set the max\n\t\tthis.octaves = this._octaves;\n\t}\n\n\t/**\n\t * The maximum value of the filter's cutoff frequency. \n\t */\n\tget octaves(): Positive {\n\t\treturn this._octaves;\n\t}\n\tset octaves(oct) {\n\t\tthis._octaves = oct;\n\t\tthis._lfo.max = this._lfo.min * Math.pow(2, oct);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.filter.dispose();\n\t\treturn this;\n\t}\n}\n","import { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { AudioRange } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n\ninterface TonePannerOptions extends ToneAudioNodeOptions {\n\tpan: AudioRange;\n\tchannelCount: number;\n}\n\n/**\n * Panner is an equal power Left/Right Panner. It is a wrapper around the StereoPannerNode.\n * @example\n * return Tone.Offline(() => {\n\t* // move the input signal from right to left\n\t* const panner = new Tone.Panner(1).toDestination();\n\t* panner.pan.rampTo(-1, 0.5);\n\t* const osc = new Tone.Oscillator(100).connect(panner).start();\n * }, 0.5, 2);\n * @category Component\n */\nexport class Panner extends ToneAudioNode<TonePannerOptions> {\n\n\treadonly name: string = \"Panner\";\n\n\t/**\n\t * the panner node\n\t */\n\tprivate _panner: StereoPannerNode = this.context.createStereoPanner();\n\treadonly input: StereoPannerNode = this._panner;\n\treadonly output: StereoPannerNode = this._panner;\n\n\t/**\n\t * The pan control. -1 = hard left, 1 = hard right.\n\t * @min -1\n\t * @max 1\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \t// pan hard right\n\t * \tconst panner = new Tone.Panner(1).toDestination();\n\t * \t// pan hard left\n\t * \tpanner.pan.setValueAtTime(-1, 0.25);\n\t * \tconst osc = new Tone.Oscillator(50, \"triangle\").connect(panner).start();\n\t * }, 0.5, 2);\n\t */\n\treadonly pan: Param<\"audioRange\">;\n\n\tconstructor(options?: Partial<TonePannerOptions>);\n\t/**\n\t * @param pan The initial panner value (Defaults to 0 = \"center\").\n\t */\n\tconstructor(pan?: AudioRange);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Panner.getDefaults(), arguments, [\"pan\"])));\n\t\tconst options = optionsFromArguments(Panner.getDefaults(), arguments, [\"pan\"]);\n\n\t\tthis.pan = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.pan,\n\t\t\tvalue: options.pan,\n\t\t\tminValue: -1,\n\t\t\tmaxValue: 1,\n\t\t});\n\n\t\t// this is necessary for standardized-audio-context\n\t\t// doesn't make any difference for the native AudioContext\n\t\t// https://github.com/chrisguttandin/standardized-audio-context/issues/647\n\t\tthis._panner.channelCount = options.channelCount;\n\t\tthis._panner.channelCountMode = \"explicit\";\n\n\t\t// initial value\n\t\treadOnly(this, \"pan\");\n\t}\n\n\tstatic getDefaults(): TonePannerOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tpan: 0,\n\t\t\tchannelCount: 1,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._panner.disconnect();\n\t\tthis.pan.dispose();\n\t\treturn this;\n\t}\n}\n","import { Panner } from \"../component/channel/Panner\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFOEffect, LFOEffectOptions } from \"./LFOEffect\";\nimport { Frequency } from \"../core/type/Units\";\n\nexport interface AutoPannerOptions extends LFOEffectOptions {\n\tchannelCount: number;\n}\n\n/**\n * AutoPanner is a [[Panner]] with an [[LFO]] connected to the pan amount. \n * [Related Reading](https://www.ableton.com/en/blog/autopan-chopper-effect-and-more-liveschool/).\n *\n * @example\n * // create an autopanner and start it\n * const autoPanner = new Tone.AutoPanner(\"4n\").toDestination().start();\n * // route an oscillator through the panner and start it\n * const oscillator = new Tone.Oscillator().connect(autoPanner).start();\n * @category Effect\n */\nexport class AutoPanner extends LFOEffect<AutoPannerOptions> {\n\n\treadonly name: string = \"AutoPanner\";\n\n\t/**\n\t * The filter node\n\t */\n\treadonly _panner: Panner;\n\n\t/**\n\t * @param frequency Rate of left-right oscillation. \n\t */\n\tconstructor(frequency?: Frequency);\n\tconstructor(options?: Partial<AutoPannerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(AutoPanner.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(AutoPanner.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis._panner = new Panner({\n\t\t\tcontext: this.context,\n\t\t\tchannelCount: options.channelCount\n\t\t});\n\t\t// connections\n\t\tthis.connectEffect(this._panner);\n\t\tthis._lfo.connect(this._panner.pan);\n\t\tthis._lfo.min = -1;\n\t\tthis._lfo.max = 1;\n\t}\n\n\tstatic getDefaults(): AutoPannerOptions {\n\t\treturn Object.assign(LFOEffect.getDefaults(), {\n\t\t\tchannelCount: 1\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._panner.dispose();\n\t\treturn this;\n\t}\n}\n\n","import { Time } from \"../../core/type/Units\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OnePoleFilter } from \"../filter/OnePoleFilter\";\nimport { Abs } from \"../../signal/Abs\";\n\nexport interface FollowerOptions extends ToneAudioNodeOptions {\n\tsmoothing: Time;\n}\n\n/**\n * Follower is a simple envelope follower. \n * It's implemented by applying a lowpass filter to the absolute value of the incoming signal. \n * ```\n *          +-----+    +---------------+\n * Input +--> Abs +----> OnePoleFilter +--> Output\n *          +-----+    +---------------+\n * ```\n * @category Component\n */\nexport class Follower extends ToneAudioNode<FollowerOptions> {\n\n\treadonly name: string = \"Follower\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * Private reference to the smoothing parameter\n\t */\n\tprivate _smoothing: Time;\n\n\t/**\n\t * The lowpass filter\n\t */\n\tprivate _lowpass: OnePoleFilter;\n\n\t/**\n\t * The absolute value\n\t */\n\tprivate _abs: Abs;\n\n\t/**\n\t * @param smoothing The rate of change of the follower.\n\t */\n\tconstructor(smoothing?: Time);\n\tconstructor(options?: Partial<FollowerOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Follower.getDefaults(), arguments, [\"smoothing\"]));\n\t\tconst options = optionsFromArguments(Follower.getDefaults(), arguments, [\"smoothing\"]);\n\n\t\tthis._abs = this.input = new Abs({ context: this.context });\n\t\tthis._lowpass = this.output = new OnePoleFilter({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: 1 / this.toSeconds(options.smoothing),\n\t\t\ttype: \"lowpass\"\n\t\t});\n\t\tthis._abs.connect(this._lowpass);\n\t\tthis._smoothing = options.smoothing;\n\t}\n\n\tstatic getDefaults(): FollowerOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsmoothing: 0.05\n\t\t});\n\t}\n\n\t/**\n\t * The amount of time it takes a value change to arrive at the updated value. \n\t */\n\tget smoothing(): Time {\n\t\treturn this._smoothing;\n\t}\n\tset smoothing(smoothing) {\n\t\tthis._smoothing = smoothing;\n\t\tthis._lowpass.frequency = 1 / this.toSeconds(this.smoothing);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._abs.dispose();\n\t\tthis._lowpass.dispose();\n\t\treturn this;\n\t}\n}\n","import { Effect, EffectOptions } from \"./Effect\";\nimport { Filter } from \"../component/filter/Filter\";\nimport { Follower } from \"../component/analysis/Follower\";\nimport { Decibels, Frequency, GainFactor, Hertz, Positive, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Gain } from \"../core/context/Gain\";\nimport { dbToGain, gainToDb } from \"../core/type/Conversions\";\nimport { ScaleExp } from \"../signal/ScaleExp\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface AutoWahOptions extends EffectOptions {\n\tbaseFrequency: Frequency;\n\toctaves: Positive;\n\tsensitivity: Decibels;\n\tQ: Positive;\n\tgain: GainFactor;\n\tfollower: Time;\n}\n\n/**\n * AutoWah connects a [[Follower]] to a [[Filter]]. \n * The frequency of the filter, follows the input amplitude curve. \n * Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna).\n * \n * @example\n * const autoWah = new Tone.AutoWah(50, 6, -30).toDestination();\n * // initialize the synth and connect to autowah\n * const synth = new Tone.Synth().connect(autoWah);\n * // Q value influences the effect of the wah - default is 2\n * autoWah.Q.value = 6;\n * // more audible on higher notes\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Effect\n */\nexport class AutoWah extends Effect<AutoWahOptions> {\n\n\treadonly name: string = \"AutoWah\";\n\n\t/**\n\t * The envelope follower. Set the attack/release\n\t * timing to adjust how the envelope is followed.\n\t */\n\tprivate _follower: Follower;\n\n\t/**\n\t * scales the follower value to the frequency domain\n\t */\n\tprivate _sweepRange: ScaleExp;\n\n\t/**\n\t * Hold the base frequency value\n\t */\n\tprivate _baseFrequency: Hertz;\n\n\t/**\n\t * Private holder for the octave count\n\t */\n\tprivate _octaves: Positive;\n\n\t/**\n\t * the input gain to adjust the sensitivity\n\t */\n\tprivate _inputBoost: Gain;\n\n\t/**\n\t * Private holder for the filter\n\t */\n\tprivate _bandpass: Filter;\n\n\t/**\n\t * The peaking fitler\n\t */\n\tprivate _peaking: Filter;\n\n\t/**\n\t * The gain of the filter.\n\t */\n\treadonly gain: Signal<\"decibels\">;\n\n\t/**\n\t * The quality of the filter.\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * @param baseFrequency The frequency the filter is set to at the low point of the wah\n\t * @param octaves The number of octaves above the baseFrequency the filter will sweep to when fully open. \n\t * @param sensitivity The decibel threshold sensitivity for the incoming signal. Normal range of -40 to 0.\n\t */\n\tconstructor(baseFrequency?: Frequency, octaves?: Positive, sensitivity?: Decibels);\n\tconstructor(options?: Partial<AutoWahOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(AutoWah.getDefaults(), arguments, [\"baseFrequency\", \"octaves\", \"sensitivity\"]));\n\t\tconst options = optionsFromArguments(AutoWah.getDefaults(), arguments, [\"baseFrequency\", \"octaves\", \"sensitivity\"]);\n\n\t\tthis._follower = new Follower({\n\t\t\tcontext: this.context,\n\t\t\tsmoothing: options.follower,\n\t\t});\n\t\tthis._sweepRange = new ScaleExp({\n\t\t\tcontext: this.context,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t\texponent: 0.5,\n\t\t});\n\t\tthis._baseFrequency = this.toFrequency(options.baseFrequency);\n\t\tthis._octaves = options.octaves;\n\t\tthis._inputBoost = new Gain({ context: this.context });\n\t\tthis._bandpass = new Filter({\n\t\t\tcontext: this.context,\n\t\t\trolloff: -48,\n\t\t\tfrequency: 0,\n\t\t\tQ: options.Q,\n\t\t});\n\t\tthis._peaking = new Filter({\n\t\t\tcontext: this.context,\n\t\t\ttype: \"peaking\"\n\t\t});\n\t\tthis._peaking.gain.value = options.gain;\n\t\tthis.gain = this._peaking.gain;\n\t\tthis.Q = this._bandpass.Q;\n\n\t\t// the control signal path\n\t\tthis.effectSend.chain(this._inputBoost, this._follower, this._sweepRange);\n\t\tthis._sweepRange.connect(this._bandpass.frequency);\n\t\tthis._sweepRange.connect(this._peaking.frequency);\n\t\t// the filtered path\n\t\tthis.effectSend.chain(this._bandpass, this._peaking, this.effectReturn);\n\t\t// set the initial value\n\t\tthis._setSweepRange();\n\t\tthis.sensitivity = options.sensitivity;\n\n\t\treadOnly(this, [\"gain\", \"Q\"]);\n\t}\n\n\tstatic getDefaults(): AutoWahOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tbaseFrequency: 100,\n\t\t\toctaves: 6,\n\t\t\tsensitivity: 0,\n\t\t\tQ: 2,\n\t\t\tgain: 2,\n\t\t\tfollower: 0.2,\n\t\t});\n\t}\n\n\t/**\n\t * The number of octaves that the filter will sweep above the baseFrequency.\n\t */\n\tget octaves() {\n\t\treturn this._octaves;\n\t}\n\tset octaves(octaves) {\n\t\tthis._octaves = octaves;\n\t\tthis._setSweepRange();\n\t}\n\n\t/**\n\t * The follower's smoothing time\n\t */\n\tget follower(): Time {\n\t\treturn this._follower.smoothing;\n\t}\n\tset follower(follower) {\n\t\tthis._follower.smoothing = follower;\n\t}\n\n\t/**\n\t * The base frequency from which the sweep will start from.\n\t */\n\tget baseFrequency(): Frequency {\n\t\treturn this._baseFrequency;\n\t}\n\tset baseFrequency(baseFreq) {\n\t\tthis._baseFrequency = this.toFrequency(baseFreq);\n\t\tthis._setSweepRange();\n\t}\n\n\t/**\n\t * The sensitivity to control how responsive to the input signal the filter is.\n\t */\n\tget sensitivity(): Decibels {\n\t\treturn gainToDb(1 / this._inputBoost.gain.value);\n\t}\n\tset sensitivity(sensitivity) {\n\t\tthis._inputBoost.gain.value = 1 / dbToGain(sensitivity);\n\t}\n\n\t/**\n\t * sets the sweep range of the scaler\n\t */\n\tprivate _setSweepRange() {\n\t\tthis._sweepRange.min = this._baseFrequency;\n\t\tthis._sweepRange.max = Math.min(this._baseFrequency * Math.pow(2, this._octaves), this.context.sampleRate / 2);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._follower.dispose();\n\t\tthis._sweepRange.dispose();\n\t\tthis._bandpass.dispose();\n\t\tthis._peaking.dispose();\n\t\tthis._inputBoost.dispose();\n\t\treturn this;\n\t}\n}\n","import \"../core/worklet/SingleIOProcessor.worklet\";\nimport { registerProcessor } from \"../core/worklet/WorkletGlobalScope\";\n\nexport const workletName = \"bit-crusher\";\n\nexport const bitCrusherWorklet = /* javascript */`\n\tclass BitCrusherWorklet extends SingleIOProcessor {\n\n\t\tstatic get parameterDescriptors() {\n\t\t\treturn [{\n\t\t\t\tname: \"bits\",\n\t\t\t\tdefaultValue: 12,\n\t\t\t\tminValue: 1,\n\t\t\t\tmaxValue: 16,\n\t\t\t\tautomationRate: 'k-rate'\n\t\t\t}];\n\t\t}\n\n\t\tgenerate(input, _channel, parameters) {\n\t\t\tconst step = Math.pow(0.5, parameters.bits - 1);\n\t\t\tconst val = step * Math.floor(input / step + 0.5);\n\t\t\treturn val;\n\t\t}\n\t}\n`;\n\nregisterProcessor(workletName, bitCrusherWorklet);\n","import { ToneAudioWorklet, ToneAudioWorkletOptions } from \"../core/worklet/ToneAudioWorklet\";\nimport { Effect, EffectOptions } from \"./Effect\";\nimport { Positive } from \"../core/type/Units\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { connectSeries } from \"../core/context/ToneAudioNode\";\nimport { Param } from \"../core/context/Param\";\nimport { workletName } from \"./BitCrusher.worklet\";\n\nexport interface BitCrusherOptions extends EffectOptions {\n\tbits: Positive;\n}\n\n/**\n * BitCrusher down-samples the incoming signal to a different bit depth.\n * Lowering the bit depth of the signal creates distortion. Read more about BitCrushing\n * on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).\n * @example\n * // initialize crusher and route a synth through it\n * const crusher = new Tone.BitCrusher(4).toDestination();\n * const synth = new Tone.Synth().connect(crusher);\n * synth.triggerAttackRelease(\"C2\", 2);\n * \n * @category Effect\n */\nexport class BitCrusher extends Effect<BitCrusherOptions> {\n\n\treadonly name: string = \"BitCrusher\";\n\n\t/**\n\t * The bit depth of the effect\n\t * @min 1\n\t * @max 16\n\t */\n\treadonly bits: Param<\"positive\">;\n\n\t/**\n\t * The node which does the bit crushing effect. Runs in an AudioWorklet when possible.\n\t */\n\tprivate _bitCrusherWorklet: BitCrusherWorklet;\n\n\tconstructor(bits?: Positive);\n\tconstructor(options?: Partial<BitCrusherWorkletOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"]));\n\t\tconst options = optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"]);\n\n\t\tthis._bitCrusherWorklet = new BitCrusherWorklet({\n\t\t\tcontext: this.context,\n\t\t\tbits: options.bits,\n\t\t});\n\t\t// connect it up\n\t\tthis.connectEffect(this._bitCrusherWorklet);\n\n\t\tthis.bits = this._bitCrusherWorklet.bits;\n\t}\n\n\tstatic getDefaults(): BitCrusherOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tbits: 4,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._bitCrusherWorklet.dispose();\n\t\treturn this;\n\t}\n}\n\ninterface BitCrusherWorkletOptions extends ToneAudioWorkletOptions {\n\tbits: number;\n}\n\n/**\n * Internal class which creates an AudioWorklet to do the bit crushing\n */\nclass BitCrusherWorklet extends ToneAudioWorklet<BitCrusherWorkletOptions> {\n\n\treadonly name: string = \"BitCrusherWorklet\";\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\treadonly bits: Param<\"positive\">;\n\n\tconstructor(options?: Partial<BitCrusherWorkletOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments);\n\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis.output = new Gain({ context: this.context });\n\n\t\tthis.bits = new Param<\"positive\">({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.bits,\n\t\t\tunits: \"positive\",\n\t\t\tminValue: 1,\n\t\t\tmaxValue: 16,\n\t\t\tparam: this._dummyParam,\n\t\t\tswappable: true,\n\t\t});\n\t}\n\n\tstatic getDefaults(): BitCrusherWorkletOptions {\n\t\treturn Object.assign(ToneAudioWorklet.getDefaults(), {\n\t\t\tbits: 12,\n\t\t});\n\t}\n\n\tprotected _audioWorkletName(): string {\n\t\treturn workletName;\n\t}\n\n\tonReady(node: AudioWorkletNode) {\n\t\tconnectSeries(this.input, node, this.output);\n\t\tconst bits = node.parameters.get(\"bits\") as AudioParam;\n\t\tthis.bits.setParam(bits);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis.bits.dispose();\n\t\treturn this;\n\t}\n}\n","import { Effect, EffectOptions } from \"./Effect\";\nimport { Positive } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { WaveShaper } from \"../signal/WaveShaper\";\n\nexport interface ChebyshevOptions extends EffectOptions {\n\torder: Positive;\n\toversample: OverSampleType;\n}\n\n/**\n * Chebyshev is a waveshaper which is good \n * for making different types of distortion sounds.\n * Note that odd orders sound very different from even ones, \n * and order = 1 is no change. \n * Read more at [music.columbia.edu](http://music.columbia.edu/cmc/musicandcomputers/chapter4/04_06.php).\n * @example\n * // create a new cheby\n * const cheby = new Tone.Chebyshev(50).toDestination();\n * // create a monosynth connected to our cheby\n * const synth = new Tone.MonoSynth().connect(cheby);\n * synth.triggerAttackRelease(\"C2\", 0.4);\n * @category Effect\n */\nexport class Chebyshev extends Effect<ChebyshevOptions> {\n\n\treadonly name: string = \"Chebyshev\";\n\n\t/**\n\t * The private waveshaper node\n\t */\n\tprivate _shaper: WaveShaper;\n\n\t/**\n\t * holds onto the order of the filter\n\t */\n\tprivate _order: number;\n\n\t/**\n\t * @param order The order of the chebyshev polynomial. Normal range between 1-100. \n\t */\n\tconstructor(order?: Positive);\n\tconstructor(options?: Partial<ChebyshevOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Chebyshev.getDefaults(), arguments, [\"order\"]));\n\t\tconst options = optionsFromArguments(Chebyshev.getDefaults(), arguments, [\"order\"]);\n\n\t\tthis._shaper = new WaveShaper({\n\t\t\tcontext: this.context,\n\t\t\tlength: 4096\n\t\t});\n\t\tthis._order = options.order;\n\n\t\tthis.connectEffect(this._shaper);\n\t\tthis.order = options.order;\n\t\tthis.oversample = options.oversample;\n\t}\n\n\tstatic getDefaults(): ChebyshevOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\torder: 1,\n\t\t\toversample: \"none\" as \"none\"\n\t\t});\n\t}\n\n\t/**\n\t * get the coefficient for that degree\n\t * @param  x the x value\n\t * @param  degree \n\t * @param  memo memoize the computed value. this speeds up computation greatly. \n\t */\n\tprivate _getCoefficient(x: number, degree: number, memo: Map<number, number>): number {\n\t\tif (memo.has(degree)) {\n\t\t\treturn memo.get(degree) as number;\n\t\t} else if (degree === 0) {\n\t\t\tmemo.set(degree, 0);\n\t\t} else if (degree === 1) {\n\t\t\tmemo.set(degree, x);\n\t\t} else {\n\t\t\tmemo.set(degree, 2 * x * this._getCoefficient(x, degree - 1, memo) - this._getCoefficient(x, degree - 2, memo));\n\t\t}\n\t\treturn memo.get(degree) as number;\n\t}\n\n\t/**\n\t * The order of the Chebyshev polynomial which creates the equation which is applied to the incoming \n\t * signal through a Tone.WaveShaper. The equations are in the form:\n\t * ```\n\t * order 2: 2x^2 + 1\n\t * order 3: 4x^3 + 3x \n\t * ```\n\t * @min 1\n\t * @max 100\n\t */\n\tget order(): Positive {\n\t\treturn this._order;\n\t}\n\tset order(order) {\n\t\tthis._order = order;\n\t\tthis._shaper.setMap((x => {\n\t\t\treturn this._getCoefficient(x, order, new Map());\n\t\t}));\n\t}\n\n\t/**\n\t * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\tset oversample(oversampling) {\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\ninterface SplitOptions extends ToneAudioNodeOptions {\n\tchannels: number;\n}\n\n/**\n * Split splits an incoming signal into the number of given channels.\n *\n * @example\n * const split = new Tone.Split();\n * // stereoSignal.connect(split);\n * @category Component\n */\nexport class Split extends ToneAudioNode<SplitOptions> {\n\treadonly name: string = \"Split\";\n\n\t/**\n\t * The splitting node\n\t */\n\tprivate _splitter: ChannelSplitterNode;\n\n\treadonly input: ChannelSplitterNode;\n\treadonly output: ChannelSplitterNode;\n\n\t/**\n\t * @param channels The number of channels to merge.\n\t */\n\tconstructor(channels?: number);\n\tconstructor(options?: Partial<SplitOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Split.getDefaults(), arguments, [\"channels\"]));\n\t\tconst options = optionsFromArguments(Split.getDefaults(), arguments, [\"channels\"]);\n\n\t\tthis._splitter = this.input = this.output = this.context.createChannelSplitter(options.channels);\n\t\tthis._internalChannels = [this._splitter];\n\t}\n\n\tstatic getDefaults(): SplitOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tchannels: 2,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._splitter.disconnect();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Positive } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\ninterface MergeOptions extends ToneAudioNodeOptions {\n\tchannels: Positive;\n}\n\n/**\n * Merge brings multiple mono input channels into a single multichannel output channel.\n *\n * @example\n * const merge = new Tone.Merge().toDestination();\n * // routing a sine tone in the left channel\n * const osc = new Tone.Oscillator().connect(merge, 0, 0).start();\n * // and noise in the right channel\n * const noise = new Tone.Noise().connect(merge, 0, 1).start();;\n * @category Component\n */\nexport class Merge extends ToneAudioNode<MergeOptions> {\n\n\treadonly name: string = \"Merge\";\n\n\t/**\n\t * The merger node for the channels.\n\t */\n\tprivate _merger: ChannelMergerNode;\n\n\t/**\n\t * The output is the input channels combined into a single (multichannel) output\n\t */\n\treadonly output: ChannelMergerNode;\n\n\t/**\n\t * Multiple input connections combine into a single output.\n\t */\n\treadonly input: ChannelMergerNode;\n\n\t/**\n\t * @param channels The number of channels to merge.\n\t */\n\tconstructor(channels?: Positive);\n\tconstructor(options?: Partial<MergeOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Merge.getDefaults(), arguments, [\"channels\"]));\n\t\tconst options = optionsFromArguments(Merge.getDefaults(), arguments, [\"channels\"]);\n\n\t\tthis._merger = this.output = this.input = this.context.createChannelMerger(options.channels);\n\t}\n\n\tstatic getDefaults(): MergeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tchannels: 2,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._merger.disconnect();\n\t\treturn this;\n\t}\n}\n","import { EffectOptions } from \"./Effect\";\nimport { connect, connectSeries, OutputNode, ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { CrossFade } from \"../component/channel/CrossFade\";\nimport { Signal } from \"../signal/Signal\";\nimport { Split } from \"../component/channel/Split\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Merge } from \"../component/channel/Merge\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport type StereoEffectOptions = EffectOptions;\n\n/**\n * Base class for Stereo effects.\n */\nexport class StereoEffect<Options extends StereoEffectOptions> extends ToneAudioNode<Options> {\n\n\treadonly name: string = \"StereoEffect\";\n\n\treadonly input: Gain;\n\treadonly output: CrossFade;\n\n\t/**\n\t * the drywet knob to control the amount of effect\n\t */\n\tprivate _dryWet: CrossFade;\n\t\n\t/**\n\t * The wet control, i.e. how much of the effected\n\t * will pass through to the output.\n\t */\n\treadonly wet: Signal<\"normalRange\">;\n\t\n\t/**\n\t * Split it\n\t */\n\tprotected _split: Split;\n\t\n\t/**\n\t * the stereo effect merger\n\t */\n\tprotected _merge: Merge;\n\n\tconstructor(options: StereoEffectOptions) {\n\n\t\tsuper(options);\n\n\t\tthis.input = new Gain({ context: this.context });\n\t\t// force mono sources to be stereo\n\t\tthis.input.channelCount = 2;\n\t\tthis.input.channelCountMode = \"explicit\";\n\n\t\tthis._dryWet = this.output = new CrossFade({\n\t\t\tcontext: this.context,\n\t\t\tfade: options.wet\n\t\t});\n\t\tthis.wet = this._dryWet.fade;\n\t\tthis._split = new Split({ context: this.context, channels: 2 });\n\t\tthis._merge = new Merge({ context: this.context, channels: 2 });\n\n\t\t// connections\n\t\tthis.input.connect(this._split);\n\t\t// dry wet connections\n\t\tthis.input.connect(this._dryWet.a);\n\t\tthis._merge.connect(this._dryWet.b);\n\t\treadOnly(this, [\"wet\"]);\n\t}\n\t\n\t/**\n\t * Connect the left part of the effect\n\t */\n\tprotected connectEffectLeft(...nodes: OutputNode[]): void{\n\t\tthis._split.connect(nodes[0], 0, 0);\n\t\tconnectSeries(...nodes);\n\t\tconnect(nodes[nodes.length-1], this._merge, 0, 0);\n\t}\n\t\n\t/**\n\t * Connect the right part of the effect\n\t */\n\tprotected connectEffectRight(...nodes: OutputNode[]): void{\n\t\tthis._split.connect(nodes[0], 1, 0);\n\t\tconnectSeries(...nodes);\n\t\tconnect(nodes[nodes.length-1], this._merge, 0, 1);\n\t}\n\n\tstatic getDefaults(): StereoEffectOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\twet: 1,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dryWet.dispose();\n\t\tthis._split.dispose();\n\t\tthis._merge.dispose();\n\t\treturn this;\n\t}\n}\n","import { StereoEffect, StereoEffectOptions } from \"./StereoEffect\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { Signal } from \"../signal/Signal\";\nimport { Gain } from \"../core/context/Gain\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Split } from \"../component/channel/Split\";\nimport { Merge } from \"../component/channel/Merge\";\n\nexport interface StereoFeedbackEffectOptions extends StereoEffectOptions {\n\tfeedback: NormalRange;\n}\n\n/**\n * Just like a stereo feedback effect, but the feedback is routed from left to right\n * and right to left instead of on the same channel.\n * ```\n * +--------------------------------+ feedbackL <-----------------------------------+\n * |                                                                                |\n * +-->                          +----->        +---->                          +---+\n *      feedbackMerge +--> split        (EFFECT)       merge +--> feedbackSplit\n * +-->                          +----->        +---->                          +---+\n * |                                                                                |\n * +--------------------------------+ feedbackR <-----------------------------------+\n * ```\n */\nexport class StereoFeedbackEffect<Options extends StereoFeedbackEffectOptions> extends StereoEffect<Options> {\n\t\n\t/**\n\t * The amount of feedback from the output\n\t * back into the input of the effect (routed\n\t * across left and right channels).\n\t */\n\treadonly feedback: Signal<\"normalRange\">;\n\n\t/**\n\t * the left side feedback\n\t */\n\tprotected _feedbackL: Gain;\n\n\t/**\n\t * the right side feedback\n\t */\n\tprotected _feedbackR: Gain;\n\n\t/**\n\t * Split the channels for feedback\n\t */\n\tprotected _feedbackSplit: Split;\n\n\t/**\n\t * Merge the channels for feedback\n\t */\n\tprotected _feedbackMerge: Merge;\n\n\tconstructor(options: StereoFeedbackEffectOptions) {\n\n\t\tsuper(options);\n\n\t\tthis.feedback = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.feedback, \n\t\t\tunits: \"normalRange\"\n\t\t});\n\t\tthis._feedbackL = new Gain({ context: this.context });\n\t\tthis._feedbackR = new Gain({ context: this.context });\n\n\t\tthis._feedbackSplit = new Split({ context: this.context, channels: 2 });\n\t\tthis._feedbackMerge = new Merge({ context: this.context, channels: 2 });\n\n\t\tthis._merge.connect(this._feedbackSplit);\n\t\tthis._feedbackMerge.connect(this._split);\n\t\t\n\t\t// the left output connected to the left input\n\t\tthis._feedbackSplit.connect(this._feedbackL, 0, 0);\n\t\tthis._feedbackL.connect(this._feedbackMerge, 0, 0);\n\n\t\t// the right output connected to the right input\n\t\tthis._feedbackSplit.connect(this._feedbackR, 1, 0);\n\t\tthis._feedbackR.connect(this._feedbackMerge, 0, 1);\n\t\t\n\t\t// the feedback control\n\t\tthis.feedback.fan(this._feedbackL.gain, this._feedbackR.gain);\n\t\treadOnly(this, [\"feedback\"]);\n\t}\n\n\tstatic getDefaults(): StereoFeedbackEffectOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\tfeedback: 0.5,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.feedback.dispose();\n\t\tthis._feedbackL.dispose();\n\t\tthis._feedbackR.dispose();\n\t\tthis._feedbackSplit.dispose();\n\t\tthis._feedbackMerge.dispose();\n\t\treturn this;\n\t}\n}\n","import { StereoFeedbackEffect, StereoFeedbackEffectOptions } from \"../effect/StereoFeedbackEffect\";\nimport { Degrees, Frequency, Milliseconds, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { ToneOscillatorType } from \"../source/oscillator/OscillatorInterface\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Delay } from \"../core/context/Delay\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface ChorusOptions extends StereoFeedbackEffectOptions {\n\tfrequency: Frequency;\n\tdelayTime: Milliseconds;\n\tdepth: NormalRange;\n\ttype: ToneOscillatorType;\n\tspread: Degrees;\n}\n\n/**\n * Chorus is a stereo chorus effect composed of a left and right delay with an [[LFO]] applied to the delayTime of each channel.\n * When [[feedback]] is set to a value larger than 0, you also get Flanger-type effects. \n * Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna/blob/master/tuna.js).\n * Read more on the chorus effect on [SoundOnSound](http://www.soundonsound.com/sos/jun04/articles/synthsecrets.htm).\n *\n * @example\n * const chorus = new Tone.Chorus(4, 2.5, 0.5);\n * const synth = new Tone.PolySynth().connect(chorus);\n * synth.triggerAttackRelease([\"C3\", \"E3\", \"G3\"], \"8n\");\n * \n * @category Effect\n */\nexport class Chorus extends StereoFeedbackEffect<ChorusOptions> {\n\n\treadonly name: string = \"Chorus\";\n\n\t/**\n\t * the depth of the chorus\n\t */\n\tprivate _depth: NormalRange;\n\n\t/**\n\t * the delayTime in seconds.\n\t */\n\tprivate _delayTime: Seconds;\n\n\t/**\n\t * the lfo which controls the delayTime\n\t */\n\tprivate _lfoL: LFO\n\n\t/**\n\t * another LFO for the right side with a 180 degree phase diff\n\t */\n\tprivate _lfoR: LFO\n\n\t/**\n\t * delay for left\n\t */\n\tprivate _delayNodeL: Delay;\n\n\t/**\n\t * delay for right\n\t */\n\tprivate _delayNodeR: Delay;\n\n\t/**\n\t * The frequency of the LFO which modulates the delayTime.\n\t */\n\treadonly frequency: Signal<\"frequency\">\n\n\t/**\n\t * @param frequency The frequency of the LFO.\n\t * @param delayTime The delay of the chorus effect in ms.\n\t * @param depth The depth of the chorus.\n\t */\n\tconstructor(frequency?: Frequency, delayTime?: Milliseconds, depth?: NormalRange);\n\tconstructor(options?: Partial<ChorusOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Chorus.getDefaults(), arguments, [\"frequency\", \"delayTime\", \"depth\"]));\n\t\tconst options = optionsFromArguments(Chorus.getDefaults(), arguments, [\"frequency\", \"delayTime\", \"depth\"]);\n\n\t\tthis._depth = options.depth;\n\t\tthis._delayTime = options.delayTime / 1000;\n\t\tthis._lfoL = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t});\n\t\tthis._lfoR = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t\tphase: 180\n\t\t});\n\t\tthis._delayNodeL = new Delay({ context: this.context });\n\t\tthis._delayNodeR = new Delay({ context: this.context });\n\t\tthis.frequency = this._lfoL.frequency;\n\t\treadOnly(this, [\"frequency\"]);\n\t\t// have one LFO frequency control the other\n\t\tthis._lfoL.frequency.connect(this._lfoR.frequency);\n\n\t\t// connections\n\t\tthis.connectEffectLeft(this._delayNodeL);\n\t\tthis.connectEffectRight(this._delayNodeR);\n\t\t// lfo setup\n\t\tthis._lfoL.connect(this._delayNodeL.delayTime);\n\t\tthis._lfoR.connect(this._delayNodeR.delayTime);\n\t\t// set the initial values\n\t\tthis.depth = this._depth;\n\t\tthis.type = options.type;\n\t\tthis.spread = options.spread;\n\t}\n\n\tstatic getDefaults(): ChorusOptions {\n\t\treturn Object.assign(StereoFeedbackEffect.getDefaults(), {\n\t\t\tfrequency: 1.5,\n\t\t\tdelayTime: 3.5,\n\t\t\tdepth: 0.7,\n\t\t\ttype: \"sine\" as \"sine\",\n\t\t\tspread: 180,\n\t\t\tfeedback: 0,\n\t\t\twet: 0.5,\n\t\t});\n\t}\n\n\t/**\n\t * The depth of the effect. A depth of 1 makes the delayTime\n\t * modulate between 0 and 2*delayTime (centered around the delayTime).\n\t */\n\tget depth(): NormalRange {\n\t\treturn this._depth;\n\t}\n\tset depth(depth) {\n\t\tthis._depth = depth;\n\t\tconst deviation = this._delayTime * depth;\n\t\tthis._lfoL.min = Math.max(this._delayTime - deviation, 0);\n\t\tthis._lfoL.max = this._delayTime + deviation;\n\t\tthis._lfoR.min = Math.max(this._delayTime - deviation, 0);\n\t\tthis._lfoR.max = this._delayTime + deviation;\n\t}\n\n\t/**\n\t * The delayTime in milliseconds of the chorus. A larger delayTime\n\t * will give a more pronounced effect. Nominal range a delayTime\n\t * is between 2 and 20ms.\n\t */\n\tget delayTime(): Milliseconds {\n\t\treturn this._delayTime * 1000;\n\t}\n\tset delayTime(delayTime) {\n\t\tthis._delayTime = delayTime / 1000;\n\t\tthis.depth = this._depth;\n\t}\n\n\t/**\n\t * The oscillator type of the LFO.\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._lfoL.type;\n\t}\n\tset type(type) {\n\t\tthis._lfoL.type = type;\n\t\tthis._lfoR.type = type;\n\t}\n\n\t/**\n\t * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.\n\t * When set to 180, LFO's will be panned hard left and right respectively.\n\t */\n\tget spread(): Degrees {\n\t\treturn this._lfoR.phase - this._lfoL.phase;\n\t}\n\tset spread(spread) {\n\t\tthis._lfoL.phase = 90 - (spread / 2);\n\t\tthis._lfoR.phase = (spread / 2) + 90;\n\t}\n\n\t/**\n\t * Start the effect.\n\t */\n\tstart(time?: Time): this {\n\t\tthis._lfoL.start(time);\n\t\tthis._lfoR.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the lfo\n\t */\n\tstop(time?: Time): this {\n\t\tthis._lfoL.stop(time);\n\t\tthis._lfoR.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the filter to the transport. See [[LFO.sync]]\n\t */\n\tsync(): this {\n\t\tthis._lfoL.sync();\n\t\tthis._lfoR.sync();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the filter from the transport.\n\t */\n\tunsync(): this {\n\t\tthis._lfoL.unsync();\n\t\tthis._lfoR.unsync();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._lfoL.dispose();\n\t\tthis._lfoR.dispose();\n\t\tthis._delayNodeL.dispose();\n\t\tthis._delayNodeR.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n","import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { WaveShaper } from \"../signal/WaveShaper\";\nimport { Effect, EffectOptions } from \"./Effect\";\n\nexport interface DistortionOptions extends EffectOptions {\n\tdistortion: number;\n\toversample: OverSampleType;\n}\n\n/**\n * A simple distortion effect using Tone.WaveShaper.\n * Algorithm from [this stackoverflow answer](http://stackoverflow.com/a/22313408).\n *\n * @example\n * const dist = new Tone.Distortion(0.8).toDestination();\n * const fm = new Tone.FMSynth().connect(dist);\n * fm.triggerAttackRelease(\"A1\", \"8n\");\n * @category Effect\n */\nexport class Distortion extends Effect<DistortionOptions> {\n\n\treadonly name: string = \"Distortion\";\n\n\t/**\n\t * The waveshaper which does the distortion\n\t */\n\tprivate _shaper: WaveShaper;\n\n\t/**\n\t * Stores the distortion value\n\t */\n\tprivate _distortion: number;\n\n\t/**\n\t * @param distortion The amount of distortion (nominal range of 0-1)\n\t */\n\tconstructor(distortion?: number);\n\tconstructor(options?: Partial<DistortionOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Distortion.getDefaults(), arguments, [\"distortion\"]));\n\t\tconst options = optionsFromArguments(Distortion.getDefaults(), arguments, [\"distortion\"]);\n\n\t\tthis._shaper = new WaveShaper({\n\t\t\tcontext: this.context,\n\t\t\tlength: 4096,\n\t\t});\n\n\t\tthis._distortion = options.distortion;\n\n\t\tthis.connectEffect(this._shaper);\n\t\tthis.distortion = options.distortion;\n\t\tthis.oversample = options.oversample;\n\t}\n\n\tstatic getDefaults(): DistortionOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tdistortion: 0.4,\n\t\t\toversample: \"none\" as OverSampleType,\n\t\t});\n\t}\n\n\t/**\n\t * The amount of distortion. Nominal range is between 0 and 1.\n\t */\n\tget distortion(): number {\n\t\treturn this._distortion;\n\t}\n\tset distortion(amount) {\n\t\tthis._distortion = amount;\n\t\tconst k = amount * 100;\n\t\tconst deg = Math.PI / 180;\n\t\tthis._shaper.setMap((x) => {\n\t\t\tif (Math.abs(x) < 0.001) {\n\t\t\t\t// should output 0 when input is 0\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\tset oversample(oversampling) {\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Effect, EffectOptions } from \"./Effect\";\n\nexport interface FeedbackEffectOptions extends EffectOptions {\n\t/**\n\t * The feedback from the output back to the input\n\t * ```\n\t * +---<--------<---+\n\t * |                |\n\t * |  +----------+  |\n\t * +--> feedback +>-+\n\t *    +----------+\n\t * ```\n\t */\n\tfeedback: NormalRange;\n}\n\n/**\n * FeedbackEffect provides a loop between an audio source and its own output.\n * This is a base-class for feedback effects.\n */\nexport abstract class FeedbackEffect<Options extends FeedbackEffectOptions> extends Effect<Options> {\n\n\treadonly name: string = \"FeedbackEffect\";\n\n\t/**\n\t * the gain which controls the feedback\n\t */\n\tprivate _feedbackGain: Gain<\"normalRange\">;\n\n\t/**\n\t * The amount of signal which is fed back into the effect input.\n\t */\n\tfeedback: Param<\"normalRange\">;\n\n\tconstructor(options: FeedbackEffectOptions) {\n\n\t\tsuper(options);\n\n\t\tthis._feedbackGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.feedback,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\n\t\tthis.feedback = this._feedbackGain.gain;\n\t\treadOnly(this, \"feedback\");\n\n\t\t// the feedback loop\n\t\tthis.effectReturn.chain(this._feedbackGain, this.effectSend);\n\t}\n\n\tstatic getDefaults(): FeedbackEffectOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tfeedback: 0.125,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._feedbackGain.dispose();\n\t\tthis.feedback.dispose();\n\t\treturn this;\n\t}\n}\n","import { Delay } from \"../core/context/Delay\";\nimport { Param } from \"../core/context/Param\";\nimport { NormalRange, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { FeedbackEffect, FeedbackEffectOptions } from \"./FeedbackEffect\";\n\ninterface FeedbackDelayOptions extends FeedbackEffectOptions {\n\tdelayTime: Time;\n\tmaxDelay: Time;\n}\n\n/**\n * FeedbackDelay is a DelayNode in which part of output signal is fed back into the delay.\n *\n * @param delayTime The delay applied to the incoming signal.\n * @param feedback The amount of the effected signal which is fed back through the delay.\n * @example\n * const feedbackDelay = new Tone.FeedbackDelay(\"8n\", 0.5).toDestination();\n * const tom = new Tone.MembraneSynth({\n * \toctaves: 4,\n * \tpitchDecay: 0.1\n * }).connect(feedbackDelay);\n * tom.triggerAttackRelease(\"A2\", \"32n\");\n * @category Effect\n */\nexport class FeedbackDelay extends FeedbackEffect<FeedbackDelayOptions> {\n\n\treadonly name: string = \"FeedbackDelay\";\n\n\t/**\n\t * the delay node\n\t */\n\tprivate _delayNode: Delay;\n\n\t/**\n\t * The delayTime of the FeedbackDelay.\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\tconstructor(delayTime?: Time, feedback?: NormalRange);\n\tconstructor(options?: Partial<FeedbackDelayOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FeedbackDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]));\n\t\tconst options = optionsFromArguments(FeedbackDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]);\n\n\t\tthis._delayNode = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tdelayTime: options.delayTime,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis.delayTime = this._delayNode.delayTime;\n\n\t\t// connect it up\n\t\tthis.connectEffect(this._delayNode);\n\t\treadOnly(this, \"delayTime\");\n\t}\n\n\tstatic getDefaults(): FeedbackDelayOptions {\n\t\treturn Object.assign(FeedbackEffect.getDefaults(), {\n\t\t\tdelayTime: 0.25,\n\t\t\tmaxDelay: 1,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.dispose();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { connectSeries, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\n\n/**\n * PhaseShiftAllpass is an very efficient implementation of a Hilbert Transform\n * using two Allpass filter banks whose outputs have a phase difference of 90°.\n * Here the `offset90` phase is offset by +90° in relation to `output`.\n * Coefficients and structure was developed by Olli Niemitalo.\n * For more details see: http://yehar.com/blog/?p=368\n * @category Component\n */\nexport class PhaseShiftAllpass extends ToneAudioNode<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"PhaseShiftAllpass\";\n\n\treadonly input = new Gain({ context: this.context });\n\n\t/**\n\t * The Allpass filter in the first bank\n\t */\n\tprivate _bank0: IIRFilterNode[];\n\n\t/**\n\t * The Allpass filter in the seconds bank\n\t */\n\tprivate _bank1: IIRFilterNode[];\n\n\t/**\n\t * A IIR filter implementing a delay by one sample used by the first bank\n\t */\n\tprivate _oneSampleDelay: IIRFilterNode;\n\n\t/**\n\t * The phase shifted output\n\t */\n\treadonly output = new Gain({ context: this.context });\n\n\t/**\n\t * The PhaseShifted allpass output\n\t */\n\treadonly offset90 = new Gain({ context: this.context });\n\n\tconstructor(options?: Partial<ToneAudioNodeOptions>) {\n\n\t\tsuper(options);\n\n\t\tconst allpassBank1Values = [0.6923878, 0.9360654322959, 0.9882295226860, 0.9987488452737];\n\t\tconst allpassBank2Values = [0.4021921162426, 0.8561710882420, 0.9722909545651, 0.9952884791278];\n\n\t\tthis._bank0 = this._createAllPassFilterBank(allpassBank1Values);\n\t\tthis._bank1 = this._createAllPassFilterBank(allpassBank2Values);\n\t\tthis._oneSampleDelay = this.context.createIIRFilter([0.0, 1.0], [1.0, 0.0]);\n\n\t\t// connect Allpass filter banks\n\t\tconnectSeries(this.input, ...this._bank0, this._oneSampleDelay, this.output);\n\t\tconnectSeries(this.input, ...this._bank1, this.offset90);\n\t}\n\n\t/**\n\t * Create all of the IIR filters from an array of values using the coefficient calculation.\n\t */\n\tprivate _createAllPassFilterBank(bankValues: number[]): IIRFilterNode[] {\n\t\tconst nodes: IIRFilterNode[] = bankValues.map(value => {\n\t\t\tconst coefficients = [[value * value, 0, -1], [1, 0, -(value * value)]];\n\t\t\treturn this.context.createIIRFilter(coefficients[0], coefficients[1]);\n\t\t});\n\n\t\treturn nodes;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis.offset90.dispose();\n\t\tthis._bank0.forEach(f => f.disconnect());\n\t\tthis._bank1.forEach(f => f.disconnect());\n\t\tthis._oneSampleDelay.disconnect();\n\t\treturn this;\n\t}\n}\n","import { PhaseShiftAllpass } from \"../component/filter/PhaseShiftAllpass\";\nimport { Frequency } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Effect, EffectOptions } from \"../effect/Effect\";\nimport { Add } from \"../signal/Add\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Negate } from \"../signal/Negate\";\nimport { Signal } from \"../signal/Signal\";\nimport { Oscillator } from \"../source/oscillator/Oscillator\";\nimport { ToneOscillatorNode } from \"../source/oscillator/ToneOscillatorNode\";\n\ninterface FrequencyShifterOptions extends EffectOptions {\n\tfrequency: Frequency;\n}\n\n/**\n * FrequencyShifter can be used to shift all frequencies of a signal by a fixed amount.\n * The amount can be changed at audio rate and the effect is applied in real time.\n * The frequency shifting is implemented with a technique called single side band modulation using a ring modulator.\n * Note: Contrary to pitch shifting, all frequencies are shifted by the same amount,\n * destroying the harmonic relationship between them. This leads to the classic ring modulator timbre distortion.\n * The algorithm will produces some aliasing towards the high end, especially if your source material\n * contains a lot of high frequencies. Unfortunatelly the webaudio API does not support resampling\n * buffers in real time, so it is not possible to fix it properly. Depending on the use case it might\n * be an option to low pass filter your input before frequency shifting it to get ride of the aliasing.\n * You can find a very detailed description of the algorithm here: https://larzeitlin.github.io/RMFS/\n *\n * @example\n * const input = new Tone.Oscillator(230, \"sawtooth\").start();\n * const shift = new Tone.FrequencyShifter(42).toDestination();\n * input.connect(shift);\n * @category Effect\n */\nexport class FrequencyShifter extends Effect<FrequencyShifterOptions> {\n\n\treadonly name: string = \"FrequencyShifter\";\n\n\t/**\n\t * The ring modulators carrier frequency. This frequency determines\n\t * by how many Hertz the input signal will be shifted up or down. Default is 0.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The ring modulators sine carrier\n\t */\n\tprivate _sine: ToneOscillatorNode;\n\n\t/**\n\t * The ring modulators cosine carrier\n\t */\n\tprivate _cosine: Oscillator;\n\n\t/**\n\t * The sine multiply operator\n\t */\n\tprivate _sineMultiply: Multiply;\n\n\t/**\n\t * The cosine multiply operator\n\t */\n\tprivate _cosineMultiply: Multiply;\n\n\t/**\n\t * The negate operator\n\t */\n\tprivate _negate: Negate;\n\n\t/**\n\t * The final add operator\n\t */\n\tprivate _add: Add;\n\n\t/**\n\t * The phase shifter to create the initial 90° phase offset\n\t */\n\tprivate _phaseShifter: PhaseShiftAllpass;\n\n\t/**\n\t * @param frequency The incoming signal is shifted by this frequency value.\n\t */\n\tconstructor(frequency?: Frequency);\n\tconstructor(options?: Partial<FrequencyShifterOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FrequencyShifter.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(FrequencyShifter.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t\tminValue: -this.context.sampleRate / 2,\n\t\t\tmaxValue: this.context.sampleRate / 2,\n\t\t});\n\n\t\tthis._sine = new ToneOscillatorNode({\n\t\t\tcontext: this.context,\n\t\t\ttype: \"sine\",\n\t\t});\n\n\t\tthis._cosine = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tphase: -90,\n\t\t\ttype: \"sine\",\n\t\t});\n\n\t\tthis._sineMultiply = new Multiply({ context: this.context });\n\t\tthis._cosineMultiply = new Multiply({ context: this.context });\n\t\tthis._negate = new Negate({ context: this.context });\n\t\tthis._add = new Add({ context: this.context });\n\n\t\tthis._phaseShifter = new PhaseShiftAllpass({ context: this.context });\n\t\tthis.effectSend.connect(this._phaseShifter);\n\n\t\t// connect the carrier frequency signal to the two oscillators\n\t\tthis.frequency.fan(this._sine.frequency, this._cosine.frequency);\n\n\t\tthis._phaseShifter.offset90.connect(this._cosineMultiply);\n\t\tthis._cosine.connect(this._cosineMultiply.factor);\n\n\t\tthis._phaseShifter.connect(this._sineMultiply);\n\t\tthis._sine.connect(this._sineMultiply.factor);\n\t\tthis._sineMultiply.connect(this._negate);\n\n\t\tthis._cosineMultiply.connect(this._add);\n\t\tthis._negate.connect(this._add.addend);\n\n\t\tthis._add.connect(this.effectReturn);\n\n\t\t// start the oscillators at the same time\n\t\tconst now = this.immediate();\n\t\tthis._sine.start(now);\n\t\tthis._cosine.start(now);\n\t}\n\n\tstatic getDefaults(): FrequencyShifterOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tfrequency: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis._add.dispose();\n\t\tthis._cosine.dispose();\n\t\tthis._cosineMultiply.dispose();\n\t\tthis._negate.dispose();\n\t\tthis._phaseShifter.dispose();\n\t\tthis._sine.dispose();\n\t\tthis._sineMultiply.dispose();\n\t\treturn this;\n\t}\n}\n","import { StereoEffect, StereoEffectOptions } from \"./StereoEffect\";\nimport { Frequency, NormalRange } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Signal } from \"../signal/Signal\";\nimport { LowpassCombFilter } from \"../component/filter/LowpassCombFilter\";\n\nexport interface FreeverbOptions extends StereoEffectOptions {\n\tdampening: Frequency;\n\troomSize: NormalRange;\n}\n\n/**\n * An array of comb filter delay values from Freeverb implementation\n */\nconst combFilterTunings = [1557 / 44100, 1617 / 44100, 1491 / 44100, 1422 / 44100, 1277 / 44100, 1356 / 44100, 1188 / 44100, 1116 / 44100];\n\n/**\n * An array of allpass filter frequency values from Freeverb implementation\n */\nconst allpassFilterFrequencies = [225, 556, 441, 341];\n\n/**\n * Freeverb is a reverb based on [Freeverb](https://ccrma.stanford.edu/~jos/pasp/Freeverb.html).\n * Read more on reverb on [Sound On Sound](https://web.archive.org/web/20160404083902/http://www.soundonsound.com:80/sos/feb01/articles/synthsecrets.asp).\n * Freeverb is now implemented with an AudioWorkletNode which may result on performance degradation on some platforms. Consider using [[Reverb]].\n * @example\n * const freeverb = new Tone.Freeverb().toDestination();\n * freeverb.dampening = 1000;\n * // routing synth through the reverb\n * const synth = new Tone.NoiseSynth().connect(freeverb);\n * synth.triggerAttackRelease(0.05);\n * @category Effect\n */\nexport class Freeverb extends StereoEffect<FreeverbOptions> {\n\n\treadonly name: string = \"Freeverb\";\n\n\t/**\n\t * The roomSize value between 0 and 1. A larger roomSize will result in a longer decay.\n\t */\n\treadonly roomSize: Signal<\"normalRange\">;\n\n\t/**\n\t * the comb filters\n\t */\n\tprivate _combFilters: LowpassCombFilter[] = [];\n\n\t/**\n\t * the allpass filters on the left\n\t */\n\tprivate _allpassFiltersL: BiquadFilterNode[] = [];\n\n\t/**\n\t * the allpass filters on the right\n\t */\n\tprivate _allpassFiltersR: BiquadFilterNode[] = [];\n\n\t/**\n\t * @param roomSize Correlated to the decay time.\n\t * @param dampening The cutoff frequency of a lowpass filter as part of the reverb.\n\t */\n\tconstructor(roomSize?: NormalRange, dampening?: Frequency);\n\tconstructor(options?: Partial<FreeverbOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Freeverb.getDefaults(), arguments, [\"roomSize\", \"dampening\"]));\n\t\tconst options = optionsFromArguments(Freeverb.getDefaults(), arguments, [\"roomSize\", \"dampening\"]);\n\n\t\tthis.roomSize = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.roomSize,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\n\t\t// make the allpass filters on the right\n\t\tthis._allpassFiltersL = allpassFilterFrequencies.map(freq => {\n\t\t\tconst allpassL = this.context.createBiquadFilter();\n\t\t\tallpassL.type = \"allpass\";\n\t\t\tallpassL.frequency.value = freq;\n\t\t\treturn allpassL;\n\t\t});\n\n\t\t// make the allpass filters on the left\n\t\tthis._allpassFiltersR = allpassFilterFrequencies.map(freq => {\n\t\t\tconst allpassR = this.context.createBiquadFilter();\n\t\t\tallpassR.type = \"allpass\";\n\t\t\tallpassR.frequency.value = freq;\n\t\t\treturn allpassR;\n\t\t});\n\n\t\t// make the comb filters\n\t\tthis._combFilters = combFilterTunings.map((delayTime, index) => {\n\t\t\tconst lfpf = new LowpassCombFilter({\n\t\t\t\tcontext: this.context,\n\t\t\t\tdampening: options.dampening,\n\t\t\t\tdelayTime,\n\t\t\t});\n\t\t\tif (index < combFilterTunings.length / 2) {\n\t\t\t\tthis.connectEffectLeft(lfpf, ...this._allpassFiltersL);\n\t\t\t} else {\n\t\t\t\tthis.connectEffectRight(lfpf, ...this._allpassFiltersR);\n\t\t\t}\n\t\t\tthis.roomSize.connect(lfpf.resonance);\n\t\t\treturn lfpf;\n\t\t});\n\n\t\treadOnly(this, [\"roomSize\"]);\n\t}\n\n\tstatic getDefaults(): FreeverbOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\troomSize: 0.7,\n\t\t\tdampening: 3000\n\t\t});\n\t}\n\n\t/**\n\t * The amount of dampening of the reverberant signal.\n\t */\n\n\tget dampening(): Frequency {\n\t\treturn this._combFilters[0].dampening;\n\t}\n\tset dampening(d) {\n\t\tthis._combFilters.forEach(c => c.dampening = d);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._allpassFiltersL.forEach(al => al.disconnect());\n\t\tthis._allpassFiltersR.forEach(ar => ar.disconnect());\n\t\tthis._combFilters.forEach(cf => cf.dispose());\n\t\tthis.roomSize.dispose();\n\t\treturn this;\n\t}\n}\n","import { NormalRange } from \"../core/type/Units\";\nimport { StereoEffect, StereoEffectOptions } from \"./StereoEffect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Scale } from \"../signal/Scale\";\nimport { Signal } from \"../signal/Signal\";\nimport { FeedbackCombFilter } from \"../component/filter/FeedbackCombFilter\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface JCReverbOptions extends StereoEffectOptions {\n\troomSize: NormalRange;\n}\n\n/**\n * an array of the comb filter delay time values\n */\nconst combFilterDelayTimes = [1687 / 25000, 1601 / 25000, 2053 / 25000, 2251 / 25000];\n\n/**\n * the resonances of each of the comb filters\n */\nconst combFilterResonances = [0.773, 0.802, 0.753, 0.733];\n\n/**\n * the allpass filter frequencies\n */\nconst allpassFilterFreqs = [347, 113, 37];\n\n/**\n * JCReverb is a simple [Schroeder Reverberator](https://ccrma.stanford.edu/~jos/pasp/Schroeder_Reverberators.html)\n * tuned by John Chowning in 1970.\n * It is made up of three allpass filters and four [[FeedbackCombFilter]].\n * JCReverb is now implemented with an AudioWorkletNode which may result on performance degradation on some platforms. Consider using [[Reverb]].\n * @example\n * const reverb = new Tone.JCReverb(0.4).toDestination();\n * const delay = new Tone.FeedbackDelay(0.5);\n * // connecting the synth to reverb through delay\n * const synth = new Tone.DuoSynth().chain(delay, reverb);\n * synth.triggerAttackRelease(\"A4\", \"8n\");\n * \n * @category Effect\n */\nexport class JCReverb extends StereoEffect<JCReverbOptions> {\n\n\treadonly name: string = \"JCReverb\";\n\n\t/**\n\t * Room size control values. \n\t */\n\treadonly roomSize: Signal<\"normalRange\">\n\n\t/**\n\t * Scale the room size\n\t */\n\tprivate _scaleRoomSize: Scale;\n\n\t/**\n\t * a series of allpass filters\n\t */\n\tprivate _allpassFilters: BiquadFilterNode[] = [];\n\n\t/**\n\t * parallel feedback comb filters\n\t */\n\tprivate _feedbackCombFilters: FeedbackCombFilter[] = [];\n\n\t/**\n\t * @param roomSize Correlated to the decay time.\n\t */\n\tconstructor(roomSize?: NormalRange);\n\tconstructor(options?: Partial<JCReverbOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(JCReverb.getDefaults(), arguments, [\"roomSize\"]));\n\t\tconst options = optionsFromArguments(JCReverb.getDefaults(), arguments, [\"roomSize\"]);\n\n\t\tthis.roomSize = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.roomSize,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\t\tthis._scaleRoomSize = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmin: -0.733,\n\t\t\tmax: 0.197,\n\t\t});\n\n\t\t// make the allpass filters\n\t\tthis._allpassFilters = allpassFilterFreqs.map(freq => {\n\t\t\tconst allpass = this.context.createBiquadFilter();\n\t\t\tallpass.type = \"allpass\";\n\t\t\tallpass.frequency.value = freq;\n\t\t\treturn allpass;\n\t\t});\n\n\t\t// and the comb filters\n\t\tthis._feedbackCombFilters = combFilterDelayTimes.map((delayTime, index) => {\n\t\t\tconst fbcf = new FeedbackCombFilter({\n\t\t\t\tcontext: this.context,\n\t\t\t\tdelayTime,\n\t\t\t});\n\t\t\tthis._scaleRoomSize.connect(fbcf.resonance);\n\t\t\tfbcf.resonance.value = combFilterResonances[index];\n\t\t\tif (index < combFilterDelayTimes.length / 2) {\n\t\t\t\tthis.connectEffectLeft(...this._allpassFilters, fbcf);\n\t\t\t} else {\n\t\t\t\tthis.connectEffectRight(...this._allpassFilters, fbcf);\n\t\t\t}\n\t\t\treturn fbcf;\n\t\t});\n\n\t\t// chain the allpass filters together\n\t\tthis.roomSize.connect(this._scaleRoomSize);\n\t\treadOnly(this, [\"roomSize\"]);\n\t}\n\n\tstatic getDefaults(): JCReverbOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\troomSize: 0.5,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._allpassFilters.forEach(apf => apf.disconnect());\n\t\tthis._feedbackCombFilters.forEach(fbcf => fbcf.dispose());\n\t\tthis.roomSize.dispose();\n\t\tthis._scaleRoomSize.dispose();\n\t\treturn this;\n\t}\n}\n","import { StereoFeedbackEffect, StereoFeedbackEffectOptions } from \"./StereoFeedbackEffect\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface StereoXFeedbackEffectOptions extends StereoFeedbackEffectOptions {\n\tfeedback: NormalRange;\n}\n\n/**\n * Just like a [[StereoFeedbackEffect]], but the feedback is routed from left to right\n * and right to left instead of on the same channel.\n * ```\n * +--------------------------------+ feedbackL <-----------------------------------+\n * |                                                                                |\n * +-->                          +----->        +---->                          +-----+\n *      feedbackMerge +--> split        (EFFECT)       merge +--> feedbackSplit     | |\n * +-->                          +----->        +---->                          +---+ |\n * |                                                                                  |\n * +--------------------------------+ feedbackR <-------------------------------------+\n * ```\n */\nexport class StereoXFeedbackEffect<Options extends StereoXFeedbackEffectOptions> extends StereoFeedbackEffect<Options> {\n\t\n\tconstructor(options: StereoXFeedbackEffectOptions) {\n\n\t\tsuper(options);\n\t\t// the left output connected to the right input\n\t\tthis._feedbackL.disconnect();\n\t\tthis._feedbackL.connect(this._feedbackMerge, 0, 1);\n\n\t\t// the left output connected to the right input\n\t\tthis._feedbackR.disconnect();\n\t\tthis._feedbackR.connect(this._feedbackMerge, 0, 0);\n\t\t\n\t\treadOnly(this, [\"feedback\"]);\n\t}\n}\n","import { StereoXFeedbackEffect, StereoXFeedbackEffectOptions } from \"./StereoXFeedbackEffect\";\nimport { NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Delay } from \"../core/context/Delay\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface PingPongDelayOptions extends StereoXFeedbackEffectOptions {\n\tdelayTime: Time;\n\tmaxDelay: Seconds;\n}\n\n/**\n * PingPongDelay is a feedback delay effect where the echo is heard\n * first in one channel and next in the opposite channel. In a stereo\n * system these are the right and left channels.\n * PingPongDelay in more simplified terms is two Tone.FeedbackDelays\n * with independent delay values. Each delay is routed to one channel\n * (left or right), and the channel triggered second will always\n * trigger at the same interval after the first.\n * @example\n * const pingPong = new Tone.PingPongDelay(\"4n\", 0.2).toDestination();\n * const drum = new Tone.MembraneSynth().connect(pingPong);\n * drum.triggerAttackRelease(\"C4\", \"32n\");\n * @category Effect\n */\nexport class PingPongDelay extends StereoXFeedbackEffect<PingPongDelayOptions> {\n\n\treadonly name: string = \"PingPongDelay\";\n\n\t/**\n\t * the delay node on the left side\n\t */\n\tprivate _leftDelay: Delay;\n\n\t/**\n\t * the delay node on the right side\n\t */\n\tprivate _rightDelay: Delay;\n\n\t/**\n\t * the predelay on the right side\n\t */\n\tprivate _rightPreDelay: Delay;\n\n\t/**\n\t * the delay time signal\n\t */\n\treadonly delayTime: Signal<\"time\">;\n\n\t/**\n\t * @param delayTime The delayTime between consecutive echos.\n\t * @param feedback The amount of the effected signal which is fed back through the delay.\n\t */\n\tconstructor(delayTime?: Time, feedback?: NormalRange);\n\tconstructor(options?: Partial<PingPongDelayOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PingPongDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]));\n\t\tconst options = optionsFromArguments(PingPongDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]);\n\n\t\tthis._leftDelay = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis._rightDelay = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tmaxDelay: options.maxDelay\n\t\t});\n\t\tthis._rightPreDelay = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tmaxDelay: options.maxDelay\n\t\t});\n\t\tthis.delayTime = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.delayTime,\n\t\t});\n\n\t\t// connect it up\n\t\tthis.connectEffectLeft(this._leftDelay);\n\t\tthis.connectEffectRight(this._rightPreDelay, this._rightDelay);\n\t\tthis.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime);\n\t\t// rearranged the feedback to be after the rightPreDelay\n\t\tthis._feedbackL.disconnect();\n\t\tthis._feedbackL.connect(this._rightDelay);\n\t\treadOnly(this, [\"delayTime\"]);\n\t}\n\n\tstatic getDefaults(): PingPongDelayOptions {\n\t\treturn Object.assign(StereoXFeedbackEffect.getDefaults(), {\n\t\t\tdelayTime: 0.25,\n\t\t\tmaxDelay: 1\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._leftDelay.dispose();\n\t\tthis._rightDelay.dispose();\n\t\tthis._rightPreDelay.dispose();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n","import { Interval, Seconds, Time } from \"../core/type/Units\";\nimport { FeedbackEffect, FeedbackEffectOptions } from \"./FeedbackEffect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Delay } from \"../core/context/Delay\";\nimport { CrossFade } from \"../component/channel/CrossFade\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Param } from \"../core/context/Param\";\nimport { intervalToFrequencyRatio } from \"../core/type/Conversions\";\n\nexport interface PitchShiftOptions extends FeedbackEffectOptions {\n\tpitch: Interval;\n\twindowSize: Seconds;\n\tdelayTime: Time;\n}\n\n/**\n * PitchShift does near-realtime pitch shifting to the incoming signal.\n * The effect is achieved by speeding up or slowing down the delayTime\n * of a DelayNode using a sawtooth wave.\n * Algorithm found in [this pdf](http://dsp-book.narod.ru/soundproc.pdf).\n * Additional reference by [Miller Pucket](http://msp.ucsd.edu/techniques/v0.11/book-html/node115.html).\n * @category Effect\n */\nexport class PitchShift extends FeedbackEffect<PitchShiftOptions> {\n\n\treadonly name: string = \"PitchShift\";\n\n\t/**\n\t * The pitch signal\n\t */\n\tprivate _frequency: Signal<\"frequency\">;\n\n\t/**\n\t * Uses two DelayNodes to cover up the jump in the sawtooth wave.\n\t */\n\tprivate _delayA: Delay;\n\n\t/**\n\t * The first LFO.\n\t */\n\tprivate _lfoA: LFO;\n\n\t/**\n\t * The second DelayNode\n\t */\n\tprivate _delayB: Delay;\n\n\t/**\n\t * The second LFO.\n\t */\n\tprivate _lfoB: LFO;\n\n\t/**\n\t * Cross fade quickly between the two delay lines to cover up the jump in the sawtooth wave\n\t */\n\tprivate _crossFade: CrossFade;\n\n\t/**\n\t * LFO which alternates between the two delay lines to cover up the disparity in the\n\t * sawtooth wave.\n\t */\n\tprivate _crossFadeLFO: LFO;\n\n\t/**\n\t * The delay node\n\t */\n\tprivate _feedbackDelay: Delay;\n\n\t/**\n\t * The amount of delay on the input signal\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\t/**\n\t * Hold the current pitch\n\t */\n\tprivate _pitch: Interval;\n\n\t/**\n\t * Hold the current windowSize\n\t */\n\tprivate _windowSize;\n\n\t/**\n\t * @param pitch The interval to transpose the incoming signal by.\n\t */\n\tconstructor(pitch?: Interval);\n\tconstructor(options?: Partial<PitchShiftOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PitchShift.getDefaults(), arguments, [\"pitch\"]));\n\t\tconst options = optionsFromArguments(PitchShift.getDefaults(), arguments, [\"pitch\"]);\n\n\t\tthis._frequency = new Signal({ context: this.context });\n\t\tthis._delayA = new Delay({\n\t\t\tmaxDelay: 1,\n\t\t\tcontext: this.context\n\t\t});\n\t\tthis._lfoA = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tmin: 0,\n\t\t\tmax: 0.1,\n\t\t\ttype: \"sawtooth\"\n\t\t}).connect(this._delayA.delayTime);\n\t\tthis._delayB = new Delay({\n\t\t\tmaxDelay: 1,\n\t\t\tcontext: this.context\n\t\t});\n\t\tthis._lfoB = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tmin: 0,\n\t\t\tmax: 0.1,\n\t\t\ttype: \"sawtooth\",\n\t\t\tphase: 180\n\t\t}).connect(this._delayB.delayTime);\n\t\tthis._crossFade = new CrossFade({ context: this.context });\n\t\tthis._crossFadeLFO = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t\ttype: \"triangle\",\n\t\t\tphase: 90\n\t\t}).connect(this._crossFade.fade);\n\t\tthis._feedbackDelay = new Delay({\n\t\t\tdelayTime: options.delayTime,\n\t\t\tcontext: this.context,\n\t\t});\n\t\tthis.delayTime = this._feedbackDelay.delayTime;\n\t\treadOnly(this, \"delayTime\");\n\t\tthis._pitch = options.pitch;\n\n\t\tthis._windowSize = options.windowSize;\n\n\t\t// connect the two delay lines up\n\t\tthis._delayA.connect(this._crossFade.a);\n\t\tthis._delayB.connect(this._crossFade.b);\n\t\t// connect the frequency\n\t\tthis._frequency.fan(this._lfoA.frequency, this._lfoB.frequency, this._crossFadeLFO.frequency);\n\t\t// route the input\n\t\tthis.effectSend.fan(this._delayA, this._delayB);\n\t\tthis._crossFade.chain(this._feedbackDelay, this.effectReturn);\n\t\t// start the LFOs at the same time\n\t\tconst now = this.now();\n\t\tthis._lfoA.start(now);\n\t\tthis._lfoB.start(now);\n\t\tthis._crossFadeLFO.start(now);\n\t\t// set the initial value\n\t\tthis.windowSize = this._windowSize;\n\t}\n\n\tstatic getDefaults(): PitchShiftOptions {\n\t\treturn Object.assign(FeedbackEffect.getDefaults(), {\n\t\t\tpitch: 0,\n\t\t\twindowSize: 0.1,\n\t\t\tdelayTime: 0,\n\t\t\tfeedback: 0\n\t\t});\n\t}\n\n\t/**\n\t * Repitch the incoming signal by some interval (measured in semi-tones).\n\t * @example\n\t * const pitchShift = new Tone.PitchShift().toDestination();\n\t * const osc = new Tone.Oscillator().connect(pitchShift).start().toDestination();\n\t * pitchShift.pitch = -12; // down one octave\n\t * pitchShift.pitch = 7; // up a fifth\n\t */\n\tget pitch() {\n\t\treturn this._pitch;\n\t}\n\tset pitch(interval) {\n\t\tthis._pitch = interval;\n\t\tlet factor = 0;\n\t\tif (interval < 0) {\n\t\t\tthis._lfoA.min = 0;\n\t\t\tthis._lfoA.max = this._windowSize;\n\t\t\tthis._lfoB.min = 0;\n\t\t\tthis._lfoB.max = this._windowSize;\n\t\t\tfactor = intervalToFrequencyRatio(interval - 1) + 1;\n\t\t} else {\n\t\t\tthis._lfoA.min = this._windowSize;\n\t\t\tthis._lfoA.max = 0;\n\t\t\tthis._lfoB.min = this._windowSize;\n\t\t\tthis._lfoB.max = 0;\n\t\t\tfactor = intervalToFrequencyRatio(interval) - 1;\n\t\t}\n\t\tthis._frequency.value = factor * (1.2 / this._windowSize);\n\t}\n\n\t/**\n\t * The window size corresponds roughly to the sample length in a looping sampler.\n\t * Smaller values are desirable for a less noticeable delay time of the pitch shifted\n\t * signal, but larger values will result in smoother pitch shifting for larger intervals.\n\t * A nominal range of 0.03 to 0.1 is recommended.\n\t */\n\tget windowSize() {\n\t\treturn this._windowSize;\n\t}\n\tset windowSize(size) {\n\t\tthis._windowSize = this.toSeconds(size);\n\t\tthis.pitch = this._pitch;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._frequency.dispose();\n\t\tthis._delayA.dispose();\n\t\tthis._delayB.dispose();\n\t\tthis._lfoA.dispose();\n\t\tthis._lfoB.dispose();\n\t\tthis._crossFade.dispose();\n\t\tthis._crossFadeLFO.dispose();\n\t\tthis._feedbackDelay.dispose();\n\t\treturn this;\n\t}\n}\n","import { StereoEffect, StereoEffectOptions } from \"./StereoEffect\";\nimport { Frequency, Hertz, Positive } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface PhaserOptions extends StereoEffectOptions {\n\tfrequency: Frequency;\n\toctaves: Positive;\n\tstages: Positive;\n\tQ: Positive;\n\tbaseFrequency: Frequency;\n}\n\n/**\n * Phaser is a phaser effect. Phasers work by changing the phase\n * of different frequency components of an incoming signal. Read more on\n * [Wikipedia](https://en.wikipedia.org/wiki/Phaser_(effect)).\n * Inspiration for this phaser comes from [Tuna.js](https://github.com/Dinahmoe/tuna/).\n * @example\n * const phaser = new Tone.Phaser({\n * \tfrequency: 15,\n * \toctaves: 5,\n * \tbaseFrequency: 1000\n * }).toDestination();\n * const synth = new Tone.FMSynth().connect(phaser);\n * synth.triggerAttackRelease(\"E3\", \"2n\");\n * @category Effect\n */\nexport class Phaser extends StereoEffect<PhaserOptions> {\n\n\treadonly name: string = \"Phaser\";\n\n\t/**\n\t * the lfo which controls the frequency on the left side\n\t */\n\tprivate _lfoL: LFO;\n\n\t/**\n\t * the lfo which controls the frequency on the right side\n\t */\n\tprivate _lfoR: LFO;\n\n\t/**\n\t * the base modulation frequency\n\t */\n\tprivate _baseFrequency: Hertz;\n\n\t/**\n\t * the octaves of the phasing\n\t */\n\tprivate _octaves: Positive;\n\n\t/**\n\t * The quality factor of the filters\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * the array of filters for the left side\n\t */\n\tprivate _filtersL: BiquadFilterNode[];\n\n\t/**\n\t * the array of filters for the left side\n\t */\n\tprivate _filtersR: BiquadFilterNode[];\n\n\t/**\n\t * the frequency of the effect\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * @param frequency The speed of the phasing.\n\t * @param octaves The octaves of the effect.\n\t * @param baseFrequency The base frequency of the filters.\n\t */\n\tconstructor(frequency?: Frequency, octaves?: Positive, baseFrequency?: Frequency);\n\tconstructor(options?: Partial<PhaserOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Phaser.getDefaults(), arguments, [\"frequency\", \"octaves\", \"baseFrequency\"]));\n\t\tconst options = optionsFromArguments(Phaser.getDefaults(), arguments, [\"frequency\", \"octaves\", \"baseFrequency\"]);\n\n\t\tthis._lfoL = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tmin: 0,\n\t\t\tmax: 1\n\t\t});\n\t\tthis._lfoR = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t\tphase: 180,\n\t\t});\n\t\tthis._baseFrequency = this.toFrequency(options.baseFrequency);\n\t\tthis._octaves = options.octaves;\n\t\tthis.Q = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.Q,\n\t\t\tunits: \"positive\",\n\t\t});\n\t\tthis._filtersL = this._makeFilters(options.stages, this._lfoL);\n\t\tthis._filtersR = this._makeFilters(options.stages, this._lfoR);\n\n\t\tthis.frequency = this._lfoL.frequency;\n\t\tthis.frequency.value = options.frequency;\n\n\t\t// connect them up\n\t\tthis.connectEffectLeft(...this._filtersL);\n\t\tthis.connectEffectRight(...this._filtersR);\n\t\t// control the frequency with one LFO\n\t\tthis._lfoL.frequency.connect(this._lfoR.frequency);\n\t\t// set the options\n\t\tthis.baseFrequency = options.baseFrequency;\n\t\tthis.octaves = options.octaves;\n\t\t// start the lfo\n\t\tthis._lfoL.start();\n\t\tthis._lfoR.start();\n\t\treadOnly(this, [\"frequency\", \"Q\"]);\n\t}\n\n\tstatic getDefaults(): PhaserOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\tfrequency: 0.5,\n\t\t\toctaves: 3,\n\t\t\tstages: 10,\n\t\t\tQ: 10,\n\t\t\tbaseFrequency: 350,\n\t\t});\n\t}\n\n\tprivate _makeFilters(stages: number, connectToFreq: LFO): BiquadFilterNode[] {\n\t\tconst filters: BiquadFilterNode[] = [];\n\t\t// make all the filters\n\t\tfor (let i = 0; i < stages; i++) {\n\t\t\tconst filter = this.context.createBiquadFilter();\n\t\t\tfilter.type = \"allpass\";\n\t\t\tthis.Q.connect(filter.Q);\n\t\t\tconnectToFreq.connect(filter.frequency);\n\t\t\tfilters.push(filter);\n\t\t}\n\t\treturn filters;\n\t}\n\n\t/**\n\t * The number of octaves the phase goes above the baseFrequency\n\t */\n\tget octaves() {\n\t\treturn this._octaves;\n\t}\n\tset octaves(octaves) {\n\t\tthis._octaves = octaves;\n\t\tconst max = this._baseFrequency * Math.pow(2, octaves);\n\t\tthis._lfoL.max = max;\n\t\tthis._lfoR.max = max;\n\t}\n\n\t/**\n\t * The the base frequency of the filters.\n\t */\n\tget baseFrequency(): Frequency {\n\t\treturn this._baseFrequency;\n\t}\n\tset baseFrequency(freq) {\n\t\tthis._baseFrequency = this.toFrequency(freq);\n\t\tthis._lfoL.min = this._baseFrequency;\n\t\tthis._lfoR.min = this._baseFrequency;\n\t\tthis.octaves = this._octaves;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.Q.dispose();\n\t\tthis._lfoL.dispose();\n\t\tthis._lfoR.dispose();\n\t\tthis._filtersL.forEach(f => f.disconnect());\n\t\tthis._filtersR.forEach(f => f.disconnect());\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n\n","import { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Seconds, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect, EffectOptions } from \"./Effect\";\nimport { OfflineContext } from \"../core/context/OfflineContext\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assertRange } from \"../core/util/Debug\";\n\ninterface ReverbOptions extends EffectOptions {\n\tdecay: Seconds;\n\tpreDelay: Seconds;\n}\n\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until [[ready]] resolves before it will make a sound. \n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n * \n * @category Effect\n */\nexport class Reverb extends Effect<ReverbOptions> {\n\n\treadonly name: string = \"Reverb\";\n\n\t/**\n\t * Convolver node\n\t */\n\tprivate _convolver: ConvolverNode = this.context.createConvolver();\n\n\t/**\n\t * The duration of the reverb.\n\t */\n\tprivate _decay: Seconds;\n\t\n\t/**\n\t * The amount of time before the reverb is fully ramped in.\n\t */\n\tprivate _preDelay: Seconds;\n\n\t/**\n\t * Resolves when the reverb buffer is generated. Whenever either [[decay]]\n\t * or [[preDelay]] are set, you have to wait until [[ready]] resolves\n\t * before the IR is generated with the latest values. \n\t */\n\tready: Promise<void> = Promise.resolve();\n\n\t/**\n\t * @param decay The amount of time it will reverberate for.\n\t */\n\tconstructor(decay?: Seconds);\n\tconstructor(options?: Partial<ReverbOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]));\n\t\tconst options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n\n\t\tthis._decay = options.decay;\n\t\tthis._preDelay = options.preDelay;\n\t\tthis.generate();\n\n\t\tthis.connectEffect(this._convolver);\n\t}\n\n\tstatic getDefaults(): ReverbOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tdecay: 1.5,\n\t\t\tpreDelay: 0.01,\n\t\t});\n\t}\n\n\t/**\n\t * The duration of the reverb.\n\t */\n\tget decay(): Time {\n\t\treturn this._decay;\n\t}\n\tset decay(time) {\n\t\ttime = this.toSeconds(time);\n\t\tassertRange(time, 0.001);\n\t\tthis._decay = time;\n\t\tthis.generate();\n\t}\n\n\t/**\n\t * The amount of time before the reverb is fully ramped in.\n\t */\n\tget preDelay(): Time {\n\t\treturn this._preDelay;\n\t}\n\tset preDelay(time) {\n\t\ttime = this.toSeconds(time);\n\t\tassertRange(time, 0);\n\t\tthis._preDelay = time;\n\t\tthis.generate();\n\t}\n\n\t/**\n\t * Generate the Impulse Response. Returns a promise while the IR is being generated.\n\t * @return Promise which returns this object.\n\t */\n\tasync generate(): Promise<this> {\n\t\tconst previousReady = this.ready;\n\n\t\t// create a noise burst which decays over the duration in each channel\n\t\tconst context = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);\n\t\tconst noiseL = new Noise({ context });\n\t\tconst noiseR = new Noise({ context });\n\t\tconst merge = new Merge({ context });\n\t\tnoiseL.connect(merge, 0, 0);\n\t\tnoiseR.connect(merge, 0, 1);\n\t\tconst gainNode = new Gain({ context }).toDestination();\n\t\tmerge.connect(gainNode);\n\t\tnoiseL.start(0);\n\t\tnoiseR.start(0);\n\t\t// predelay\n\t\tgainNode.gain.setValueAtTime(0, 0);\n\t\tgainNode.gain.setValueAtTime(1, this._preDelay);\n\t\t// decay\n\t\tgainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);\n\t\t\n\t\t// render the buffer\n\t\tconst renderPromise = context.render();\n\t\tthis.ready = renderPromise.then(noOp);\n\t\t\n\t\t// wait for the previous `ready` to resolve\n\t\tawait previousReady;\n\t\t// set the buffer\n\t\tthis._convolver.buffer = (await renderPromise).get() as AudioBuffer;\n\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._convolver.disconnect();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Split } from \"./Split\";\nimport { Add } from \"../../signal/Add\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Subtract } from \"../../signal/Subtract\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\nexport type MidSideSplitOptions = ToneAudioNodeOptions;\n\n/**\n * Mid/Side processing separates the the 'mid' signal (which comes out of both the left and the right channel)\n * and the 'side' (which only comes out of the the side channels).\n * ```\n * Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right\n * Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and right\n * ```\n */\nexport class MidSideSplit extends ToneAudioNode<MidSideSplitOptions> {\n\t\n\treadonly name: string = \"MidSideSplit\";\n\n\treadonly input: Split;\n\n\t/**\n\t * There is no output node, use either [[mid]] or [[side]] outputs.\n\t */\n\treadonly output: undefined;\n\t/**\n\t * Split the incoming signal into left and right channels\n\t */\n\tprivate _split: Split;\n\n\t/**\n\t * Sums the left and right channels\n\t */\n\tprivate _midAdd: Add;\n\n\t/**\n\t * Subtract left and right channels. \n\t */\n\tprivate _sideSubtract: Subtract;\n\n\t/**\n\t * The \"mid\" output. `(Left+Right)/sqrt(2)`\n\t */\n\treadonly mid: ToneAudioNode;\n\n\t/**\n\t * The \"side\" output. `(Left-Right)/sqrt(2)`\n\t */\n\treadonly side: ToneAudioNode;\n\t\n\tconstructor(options?: Partial<MidSideSplitOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MidSideSplit.getDefaults(), arguments));\n\n\t\tthis._split = this.input = new Split({\n\t\t\tchannels: 2,\n\t\t\tcontext: this.context\n\t\t});\n\t\tthis._midAdd = new Add({ context: this.context });\n\t\tthis.mid = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: Math.SQRT1_2,\n\t\t});\n\t\tthis._sideSubtract = new Subtract({ context: this.context });\n\t\tthis.side = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: Math.SQRT1_2,\n\t\t});\n\n\t\tthis._split.connect(this._midAdd, 0);\n\t\tthis._split.connect(this._midAdd.addend, 1);\n\t\tthis._split.connect(this._sideSubtract, 0);\n\t\tthis._split.connect(this._sideSubtract.subtrahend, 1);\n\t\tthis._midAdd.connect(this.mid);\n\t\tthis._sideSubtract.connect(this.side);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.side.dispose();\n\t\tthis._midAdd.dispose();\n\t\tthis._sideSubtract.dispose();\n\t\tthis._split.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Merge } from \"./Merge\";\nimport { Add } from \"../../signal/Add\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Subtract } from \"../../signal/Subtract\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\nexport type MidSideMergeOptions = ToneAudioNodeOptions;\n\n/**\n * MidSideMerge merges the mid and side signal after they've been separated by [[MidSideMerge]]\n * ```\n * Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right\n * Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and righ\n * ```\n */\nexport class MidSideMerge extends ToneAudioNode<MidSideMergeOptions> {\n\t\n\treadonly name: string = \"MidSideMerge\";\n\n\t/**\n\t * There is no input, connect sources to either [[mid]] or [[side]] inputs.\n\t */\n\treadonly input: undefined;\n\n\t/**\n\t * The merged signal\n\t */\n\treadonly output: Merge;\n\n\t/**\n\t * Merge the incoming signal into left and right channels\n\t */\n\tprivate _merge: Merge;\n\n\t/**\n\t * The \"mid\" input.\n\t */\n\treadonly mid: ToneAudioNode;\n\n\t/**\n\t * The \"side\" input.\n\t */\n\treadonly side: ToneAudioNode;\n\n\t/**\n\t * Recombine the mid/side into Left\n\t */\n\tprivate _left: Add;\n\n\t/**\n\t * Recombine the mid/side into Right\n\t */\n\tprivate _right: Subtract;\n\n\t/**\n\t * Multiply the right by sqrt(1/2)\n\t */\n\tprivate _leftMult: Multiply;\n\n\t/**\n\t * Multiply the left by sqrt(1/2)\n\t */\n\tprivate _rightMult: Multiply;\n\t\n\tconstructor(options?: Partial<MidSideMergeOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MidSideMerge.getDefaults(), arguments));\n\t\tthis.mid = new Gain({ context: this.context });\n\t\tthis.side = new Gain({ context: this.context });\n\t\tthis._left = new Add({ context: this.context });\n\t\tthis._leftMult = new Multiply({\n\t\t\tcontext: this.context, \n\t\t\tvalue: Math.SQRT1_2\n\t\t});\n\t\tthis._right = new Subtract({ context: this.context });\n\t\tthis._rightMult = new Multiply({\n\t\t\tcontext: this.context, \n\t\t\tvalue: Math.SQRT1_2\n\t\t});\n\t\tthis._merge = this.output = new Merge({ context: this.context });\n\n\t\tthis.mid.fan(this._left);\n\t\tthis.side.connect(this._left.addend);\n\t\tthis.mid.connect(this._right);\n\t\tthis.side.connect(this._right.subtrahend);\n\t\tthis._left.connect(this._leftMult);\n\t\tthis._right.connect(this._rightMult);\n\t\tthis._leftMult.connect(this._merge, 0, 0);\n\t\tthis._rightMult.connect(this._merge, 0, 1);\n\t}\n\t\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.side.dispose();\n\t\tthis._leftMult.dispose();\n\t\tthis._rightMult.dispose();\n\t\tthis._left.dispose();\n\t\tthis._right.dispose();\n\t\treturn this;\n\t}\n}\n","import { Effect, EffectOptions } from \"./Effect\";\nimport { MidSideSplit } from \"../component/channel/MidSideSplit\";\nimport { MidSideMerge } from \"../component/channel/MidSideMerge\";\nimport { OutputNode, ToneAudioNode } from \"../core/context/ToneAudioNode\";\n\nexport type MidSideEffectOptions = EffectOptions;\n\n/**\n * Mid/Side processing separates the the 'mid' signal\n * (which comes out of both the left and the right channel)\n * and the 'side' (which only comes out of the the side channels)\n * and effects them separately before being recombined.\n * Applies a Mid/Side seperation and recombination.\n * Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).\n * This is a base-class for Mid/Side Effects.\n */\nexport abstract class MidSideEffect<Options extends MidSideEffectOptions> extends Effect<Options> {\n\n\treadonly name: string = \"MidSideEffect\";\n\n\t/**\n\t * The mid/side split\n\t */\n\tprivate _midSideSplit: MidSideSplit;\n\t\n\t/**\n\t * The mid/side merge\n\t */\n\tprivate _midSideMerge: MidSideMerge;\n\t\n\t/**\n\t * The mid send. Connect to mid processing\n\t */\n\tprotected _midSend: ToneAudioNode;\n\t\n\t/**\n\t * The side send. Connect to side processing\n\t */\n\tprotected _sideSend: ToneAudioNode;\n\t\n\t/**\n\t * The mid return connection\n\t */\n\tprotected _midReturn: ToneAudioNode;\n\t\n\t/**\n\t * The side return connection\n\t */\n\tprotected _sideReturn: ToneAudioNode;\n\n\tconstructor(options: MidSideEffectOptions) {\n\n\t\tsuper(options);\n\n\t\tthis._midSideMerge = new MidSideMerge({ context: this.context });\n\t\tthis._midSideSplit = new MidSideSplit({ context: this.context });\n\t\tthis._midSend = this._midSideSplit.mid;\n\t\tthis._sideSend = this._midSideSplit.side;\n\t\tthis._midReturn = this._midSideMerge.mid;\n\t\tthis._sideReturn = this._midSideMerge.side;\n\n\t\t// the connections\n\t\tthis.effectSend.connect(this._midSideSplit);\n\t\tthis._midSideMerge.connect(this.effectReturn);\n\t}\n\n\t/**\n\t * Connect the mid chain of the effect\n\t */\n\tprotected connectEffectMid(...nodes: OutputNode[]): void{\n\t\tthis._midSend.chain(...nodes, this._midReturn);\n\t}\n\t\n\t/**\n\t * Connect the side chain of the effect\n\t */\n\tprotected connectEffectSide(...nodes: OutputNode[]): void{\n\t\tthis._sideSend.chain(...nodes, this._sideReturn);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._midSideSplit.dispose();\n\t\tthis._midSideMerge.dispose();\n\t\tthis._midSend.dispose();\n\t\tthis._sideSend.dispose();\n\t\tthis._midReturn.dispose();\n\t\tthis._sideReturn.dispose();\n\t\treturn this;\n\t}\n}\n\n","import { MidSideEffect, MidSideEffectOptions } from \"../effect/MidSideEffect\";\nimport { Signal } from \"../signal/Signal\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Subtract } from \"../signal/Subtract\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { connect } from \"../core/context/ToneAudioNode\";\n\nexport interface StereoWidenerOptions extends MidSideEffectOptions {\n\twidth: NormalRange;\n}\n\n/**\n * Applies a width factor to the mid/side seperation.\n * 0 is all mid and 1 is all side.\n * Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).\n * ```\n * Mid *= 2*(1-width)<br>\n * Side *= 2*width\n * ```\n * @category Effect\n */\nexport class StereoWidener extends MidSideEffect<StereoWidenerOptions> {\n\n\treadonly name: string = \"StereoWidener\";\n\n\t/**\n\t * The width control. 0 = 100% mid. 1 = 100% side. 0.5 = no change.\n\t */\n\treadonly width: Signal<\"normalRange\">;\n\t\n\t/**\n\t * Two times the (1-width) for the mid channel\n\t */\n\tprivate _twoTimesWidthMid: Multiply;\n\t\n\t/**\n\t * Two times the width for the side channel\n\t */\n\tprivate _twoTimesWidthSide: Multiply;\n\t\n\t/**\n\t * Mid multiplier\n\t */\n\tprivate _midMult: Multiply;\n\t\n\t/**\n\t * 1 - width\n\t */\n\tprivate _oneMinusWidth: Subtract;\n\t\n\t/**\n\t * Side multiplier\n\t */\n\tprivate _sideMult: Multiply;\n\n\t/**\n\t * @param width The stereo width. A width of 0 is mono and 1 is stereo. 0.5 is no change.\n\t */\n\tconstructor(width?: NormalRange);\n\tconstructor(options?: Partial<StereoWidenerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(StereoWidener.getDefaults(), arguments, [\"width\"]));\n\t\tconst options = optionsFromArguments(StereoWidener.getDefaults(), arguments, [\"width\"]);\n\t\tthis.width = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.width,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\t\treadOnly(this, [\"width\"]);\n\t\tthis._twoTimesWidthMid = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: 2,\n\t\t});\n\t\tthis._twoTimesWidthSide = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: 2,\n\t\t});\n\t\tthis._midMult = new Multiply({ context: this.context });\n\t\tthis._twoTimesWidthMid.connect(this._midMult.factor);\n\t\tthis.connectEffectMid(this._midMult);\n\n\t\tthis._oneMinusWidth = new Subtract({ context: this.context });\n\t\tthis._oneMinusWidth.connect(this._twoTimesWidthMid);\n\t\tconnect(this.context.getConstant(1), this._oneMinusWidth);\n\t\tthis.width.connect(this._oneMinusWidth.subtrahend);\n\n\t\tthis._sideMult = new Multiply({ context: this.context });\n\t\tthis.width.connect(this._twoTimesWidthSide);\n\t\tthis._twoTimesWidthSide.connect(this._sideMult.factor);\n\t\tthis.connectEffectSide(this._sideMult);\n\t}\n\n\tstatic getDefaults(): StereoWidenerOptions {\n\t\treturn Object.assign(MidSideEffect.getDefaults(), {\n\t\t\twidth: 0.5,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.width.dispose();\n\t\tthis._midMult.dispose();\n\t\tthis._sideMult.dispose();\n\t\tthis._twoTimesWidthMid.dispose();\n\t\tthis._twoTimesWidthSide.dispose();\n\t\tthis._oneMinusWidth.dispose();\n\t\treturn this;\n\t}\n}\n","import { StereoEffect, StereoEffectOptions } from \"./StereoEffect\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Signal } from \"../signal/Signal\";\nimport { Degrees, Frequency, NormalRange, Time } from \"../core/type/Units\";\nimport { ToneOscillatorType } from \"../source/oscillator/OscillatorInterface\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface TremoloOptions extends StereoEffectOptions {\n\tfrequency: Frequency;\n\ttype: ToneOscillatorType;\n\tdepth: NormalRange;\n\tspread: Degrees;\n}\n\n/**\n * Tremolo modulates the amplitude of an incoming signal using an [[LFO]].\n * The effect is a stereo effect where the modulation phase is inverted in each channel.\n *\n * @example\n * // create a tremolo and start it's LFO\n * const tremolo = new Tone.Tremolo(9, 0.75).toDestination().start();\n * // route an oscillator through the tremolo and start it\n * const oscillator = new Tone.Oscillator().connect(tremolo).start();\n * \n * @category Effect\n */\nexport class Tremolo extends StereoEffect<TremoloOptions> {\n\n\treadonly name: string = \"Tremolo\";\n\n\t/**\n\t * The tremolo LFO in the left channel\n\t */\n\tprivate _lfoL: LFO;\n\n\t/**\n\t * The tremolo LFO in the left channel\n\t */\n\tprivate _lfoR: LFO;\n\n\t/**\n\t * Where the gain is multiplied\n\t */\n\tprivate _amplitudeL: Gain;\n\n\t/**\n\t * Where the gain is multiplied\n\t */\n\tprivate _amplitudeR: Gain;\n\n\t/**\n\t * The frequency of the tremolo.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The depth of the effect. A depth of 0, has no effect\n\t * on the amplitude, and a depth of 1 makes the amplitude\n\t * modulate fully between 0 and 1.\n\t */\n\treadonly depth: Signal<\"normalRange\">;\n\n\t/**\n\t * @param frequency The rate of the effect.\n\t * @param depth The depth of the effect.\n\t */\n\tconstructor(frequency?: Frequency, depth?: NormalRange);\n\tconstructor(options?: Partial<TremoloOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Tremolo.getDefaults(), arguments, [\"frequency\", \"depth\"]));\n\t\tconst options = optionsFromArguments(Tremolo.getDefaults(), arguments, [\"frequency\", \"depth\"]);\n\n\t\tthis._lfoL = new LFO({\n\t\t\tcontext: this.context,\n\t\t\ttype: options.type,\n\t\t\tmin: 1,\n\t\t\tmax: 0,\n\t\t});\n\t\tthis._lfoR = new LFO({\n\t\t\tcontext: this.context,\n\t\t\ttype: options.type,\n\t\t\tmin: 1,\n\t\t\tmax: 0,\n\t\t});\n\t\tthis._amplitudeL = new Gain({ context: this.context });\n\t\tthis._amplitudeR = new Gain({ context: this.context });\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.frequency,\n\t\t\tunits: \"frequency\",\n\t\t});\n\t\tthis.depth = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.depth,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\n\t\treadOnly(this, [\"frequency\", \"depth\"]);\n\t\tthis.connectEffectLeft(this._amplitudeL);\n\t\tthis.connectEffectRight(this._amplitudeR);\n\t\tthis._lfoL.connect(this._amplitudeL.gain);\n\t\tthis._lfoR.connect(this._amplitudeR.gain);\n\t\tthis.frequency.fan(this._lfoL.frequency, this._lfoR.frequency);\n\t\tthis.depth.fan(this._lfoR.amplitude, this._lfoL.amplitude);\n\t\tthis.spread = options.spread;\n\t}\n\n\tstatic getDefaults(): TremoloOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\tfrequency: 10,\n\t\t\ttype: \"sine\" as \"sine\",\n\t\t\tdepth: 0.5,\n\t\t\tspread: 180,\n\t\t});\n\t}\n\n\t/**\n\t * Start the tremolo.\n\t */\n\tstart(time?: Time): this {\n\t\tthis._lfoL.start(time);\n\t\tthis._lfoR.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the tremolo.\n\t */\n\tstop(time?: Time): this {\n\t\tthis._lfoL.stop(time);\n\t\tthis._lfoR.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the effect to the transport.\n\t */\n\tsync(): this {\n\t\tthis._lfoL.sync();\n\t\tthis._lfoR.sync();\n\t\tthis.context.transport.syncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the filter from the transport\n\t */\n\tunsync(): this {\n\t\tthis._lfoL.unsync();\n\t\tthis._lfoR.unsync();\n\t\tthis.context.transport.unsyncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The oscillator type.\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._lfoL.type;\n\t}\n\tset type(type) {\n\t\tthis._lfoL.type = type;\n\t\tthis._lfoR.type = type;\n\t}\n\n\t/**\n\t * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.\n\t * When set to 180, LFO's will be panned hard left and right respectively.\n\t */\n\tget spread(): Degrees {\n\t\treturn this._lfoR.phase - this._lfoL.phase; // 180\n\t}\n\tset spread(spread) {\n\t\tthis._lfoL.phase = 90 - (spread / 2);\n\t\tthis._lfoR.phase = (spread / 2) + 90;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._lfoL.dispose();\n\t\tthis._lfoR.dispose();\n\t\tthis._amplitudeL.dispose();\n\t\tthis._amplitudeR.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.depth.dispose();\n\t\treturn this;\n\t}\n}\n","import { Effect, EffectOptions } from \"./Effect\";\nimport { ToneOscillatorType } from \"../source/oscillator/OscillatorInterface\";\nimport { Frequency, NormalRange, Seconds } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Delay } from \"../core/context/Delay\";\nimport { Signal } from \"../signal/Signal\";\nimport { Param } from \"../core/context/Param\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface VibratoOptions extends EffectOptions {\n\tmaxDelay: Seconds;\n\tfrequency: Frequency;\n\tdepth: NormalRange;\n\ttype: ToneOscillatorType;\n}\n/**\n * A Vibrato effect composed of a Tone.Delay and a Tone.LFO. The LFO\n * modulates the delayTime of the delay, causing the pitch to rise and fall. \n * @category Effect\n */\nexport class Vibrato extends Effect<VibratoOptions> {\n\n\treadonly name: string = \"Vibrato\";\n\t/**\n\t * The delay node used for the vibrato effect\n\t */\n\tprivate _delayNode: Delay;\n\t\n\t/**\n\t * The LFO used to control the vibrato\n\t */\n\tprivate _lfo: LFO;\n\t\n\t/**\n\t * The frequency of the vibrato\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\t\n\t/**\n\t * The depth of the vibrato. \n\t */\n\treadonly depth: Param<\"normalRange\">;\n\n\t/**\n\t * @param frequency The frequency of the vibrato.\n\t * @param depth The amount the pitch is modulated.\n\t */\n\tconstructor(frequency?: Frequency, depth?: NormalRange);\n\tconstructor(options?: Partial<VibratoOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Vibrato.getDefaults(), arguments, [\"frequency\", \"depth\"]));\n\t\tconst options = optionsFromArguments(Vibrato.getDefaults(), arguments, [\"frequency\", \"depth\"]);\n\n\t\tthis._delayNode = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tdelayTime: 0,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis._lfo = new LFO({\n\t\t\tcontext: this.context,\n\t\t\ttype: options.type,\n\t\t\tmin: 0,\n\t\t\tmax: options.maxDelay, \n\t\t\tfrequency: options.frequency,\n\t\t\tphase: -90 // offse the phase so the resting position is in the center\n\t\t}).start().connect(this._delayNode.delayTime);\n\t\tthis.frequency = this._lfo.frequency;\n\t\tthis.depth = this._lfo.amplitude;\n\n\t\tthis.depth.value = options.depth;\n\t\treadOnly(this, [\"frequency\", \"depth\"]);\n\t\tthis.effectSend.chain(this._delayNode, this.effectReturn);\n\t}\n\n\tstatic getDefaults(): VibratoOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tmaxDelay: 0.005,\n\t\t\tfrequency: 5,\n\t\t\tdepth: 0.1,\n\t\t\ttype: \"sine\" as \"sine\"\n\t\t});\n\t}\n\n\t/**\n\t * Type of oscillator attached to the Vibrato.\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._lfo.type;\n\t}\n\tset type(type) {\n\t\tthis._lfo.type = type;\n\t}\n\t\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.dispose();\n\t\tthis._lfo.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.depth.dispose();\n\t\treturn this;\n\t}\n}\n","import { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange, PowerOfTwo } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Split } from \"../channel/Split\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { assert, assertRange } from \"../../core/util/Debug\";\n\nexport type AnalyserType = \"fft\" | \"waveform\";\n\nexport interface AnalyserOptions extends ToneAudioNodeOptions {\n\tsize: PowerOfTwo;\n\ttype: AnalyserType;\n\tsmoothing: NormalRange;\n\tchannels: number;\n}\n\n/**\n * Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n * Extracts FFT or Waveform data from the incoming signal.\n * @category Component\n */\nexport class Analyser extends ToneAudioNode<AnalyserOptions> {\n\n\treadonly name: string = \"Analyser\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The analyser node.\n\t */\n\tprivate _analysers: AnalyserNode[] = [];\n\n\t/**\n\t * Input and output are a gain node\n\t */\n\tprivate _gain: Gain;\n\n\t/**\n\t * The channel splitter node\n\t */\n\tprivate _split: Split;\n\n\t/**\n\t * The analysis type\n\t */\n\tprivate _type!: AnalyserType;\n\n\t/**\n\t * The buffer that the FFT data is written to\n\t */\n\tprivate _buffers: Float32Array[] = [];\n\n\t/**\n\t * @param type The return type of the analysis, either \"fft\", or \"waveform\".\n\t * @param size The size of the FFT. This must be a power of two in the range 16 to 16384.\n\t */\n\tconstructor(type?: AnalyserType, size?: number);\n\tconstructor(options?: Partial<AnalyserOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]));\n\t\tconst options = optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]);\n\n\t\tthis.input = this.output = this._gain = new Gain({ context: this.context });\n\t\tthis._split = new Split({\n\t\t\tcontext: this.context,\n\t\t\tchannels: options.channels,\n\t\t});\n\t\tthis.input.connect(this._split);\n\t\t\n\t\tassertRange(options.channels, 1);\n\t\t\n\t\t// create the analysers\n\t\tfor (let channel = 0; channel < options.channels; channel++) {\n\t\t\tthis._analysers[channel] = this.context.createAnalyser();\n\t\t\tthis._split.connect(this._analysers[channel], channel, 0);\n\t\t}\n\n\t\t// set the values initially\n\t\tthis.size = options.size;\n\t\tthis.type = options.type;\n\t}\n\n\tstatic getDefaults(): AnalyserOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsize: 1024,\n\t\t\tsmoothing: 0.8,\n\t\t\ttype: \"fft\" as AnalyserType,\n\t\t\tchannels: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Run the analysis given the current settings. If [[channels]] = 1,\n\t * it will return a Float32Array. If [[channels]] > 1, it will\n\t * return an array of Float32Arrays where each index in the array\n\t * represents the analysis done on a channel.\n\t */\n\tgetValue(): Float32Array | Float32Array[] {\n\t\tthis._analysers.forEach((analyser, index) => {\n\t\t\tconst buffer = this._buffers[index];\n\t\t\tif (this._type === \"fft\") {\n\t\t\t\tanalyser.getFloatFrequencyData(buffer);\n\t\t\t} else if (this._type === \"waveform\") {\n\t\t\t\tanalyser.getFloatTimeDomainData(buffer);\n\t\t\t}\n\t\t});\n\t\tif (this.channels === 1) {\n\t\t\treturn this._buffers[0];\n\t\t} else {\n\t\t\treturn this._buffers;\n\t\t}\n\t}\n\n\t/**\n\t * The size of analysis. This must be a power of two in the range 16 to 16384.\n\t */\n\tget size(): PowerOfTwo {\n\t\treturn this._analysers[0].frequencyBinCount;\n\t}\n\tset size(size: PowerOfTwo) {\n\t\tthis._analysers.forEach((analyser, index) => {\n\t\t\tanalyser.fftSize = size * 2;\n\t\t\tthis._buffers[index] = new Float32Array(size);\n\t\t});\n\t}\n\n\t/**\n\t * The number of channels the analyser does the analysis on. Channel\n\t * separation is done using [[Split]]\n\t */\n\tget channels(): number {\n\t\treturn this._analysers.length;\n\t}\n\n\t/**\n\t * The analysis function returned by analyser.getValue(), either \"fft\" or \"waveform\".\n\t */\n\tget type(): AnalyserType {\n\t\treturn this._type;\n\t}\n\tset type(type: AnalyserType) {\n\t\tassert(type === \"waveform\" || type === \"fft\", `Analyser: invalid type: ${type}`);\n\t\tthis._type = type;\n\t}\n\n\t/**\n\t * 0 represents no time averaging with the last analysis frame.\n\t */\n\tget smoothing(): NormalRange {\n\t\treturn this._analysers[0].smoothingTimeConstant;\n\t}\n\tset smoothing(val: NormalRange) {\n\t\tthis._analysers.forEach(a => a.smoothingTimeConstant = val);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._analysers.forEach(a => a.disconnect());\n\t\tthis._split.dispose();\n\t\tthis._gain.dispose();\n\t\treturn this;\n\t}\n}\n","import { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Analyser } from \"./Analyser\";\n\nexport type MeterBaseOptions = ToneAudioNodeOptions;\n\n/**\n * The base class for Metering classes.\n */\nexport class MeterBase<Options extends MeterBaseOptions> extends ToneAudioNode<Options> {\n\n\treadonly name: string = \"MeterBase\";\n\n\t/**\n\t * The signal to be analysed\n\t */\n\tinput: InputNode;\n\n\t/**\n\t * The output is just a pass through of the input\n\t */\n\toutput: OutputNode;\n\n\t/**\n\t * The analyser node for the incoming signal\n\t */\n\tprotected _analyser: Analyser;\n\n\tconstructor(options?: Partial<MeterBaseOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MeterBase.getDefaults(), arguments));\n\n\t\tthis.input = this.output = this._analyser = new Analyser({\n\t\t\tcontext: this.context,\n\t\t\tsize: 256,\n\t\t\ttype: \"waveform\",\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._analyser.dispose();\n\t\treturn this;\n\t}\n}\n","import { gainToDb } from \"../../core/type/Conversions\";\nimport { NormalRange } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase, MeterBaseOptions } from \"./MeterBase\";\nimport { warn } from \"../../core/util/Debug\";\nimport { Analyser } from \"./Analyser\";\n\nexport interface MeterOptions extends MeterBaseOptions {\n\tsmoothing: NormalRange;\n\tnormalRange: boolean;\n\tchannels: number;\n}\n\n/**\n * Meter gets the [RMS](https://en.wikipedia.org/wiki/Root_mean_square)\n * of an input signal. It can also get the raw value of the input signal.\n *\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia();\n * mic.open();\n * // connect mic to the meter\n * mic.connect(meter);\n * // the current level of the mic\n * setInterval(() => console.log(meter.getValue()), 100);\n * @category Component\n */\nexport class Meter extends MeterBase<MeterOptions> {\n\n\treadonly name: string = \"Meter\";\n\n\t/**\n\t * If the output should be in decibels or normal range between 0-1. If `normalRange` is false,\n\t * the output range will be the measured decibel value, otherwise the decibel value will be converted to\n\t * the range of 0-1\n\t */\n\tnormalRange: boolean;\n\n\t/**\n\t * A value from between 0 and 1 where 0 represents no time averaging with the last analysis frame.\n\t */\n\tsmoothing: number;\n\n\t/**\n\t * The previous frame's value\n\t */\n\tprivate _rms = 0;\n\n\t/**\n\t * @param smoothing The amount of smoothing applied between frames.\n\t */\n\tconstructor(smoothing?: NormalRange);\n\tconstructor(options?: Partial<MeterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Meter.getDefaults(), arguments, [\"smoothing\"]));\n\t\tconst options = optionsFromArguments(Meter.getDefaults(), arguments, [\"smoothing\"]);\n\n\t\tthis.input = this.output = this._analyser = new Analyser({\n\t\t\tcontext: this.context,\n\t\t\tsize: 256,\n\t\t\ttype: \"waveform\",\n\t\t\tchannels: options.channels,\n\t\t});\n\n\t\tthis.smoothing = options.smoothing,\n\t\tthis.normalRange = options.normalRange;\n\t}\n\n\tstatic getDefaults(): MeterOptions {\n\t\treturn Object.assign(MeterBase.getDefaults(), {\n\t\t\tsmoothing: 0.8,\n\t\t\tnormalRange: false,\n\t\t\tchannels: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Use [[getValue]] instead. For the previous getValue behavior, use DCMeter.\n\t * @deprecated\n\t */\n\tgetLevel(): number | number[] {\n\t\twarn(\"'getLevel' has been changed to 'getValue'\");\n\t\treturn this.getValue();\n\t}\n\n\t/**\n\t * Get the current value of the incoming signal. \n\t * Output is in decibels when [[normalRange]] is `false`.\n\t * If [[channels]] = 1, then the output is a single number\n\t * representing the value of the input signal. When [[channels]] > 1,\n\t * then each channel is returned as a value in a number array. \n\t */\n\tgetValue(): number | number[] {\n\t\tconst aValues = this._analyser.getValue();\n\t\tconst channelValues = this.channels === 1 ? [aValues as Float32Array] : aValues as Float32Array[];\n\t\tconst vals = channelValues.map(values => {\n\t\t\tconst totalSquared = values.reduce((total, current) => total + current * current, 0);\n\t\t\tconst rms = Math.sqrt(totalSquared / values.length);\n\t\t\t// the rms can only fall at the rate of the smoothing\n\t\t\t// but can jump up instantly\n\t\t\tthis._rms = Math.max(rms, this._rms * this.smoothing);\n\t\t\treturn this.normalRange ? this._rms : gainToDb(this._rms);\n\t\t});\n\t\tif (this.channels === 1) {\n\t\t\treturn vals[0];\n\t\t} else {\n\t\t\treturn vals;\n\t\t}\n\t}\n\n\t/**\n\t * The number of channels of analysis.\n\t */\n\tget channels(): number {\n\t\treturn this._analyser.channels;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._analyser.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { dbToGain } from \"../../core/type/Conversions\";\nimport { Hertz, NormalRange, PowerOfTwo } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase, MeterBaseOptions } from \"./MeterBase\";\nimport { assert } from \"../../core/util/Debug\";\n\nexport interface FFTOptions extends MeterBaseOptions {\n\tsize: PowerOfTwo;\n\tsmoothing: NormalRange;\n\tnormalRange: boolean;\n}\n\n/**\n * Get the current frequency data of the connected audio source using a fast Fourier transform.\n * @category Component\n */\nexport class FFT extends MeterBase<FFTOptions> {\n\n\treadonly name: string = \"FFT\";\n\n\t/**\n\t * If the output should be in decibels or normal range between 0-1. If `normalRange` is false,\n\t * the output range will be the measured decibel value, otherwise the decibel value will be converted to\n\t * the range of 0-1\n\t */\n\tnormalRange: boolean;\n\n\t/**\n\t * @param size The size of the FFT. Value must be a power of two in the range 16 to 16384.\n\t */\n\tconstructor(size?: PowerOfTwo);\n\tconstructor(options?: Partial<FFTOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]));\n\t\tconst options = optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]);\n\n\t\tthis.normalRange = options.normalRange;\n\t\tthis._analyser.type = \"fft\";\n\t\tthis.size = options.size;\n\t}\n\n\tstatic getDefaults(): FFTOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tnormalRange: false,\n\t\t\tsize: 1024,\n\t\t\tsmoothing: 0.8,\n\t\t});\n\t}\n\n\t/**\n\t * Gets the current frequency data from the connected audio source.\n\t * Returns the frequency data of length [[size]] as a Float32Array of decibel values.\n\t */\n\tgetValue(): Float32Array {\n\t\tconst values = this._analyser.getValue() as Float32Array;\n\t\treturn values.map(v => this.normalRange ? dbToGain(v) : v);\n\t}\n\n\t/**\n\t * The size of analysis. This must be a power of two in the range 16 to 16384.\n\t * Determines the size of the array returned by [[getValue]] (i.e. the number of\n\t * frequency bins). Large FFT sizes may be costly to compute.\n\t */\n\tget size(): PowerOfTwo {\n\t\treturn this._analyser.size;\n\t}\n\tset size(size) {\n\t\tthis._analyser.size = size;\n\t}\n\n\t/**\n\t * 0 represents no time averaging with the last analysis frame.\n\t */\n\tget smoothing(): NormalRange {\n\t\treturn this._analyser.smoothing;\n\t}\n\tset smoothing(val) {\n\t\tthis._analyser.smoothing = val;\n\t}\n\n\t/**\n\t * Returns the frequency value in hertz of each of the indices of the FFT's [[getValue]] response.\n\t * @example\n\t * const fft = new Tone.FFT(32);\n\t * console.log([0, 1, 2, 3, 4].map(index => fft.getFrequencyOfIndex(index)));\n\t */\n\tgetFrequencyOfIndex(index: number): Hertz {\n\t\tassert(0 <= index && index < this.size, `index must be greater than or equal to 0 and less than ${this.size}`);\n\t\treturn index * this.context.sampleRate / (this.size * 2);\n\t}\n}\n","import { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase, MeterBaseOptions } from \"./MeterBase\";\n\nexport type DCMeterOptions = MeterBaseOptions;\n\n/**\n * DCMeter gets the raw value of the input signal at the current time.\n *\n * @example\n * const meter = new Tone.DCMeter();\n * const mic = new Tone.UserMedia();\n * mic.open();\n * // connect mic to the meter\n * mic.connect(meter);\n * // the current level of the mic\n * const level = meter.getValue();\n * @category Component\n */\nexport class DCMeter extends MeterBase<DCMeterOptions> {\n\n\treadonly name: string = \"DCMeter\";\n\n\tconstructor(options?: Partial<DCMeterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(DCMeter.getDefaults(), arguments));\n\n\t\tthis._analyser.type = \"waveform\";\n\t\tthis._analyser.size = 256;\n\t}\n\n\t/**\n\t * Get the signal value of the incoming signal\n\t */\n\tgetValue(): number {\n\t\tconst value = this._analyser.getValue() as Float32Array;\n\t\treturn value[0];\n\t}\n}\n","import { PowerOfTwo } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase, MeterBaseOptions } from \"./MeterBase\";\n\nexport interface WaveformOptions extends MeterBaseOptions {\n\t/**\n\t * The size of the Waveform. Value must be a power of two in the range 16 to 16384.\n\t */\n\tsize: PowerOfTwo;\n}\n\n/**\n * Get the current waveform data of the connected audio source.\n * @category Component\n */\nexport class Waveform extends MeterBase<WaveformOptions> {\n\n\treadonly name: string = \"Waveform\";\n\n\t/**\n\t * @param size The size of the Waveform. Value must be a power of two in the range 16 to 16384.\n\t */\n\tconstructor(size?: PowerOfTwo);\n\tconstructor(options?: Partial<WaveformOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Waveform.getDefaults(), arguments, [\"size\"]));\n\t\tconst options = optionsFromArguments(Waveform.getDefaults(), arguments, [\"size\"]);\n\n\t\tthis._analyser.type = \"waveform\";\n\t\tthis.size = options.size;\n\t}\n\n\tstatic getDefaults(): WaveformOptions {\n\t\treturn Object.assign(MeterBase.getDefaults(), {\n\t\t\tsize: 1024,\n\t\t});\n\t}\n\n\t/**\n\t * Return the waveform for the current time as a Float32Array where each value in the array\n\t * represents a sample in the waveform.\n\t */\n\tgetValue(): Float32Array {\n\t\treturn this._analyser.getValue() as Float32Array;\n\t}\n\n\t/**\n\t * The size of analysis. This must be a power of two in the range 16 to 16384.\n\t * Determines the size of the array returned by [[getValue]].\n\t */\n\tget size(): PowerOfTwo {\n\t\treturn this._analyser.size;\n\t}\n\tset size(size) {\n\t\tthis._analyser.size = size;\n\t}\n}\n","import { BaseContext } from \"../../core/context/BaseContext\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\nexport interface SoloOptions extends ToneAudioNodeOptions {\n\tsolo: boolean;\n}\n\n/**\n * Solo lets you isolate a specific audio stream. When an instance is set to `solo=true`,\n * it will mute all other instances of Solo.\n * @example\n * const soloA = new Tone.Solo().toDestination();\n * const oscA = new Tone.Oscillator(\"C4\", \"sawtooth\").connect(soloA);\n * const soloB = new Tone.Solo().toDestination();\n * const oscB = new Tone.Oscillator(\"E4\", \"square\").connect(soloB);\n * soloA.solo = true;\n * // no audio will pass through soloB\n * @category Component\n */\nexport class Solo extends ToneAudioNode<SoloOptions> {\n\n\treadonly name: string = \"Solo\";\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\t/**\n\t * @param solo If the connection should be initially solo'ed.\n\t */\n\tconstructor(solo?: boolean);\n\tconstructor(options?: Partial<SoloOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Solo.getDefaults(), arguments, [\"solo\"]));\n\t\tconst options = optionsFromArguments(Solo.getDefaults(), arguments, [\"solo\"]);\n\n\t\tthis.input = this.output = new Gain({\n\t\t\tcontext: this.context,\n\t\t});\n\n\t\tif (!Solo._allSolos.has(this.context)) {\n\t\t\tSolo._allSolos.set(this.context, new Set());\n\t\t}\n\t\t(Solo._allSolos.get(this.context) as Set<Solo>).add(this);\n\n\t\t// set initially\n\t\tthis.solo = options.solo;\n\t}\n\n\tstatic getDefaults(): SoloOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsolo: false,\n\t\t});\n\t}\n\n\t/**\n\t * Hold all of the solo'ed tracks belonging to a specific context\n\t */\n\tprivate static _allSolos: Map<BaseContext, Set<Solo>> = new Map();\n\n\t/**\n\t * Hold the currently solo'ed instance(s)\n\t */\n\tprivate static _soloed: Map<BaseContext, Set<Solo>> = new Map();\n\n\t/**\n\t * Isolates this instance and mutes all other instances of Solo.\n\t * Only one instance can be soloed at a time. A soloed\n\t * instance will report `solo=false` when another instance is soloed.\n\t */\n\tget solo(): boolean {\n\t\treturn this._isSoloed();\n\t}\n\tset solo(solo) {\n\t\tif (solo) {\n\t\t\tthis._addSolo();\n\t\t} else {\n\t\t\tthis._removeSolo();\n\t\t}\n\t\t(Solo._allSolos.get(this.context) as Set<Solo>).forEach(instance => instance._updateSolo());\n\t}\n\n\t/**\n\t * If the current instance is muted, i.e. another instance is soloed\n\t */\n\tget muted(): boolean {\n\t\treturn this.input.gain.value === 0;\n\t}\n\n\t/**\n\t * Add this to the soloed array\n\t */\n\tprivate _addSolo(): void {\n\t\tif (!Solo._soloed.has(this.context)) {\n\t\t\tSolo._soloed.set(this.context, new Set());\n\t\t}\n\t\t(Solo._soloed.get(this.context) as Set<Solo>).add(this);\n\t}\n\n\t/**\n\t * Remove this from the soloed array\n\t */\n\tprivate _removeSolo(): void {\n\t\tif (Solo._soloed.has(this.context)) {\n\t\t\t(Solo._soloed.get(this.context) as Set<Solo>).delete(this);\n\t\t}\n\t}\n\n\t/**\n\t * Is this on the soloed array\n\t */\n\tprivate _isSoloed(): boolean {\n\t\treturn Solo._soloed.has(this.context) && (Solo._soloed.get(this.context) as Set<Solo>).has(this);\n\t}\n\n\t/**\n\t * Returns true if no one is soloed\n\t */\n\tprivate _noSolos(): boolean {\n\t\t// either does not have any soloed added\n\t\treturn !Solo._soloed.has(this.context) ||\n\t\t\t// or has a solo set but doesn't include any items\n\t\t\t(Solo._soloed.has(this.context) && (Solo._soloed.get(this.context) as Set<Solo>).size === 0);\n\t}\n\n\t/**\n\t * Solo the current instance and unsolo all other instances.\n\t */\n\tprivate _updateSolo(): void {\n\t\tif (this._isSoloed()) {\n\t\t\tthis.input.gain.value = 1;\n\t\t} else if (this._noSolos()) {\n\t\t\t// no one is soloed\n\t\t\tthis.input.gain.value = 1;\n\t\t} else {\n\t\t\tthis.input.gain.value = 0;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\t(Solo._allSolos.get(this.context) as Set<Solo>).delete(this);\n\t\tthis._removeSolo();\n\t\treturn this;\n\t}\n}\n","import { readOnly } from \"../../core/util/Interface\";\nimport { Param } from \"../../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { AudioRange, Decibels } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Panner } from \"./Panner\";\nimport { Volume } from \"./Volume\";\n\nexport interface PanVolOptions extends ToneAudioNodeOptions {\n\tpan: AudioRange;\n\tvolume: Decibels;\n\tmute: boolean;\n\tchannelCount: number;\n}\n\n/**\n * PanVol is a Tone.Panner and Tone.Volume in one.\n * @example\n * // pan the incoming signal left and drop the volume\n * const panVol = new Tone.PanVol(-0.25, -12).toDestination();\n * const osc = new Tone.Oscillator().connect(panVol).start();\n * @category Component\n */\nexport class PanVol extends ToneAudioNode<PanVolOptions> {\n\n\treadonly name: string = \"PanVol\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The panning node\n\t */\n\tprivate _panner: Panner;\n\n\t/**\n\t * The L/R panning control.\n\t */\n\treadonly pan: Param<\"audioRange\">;\n\n\t/**\n\t * The volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The volume control in decibels.\n\t */\n\treadonly volume: Param<\"decibels\">;\n\n\t/**\n\t * @param pan the initial pan\n\t * @param volume The output volume.\n\t */\n\tconstructor(pan?: AudioRange, volume?: Decibels);\n\tconstructor(options?: Partial<PanVolOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PanVol.getDefaults(), arguments, [\"pan\", \"volume\"]));\n\t\tconst options = optionsFromArguments(PanVol.getDefaults(), arguments, [\"pan\", \"volume\"]);\n\n\t\tthis._panner = this.input = new Panner({\n\t\t\tcontext: this.context,\n\t\t\tpan: options.pan,\n\t\t\tchannelCount: options.channelCount,\n\t\t});\n\t\tthis.pan = this._panner.pan;\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\n\t\t// connections\n\t\tthis._panner.connect(this._volume);\n\t\tthis.mute = options.mute;\n\n\t\treadOnly(this, [\"pan\", \"volume\"]);\n\t}\n\n\tstatic getDefaults(): PanVolOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tpan: 0,\n\t\t\tvolume: 0,\n\t\t\tchannelCount: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Mute/unmute the volume\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._panner.dispose();\n\t\tthis.pan.dispose();\n\t\tthis._volume.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n","import { AudioRange, Decibels } from \"../../core/type/Units\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Solo } from \"./Solo\";\nimport { PanVol } from \"./PanVol\";\nimport { Param } from \"../../core/context/Param\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Gain } from \"../../core/context/Gain\";\n\nexport interface ChannelOptions extends ToneAudioNodeOptions {\n\tpan: AudioRange;\n\tvolume: Decibels;\n\tsolo: boolean;\n\tmute: boolean;\n\tchannelCount: number;\n}\n\n/**\n * Channel provides a channel strip interface with volume, pan, solo and mute controls. \n * See [[PanVol]] and [[Solo]]\n * @example\n * // pan the incoming signal left and drop the volume 12db\n * const channel = new Tone.Channel(-0.25, -12);\n * @category Component\n */\nexport class Channel extends ToneAudioNode<ChannelOptions> {\n\n\treadonly name: string = \"Channel\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The soloing interface\n\t */\n\tprivate _solo: Solo;\n\n\t/**\n\t * The panning and volume node\n\t */\n\tprivate _panVol: PanVol;\n\n\t/**\n\t * The L/R panning control.\n\t */\n\treadonly pan: Param<\"audioRange\">;\n\n\t/**\n\t * The volume control in decibels.\n\t */\n\treadonly volume: Param<\"decibels\">;\n\n\t/**\n\t * @param volume The output volume.\n\t * @param pan the initial pan\n\t */\n\tconstructor(volume?: Decibels, pan?: AudioRange);\n\tconstructor(options?: Partial<ChannelOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Channel.getDefaults(), arguments, [\"volume\", \"pan\"]));\n\t\tconst options = optionsFromArguments(Channel.getDefaults(), arguments, [\"volume\", \"pan\"]);\n\n\t\tthis._solo = this.input = new Solo({\n\t\t\tsolo: options.solo,\n\t\t\tcontext: this.context,\n\t\t});\n\t\tthis._panVol = this.output = new PanVol({\n\t\t\tcontext: this.context,\n\t\t\tpan: options.pan,\n\t\t\tvolume: options.volume,\n\t\t\tmute: options.mute,\n\t\t\tchannelCount: options.channelCount\n\t\t});\n\t\tthis.pan = this._panVol.pan;\n\t\tthis.volume = this._panVol.volume;\n\n\t\tthis._solo.connect(this._panVol);\n\t\treadOnly(this, [\"pan\", \"volume\"]);\n\t}\n\n\tstatic getDefaults(): ChannelOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tpan: 0,\n\t\t\tvolume: 0,\n\t\t\tmute: false,\n\t\t\tsolo: false,\n\t\t\tchannelCount: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Solo/unsolo the channel. Soloing is only relative to other [[Channels]] and [[Solo]] instances\n\t */\n\tget solo(): boolean {\n\t\treturn this._solo.solo;\n\t}\n\tset solo(solo) {\n\t\tthis._solo.solo = solo;\n\t}\n\n\t/**\n\t * If the current instance is muted, i.e. another instance is soloed,\n\t * or the channel is muted\n\t */\n\tget muted(): boolean {\n\t\treturn this._solo.muted || this.mute;\n\t}\n\n\t/**\n\t * Mute/unmute the volume\n\t */\n\tget mute(): boolean {\n\t\treturn this._panVol.mute;\n\t}\n\tset mute(mute) {\n\t\tthis._panVol.mute = mute;\n\t}\n\n\t/**\n\t * Store the send/receive channels by name. \n\t */\n\tprivate static buses: Map<string, Gain> = new Map();\n\n\t/**\n\t * Get the gain node belonging to the bus name. Create it if\n\t * it doesn't exist\n\t * @param name The bus name\n\t */\n\tprivate _getBus(name: string): Gain {\n\t\tif (!Channel.buses.has(name)) {\n\t\t\tChannel.buses.set(name, new Gain({ context: this.context }));\n\t\t}\n\t\treturn Channel.buses.get(name) as Gain;\n\t}\n\n\t/**\n\t * Send audio to another channel using a string. `send` is a lot like\n\t * [[connect]], except it uses a string instead of an object. This can \n\t * be useful in large applications to decouple sections since [[send]]\n\t * and [[receive]] can be invoked separately in order to connect an object\n\t * @param name The channel name to send the audio\n\t * @param volume The amount of the signal to send. \n\t * \tDefaults to 0db, i.e. send the entire signal\n\t * @returns Returns the gain node of this connection.\n\t */\n\tsend(name: string, volume: Decibels = 0): Gain<\"decibels\"> {\n\t\tconst bus = this._getBus(name);\n\t\tconst sendKnob = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"decibels\",\n\t\t\tgain: volume,\n\t\t});\n\t\tthis.connect(sendKnob);\n\t\tsendKnob.connect(bus);\n\t\treturn sendKnob;\n\t}\n\n\t/**\n\t * Receive audio from a channel which was connected with [[send]]. \n\t * @param name The channel name to receive audio from.\n\t */\n\treceive(name: string): this {\n\t\tconst bus = this._getBus(name);\n\t\tbus.connect(this);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._panVol.dispose();\n\t\tthis.pan.dispose();\n\t\tthis.volume.dispose();\n\t\tthis._solo.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Frequency, Positive } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Filter } from \"../filter/Filter\";\n\ninterface MultibandSplitOptions extends ToneAudioNodeOptions {\n\tQ: Positive;\n\tlowFrequency: Frequency;\n\thighFrequency: Frequency;\n}\n\n/**\n * Split the incoming signal into three bands (low, mid, high)\n * with two crossover frequency controls.\n * ```\n *            +----------------------+\n *          +-> input < lowFrequency +------------------> low\n *          | +----------------------+\n *          |\n *          | +--------------------------------------+\n * input ---+-> lowFrequency < input < highFrequency +--> mid\n *          | +--------------------------------------+\n *          |\n *          | +-----------------------+\n *          +-> highFrequency < input +-----------------> high\n *            +-----------------------+\n * ```\n * @category Component\n */\nexport class MultibandSplit extends ToneAudioNode<MultibandSplitOptions> {\n\n\treadonly name: string = \"MultibandSplit\";\n\n\t/**\n\t * the input\n\t */\n\treadonly input = new Gain({ context: this.context });\n\n\t/**\n\t * no output node, use either low, mid or high outputs\n\t */\n\treadonly output = undefined;\n\n\t/**\n\t * The low band.\n\t */\n\treadonly low = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"lowpass\",\n\t});\n\n\t/**\n\t * the lower filter of the mid band\n\t */\n\tprivate _lowMidFilter = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"highpass\",\n\t});\n\n\t/**\n\t * The mid band output.\n\t */\n\treadonly mid = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"lowpass\",\n\t});\n\n\t/**\n\t * The high band output.\n\t */\n\treadonly high = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"highpass\",\n\t});\n\n\t/**\n\t * The low/mid crossover frequency.\n\t */\n\treadonly lowFrequency: Signal<\"frequency\">;\n\n\t/**\n\t * The mid/high crossover frequency.\n\t */\n\treadonly highFrequency: Signal<\"frequency\">;\n\n\tprotected _internalChannels = [this.low, this.mid, this.high];\n\n\t/**\n\t * The Q or Quality of the filter\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * @param lowFrequency the low/mid crossover frequency\n\t * @param highFrequency the mid/high crossover frequency\n\t */\n\tconstructor(lowFrequency?: Frequency, highFrequency?: Frequency);\n\tconstructor(options?: Partial<MultibandSplitOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MultibandSplit.getDefaults(), arguments, [\"lowFrequency\", \"highFrequency\"]));\n\t\tconst options = optionsFromArguments(MultibandSplit.getDefaults(), arguments, [\"lowFrequency\", \"highFrequency\"]);\n\n\t\tthis.lowFrequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.lowFrequency,\n\t\t});\n\n\t\tthis.highFrequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.highFrequency,\n\t\t});\n\n\t\tthis.Q = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.Q,\n\t\t});\n\n\t\tthis.input.fan(this.low, this.high);\n\t\tthis.input.chain(this._lowMidFilter, this.mid);\n\t\t// the frequency control signal\n\t\tthis.lowFrequency.fan(this.low.frequency, this._lowMidFilter.frequency);\n\t\tthis.highFrequency.fan(this.mid.frequency, this.high.frequency);\n\t\t// the Q value\n\t\tthis.Q.connect(this.low.Q);\n\t\tthis.Q.connect(this._lowMidFilter.Q);\n\t\tthis.Q.connect(this.mid.Q);\n\t\tthis.Q.connect(this.high.Q);\n\n\t\treadOnly(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n\t}\n\n\tstatic getDefaults(): MultibandSplitOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tQ: 1,\n\t\t\thighFrequency: 2500,\n\t\t\tlowFrequency: 400,\n\t\t});\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\twritable(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n\t\tthis.low.dispose();\n\t\tthis._lowMidFilter.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.high.dispose();\n\t\tthis.lowFrequency.dispose();\n\t\tthis.highFrequency.dispose();\n\t\tthis.Q.dispose();\n\t\treturn this;\n\t}\n\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\nimport { Param } from \"./Param\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization\";\n\nexport interface ListenerOptions extends ToneAudioNodeOptions{\n\tpositionX: number;\n\tpositionY: number;\n\tpositionZ: number;\n\tforwardX: number;\n\tforwardY: number;\n\tforwardZ: number;\n\tupX: number;\n\tupY: number;\n\tupZ: number;\n}\n\n/**\n * Tone.Listener is a thin wrapper around the AudioListener. Listener combined\n * with [[Panner3D]] makes up the Web Audio API's 3D panning system. Panner3D allows you \n * to place sounds in 3D and Listener allows you to navigate the 3D sound environment from\n * a first-person perspective. There is only one listener per audio context. \n */\nexport class Listener extends ToneAudioNode<ListenerOptions> {\n\n\treadonly name: string = \"Listener\";\n\n\t/**\n\t * The listener has no inputs or outputs. \n\t */\n\toutput: undefined; \n\tinput: undefined; \n\n\treadonly positionX: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.positionX,\n\t})\n\n\treadonly positionY: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.positionY,\n\t})\n\n\treadonly positionZ: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.positionZ,\n\t})\n\n\treadonly forwardX: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.forwardX,\n\t})\n\n\treadonly forwardY: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.forwardY,\n\t})\n\n\treadonly forwardZ: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.forwardZ,\n\t})\n\n\treadonly upX: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.upX,\n\t})\n\n\treadonly upY: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.upY,\n\t})\n\n\treadonly upZ: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.upZ,\n\t})\n\n\tstatic getDefaults(): ListenerOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tpositionX: 0,\n\t\t\tpositionY: 0,\n\t\t\tpositionZ: 0,\n\t\t\tforwardX: 0,\n\t\t\tforwardY: 0,\n\t\t\tforwardZ: -1,\n\t\t\tupX: 0,\n\t\t\tupY: 1,\n\t\t\tupZ: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.positionX.dispose();\n\t\tthis.positionY.dispose();\n\t\tthis.positionZ.dispose();\n\t\tthis.forwardX.dispose();\n\t\tthis.forwardY.dispose();\n\t\tthis.forwardZ.dispose();\n\t\tthis.upX.dispose();\n\t\tthis.upY.dispose();\n\t\tthis.upZ.dispose();\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n\tcontext.listener = new Listener({ context });\n});\n\nonContextClose(context => {\n\tcontext.listener.dispose();\n});\n","import { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Degrees, GainFactor } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport \"../../core/context/Listener\";\n\nexport interface Panner3DOptions extends ToneAudioNodeOptions {\n\tconeInnerAngle: Degrees;\n\tconeOuterAngle: Degrees;\n\tconeOuterGain: GainFactor;\n\tdistanceModel: DistanceModelType;\n\tmaxDistance: number;\n\torientationX: number;\n\torientationY: number;\n\torientationZ: number;\n\tpanningModel: PanningModelType;\n\tpositionX: number;\n\tpositionY: number;\n\tpositionZ: number;\n\trefDistance: number;\n\trolloffFactor: number;\n}\n\n/**\n * A spatialized panner node which supports equalpower or HRTF panning.\n * @category Component\n */\nexport class Panner3D extends ToneAudioNode<Panner3DOptions> {\n\n\treadonly name: string = \"Panner3D\";\n\n\t/**\n\t * The panning object\n\t */\n\tprivate _panner: PannerNode;\n\treadonly input: PannerNode;\n\treadonly output: PannerNode;\n\n\treadonly positionX: Param<\"number\">;\n\treadonly positionY: Param<\"number\">;\n\treadonly positionZ: Param<\"number\">;\n\n\treadonly orientationX: Param<\"number\">;\n\treadonly orientationY: Param<\"number\">;\n\treadonly orientationZ: Param<\"number\">;\n\n\t/**\n\t * @param positionX The initial x position.\n\t * @param positionY The initial y position.\n\t * @param positionZ The initial z position.\n\t */\n\tconstructor(positionX: number, positionY: number, positionZ: number);\n\tconstructor(options?: Partial<Panner3DOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Panner3D.getDefaults(), arguments, [\"positionX\", \"positionY\", \"positionZ\"]));\n\t\tconst options = optionsFromArguments(Panner3D.getDefaults(), arguments, [\"positionX\", \"positionY\", \"positionZ\"]);\n\n\t\tthis._panner = this.input = this.output = this.context.createPanner();\n\t\t// set some values\n\t\tthis.panningModel = options.panningModel;\n\t\tthis.maxDistance = options.maxDistance;\n\t\tthis.distanceModel = options.distanceModel;\n\t\tthis.coneOuterGain = options.coneOuterGain;\n\t\tthis.coneOuterAngle = options.coneOuterAngle;\n\t\tthis.coneInnerAngle = options.coneInnerAngle;\n\t\tthis.refDistance = options.refDistance;\n\t\tthis.rolloffFactor = options.rolloffFactor;\n\n\t\tthis.positionX = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.positionX,\n\t\t\tvalue: options.positionX,\n\t\t});\n\t\tthis.positionY = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.positionY,\n\t\t\tvalue: options.positionY,\n\t\t});\n\t\tthis.positionZ = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.positionZ,\n\t\t\tvalue: options.positionZ,\n\t\t});\n\t\tthis.orientationX = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.orientationX,\n\t\t\tvalue: options.orientationX,\n\t\t});\n\t\tthis.orientationY = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.orientationY,\n\t\t\tvalue: options.orientationY,\n\t\t});\n\t\tthis.orientationZ = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.orientationZ,\n\t\t\tvalue: options.orientationZ,\n\t\t});\n\t}\n\n\tstatic getDefaults(): Panner3DOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tconeInnerAngle: 360,\n\t\t\tconeOuterAngle: 360,\n\t\t\tconeOuterGain: 0,\n\t\t\tdistanceModel: \"inverse\" as DistanceModelType,\n\t\t\tmaxDistance: 10000,\n\t\t\torientationX: 0,\n\t\t\torientationY: 0,\n\t\t\torientationZ: 0,\n\t\t\tpanningModel: \"equalpower\" as PanningModelType,\n\t\t\tpositionX: 0,\n\t\t\tpositionY: 0,\n\t\t\tpositionZ: 0,\n\t\t\trefDistance: 1,\n\t\t\trolloffFactor: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Sets the position of the source in 3d space.\n\t */\n\tsetPosition(x: number, y: number, z: number): this {\n\t\tthis.positionX.value = x;\n\t\tthis.positionY.value = y;\n\t\tthis.positionZ.value = z;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the orientation of the source in 3d space.\n\t */\n\tsetOrientation(x: number, y: number, z: number): this {\n\t\tthis.orientationX.value = x;\n\t\tthis.orientationY.value = y;\n\t\tthis.orientationZ.value = z;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The panning model. Either \"equalpower\" or \"HRTF\".\n\t */\n\tget panningModel(): PanningModelType {\n\t\treturn this._panner.panningModel;\n\t}\n\tset panningModel(val) {\n\t\tthis._panner.panningModel = val;\n\t}\n\n\t/**\n\t * A reference distance for reducing volume as source move further from the listener\n\t */\n\tget refDistance(): number {\n\t\treturn this._panner.refDistance;\n\t}\n\tset refDistance(val) {\n\t\tthis._panner.refDistance = val;\n\t}\n\n\t/**\n\t * Describes how quickly the volume is reduced as source moves away from listener.\n\t */\n\tget rolloffFactor(): number {\n\t\treturn this._panner.rolloffFactor;\n\t}\n\tset rolloffFactor(val) {\n\t\tthis._panner.rolloffFactor = val;\n\t}\n\n\t/**\n\t * The distance model used by,  \"linear\", \"inverse\", or \"exponential\".\n\t */\n\tget distanceModel(): DistanceModelType {\n\t\treturn this._panner.distanceModel;\n\t}\n\tset distanceModel(val) {\n\t\tthis._panner.distanceModel = val;\n\t}\n\n\t/**\n\t * The angle, in degrees, inside of which there will be no volume reduction\n\t */\n\tget coneInnerAngle(): Degrees {\n\t\treturn this._panner.coneInnerAngle;\n\t}\n\tset coneInnerAngle(val) {\n\t\tthis._panner.coneInnerAngle = val;\n\t}\n\n\t/**\n\t * The angle, in degrees, outside of which the volume will be reduced\n\t * to a constant value of coneOuterGain\n\t */\n\tget coneOuterAngle(): Degrees {\n\t\treturn this._panner.coneOuterAngle;\n\t}\n\tset coneOuterAngle(val) {\n\t\tthis._panner.coneOuterAngle = val;\n\t}\n\n\t/**\n\t * The gain outside of the coneOuterAngle\n\t */\n\tget coneOuterGain(): GainFactor {\n\t\treturn this._panner.coneOuterGain;\n\t}\n\tset coneOuterGain(val) {\n\t\tthis._panner.coneOuterGain = val;\n\t}\n\n\t/**\n\t * The maximum distance between source and listener,\n\t * after which the volume will not be reduced any further.\n\t */\n\tget maxDistance(): number {\n\t\treturn this._panner.maxDistance;\n\t}\n\tset maxDistance(val) {\n\t\tthis._panner.maxDistance = val;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._panner.disconnect();\n\t\tthis.orientationX.dispose();\n\t\tthis.orientationY.dispose();\n\t\tthis.orientationZ.dispose();\n\t\tthis.positionX.dispose();\n\t\tthis.positionY.dispose();\n\t\tthis.positionZ.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { assert } from \"../../core/util/Debug\";\nimport { theWindow } from \"../../core/context/AudioContext\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { PlaybackState } from \"../../core/util/StateTimeline\";\n\nexport interface RecorderOptions extends ToneAudioNodeOptions {\n\tmimeType?: string;\n}\n\n/**\n * A wrapper around the MediaRecorder API. Unlike the rest of Tone.js, this module does not offer\n * any sample-accurate scheduling because it is not a feature of the MediaRecorder API.\n * This is only natively supported in Chrome and Firefox. \n * For a cross-browser shim, install (audio-recorder-polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill]. \n * @example\n * const recorder = new Tone.Recorder();\n * const synth = new Tone.Synth().connect(recorder);\n * // start recording\n * recorder.start();\n * // generate a few notes\n * synth.triggerAttackRelease(\"C3\", 0.5);\n * synth.triggerAttackRelease(\"C4\", 0.5, \"+1\");\n * synth.triggerAttackRelease(\"C5\", 0.5, \"+2\");\n * // wait for the notes to end and stop the recording\n * setTimeout(async () => {\n * \t// the recorded audio is returned as a blob\n * \tconst recording = await recorder.stop();\n * \t// download the recording by creating an anchor element and blob url\n * \tconst url = URL.createObjectURL(recording);\n * \tconst anchor = document.createElement(\"a\");\n * \tanchor.download = \"recording.webm\";\n * \tanchor.href = url;\n * \tanchor.click();\n * }, 4000);\n */\nexport class Recorder extends ToneAudioNode<RecorderOptions> {\n\n\treadonly name = \"Recorder\";\n\n\t/**\n\t * Recorder uses the Media Recorder API\n\t */\n\tprivate _recorder: MediaRecorder;\n\n\t/**\n\t * MediaRecorder requires \n\t */\n\tprivate _stream: MediaStreamAudioDestinationNode;\n\n\treadonly input: Gain;\n\treadonly output: undefined;\n\n\tconstructor(options?: Partial<RecorderOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Recorder.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Recorder.getDefaults(), arguments);\n\n\t\tthis.input = new Gain({\n\t\t\tcontext: this.context\n\t\t});\n\n\t\tassert(Recorder.supported, \"Media Recorder API is not available\");\n\n\t\tthis._stream = this.context.createMediaStreamDestination();\n\t\tthis.input.connect(this._stream);\n\t\tthis._recorder = new MediaRecorder(this._stream.stream, {\n\t\t\tmimeType: options.mimeType\n\t\t});\n\t}\n\n\tstatic getDefaults(): RecorderOptions {\n\t\treturn ToneAudioNode.getDefaults();\n\t}\n\n\t/**\n\t * The mime type is the format that the audio is encoded in. For Chrome \n\t * that is typically webm encoded as \"vorbis\". \n\t */\n\tget mimeType(): string {\n\t\treturn this._recorder.mimeType;\n\t}\n\n\t/**\n\t * Test if your platform supports the Media Recorder API. If it's not available, \n\t * try installing this (polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill].\n\t */\n\tstatic get supported(): boolean {\n\t\treturn theWindow !== null && Reflect.has(theWindow, \"MediaRecorder\");\n\t}\n\n\t/**\n\t * Get the playback state of the Recorder, either \"started\", \"stopped\" or \"paused\"\n\t */\n\tget state(): PlaybackState {\n\t\tif (this._recorder.state === \"inactive\") {\n\t\t\treturn \"stopped\";\n\t\t} else if (this._recorder.state === \"paused\") {\n\t\t\treturn \"paused\";\n\t\t} else {\n\t\t\treturn \"started\";\n\t\t}\n\t}\n\n\t/**\n\t * Start the Recorder. Returns a promise which resolves\n\t * when the recorder has started.\n\t */\n\tasync start() {\n\t\tassert(this.state !== \"started\", \"Recorder is already started\");\n\t\tconst startPromise = new Promise(done => {\n\t\t\tconst handleStart = () => {\n\t\t\t\tthis._recorder.removeEventListener(\"start\", handleStart, false);\n\n\t\t\t\tdone();\n\t\t\t};\n\n\t\t\tthis._recorder.addEventListener(\"start\", handleStart, false);\n\t\t});\n\n\t\tthis._recorder.start();\n\t\treturn await startPromise;\n\t}\n\n\t/**\n\t * Stop the recorder. Returns a promise with the recorded content until this point\n\t * encoded as [[mimeType]]\n\t */\n\tasync stop(): Promise<Blob> {\n\t\tassert(this.state !== \"stopped\", \"Recorder is not started\");\n\t\tconst dataPromise: Promise<Blob> = new Promise(done => {\n\t\t\tconst handleData = (e: BlobEvent) => {\n\t\t\t\tthis._recorder.removeEventListener(\"dataavailable\", handleData, false);\n\n\t\t\t\tdone(e.data);\n\t\t\t};\n\n\t\t\tthis._recorder.addEventListener(\"dataavailable\", handleData, false);\n\t\t});\n\t\tthis._recorder.stop();\n\t\treturn await dataPromise;\n\t}\n\n\t/**\n\t * Pause the recorder\n\t */\n\tpause(): this {\n\t\tassert(this.state === \"started\", \"Recorder must be started\");\n\t\tthis._recorder.pause();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis._stream.disconnect();\n\t\treturn this;\n\t}\n}\n","import { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Decibels, Positive, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n\nexport interface CompressorOptions extends ToneAudioNodeOptions {\n\tattack: Time;\n\tknee: Decibels;\n\tratio: Positive;\n\trelease: Time;\n\tthreshold: Decibels;\n}\n\n/**\n * Compressor is a thin wrapper around the Web Audio\n * [DynamicsCompressorNode](http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface).\n * Compression reduces the volume of loud sounds or amplifies quiet sounds\n * by narrowing or \"compressing\" an audio signal's dynamic range.\n * Read more on [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_range_compression).\n * @example\n * const comp = new Tone.Compressor(-30, 3);\n * @category Component\n */\nexport class Compressor extends ToneAudioNode<CompressorOptions> {\n\n\treadonly name: string = \"Compressor\";\n\n\t/**\n\t * the compressor node\n\t */\n\tprivate _compressor: DynamicsCompressorNode = this.context.createDynamicsCompressor();\n\treadonly input = this._compressor;\n\treadonly output = this._compressor;\n\n\t/**\n\t * The decibel value above which the compression will start taking effect.\n\t * @min -100\n\t * @max 0\n\t */\n\treadonly threshold: Param<\"decibels\">;\n\n\t/**\n\t * The amount of time (in seconds) to reduce the gain by 10dB.\n\t * @min 0\n\t * @max 1\n\t */\n\treadonly attack: Param<\"time\">;\n\n\t/**\n\t * The amount of time (in seconds) to increase the gain by 10dB.\n\t * @min 0\n\t * @max 1\n\t */\n\treadonly release: Param<\"time\">;\n\n\t/**\n\t * A decibel value representing the range above the threshold where the\n\t * curve smoothly transitions to the \"ratio\" portion.\n\t * @min 0\n\t * @max 40\n\t */\n\treadonly knee: Param<\"decibels\">;\n\n\t/**\n\t * The amount of dB change in input for a 1 dB change in output.\n\t * @min 1\n\t * @max 20\n\t */\n\treadonly ratio: Param<\"positive\">;\n\n\t/**\n\t * @param threshold The value above which the compression starts to be applied.\n\t * @param ratio The gain reduction ratio.\n\t */\n\tconstructor(threshold?: Decibels, ratio?: Positive);\n\tconstructor(options?: Partial<CompressorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Compressor.getDefaults(), arguments, [\"threshold\", \"ratio\"]));\n\t\tconst options = optionsFromArguments(Compressor.getDefaults(), arguments, [\"threshold\", \"ratio\"]);\n\n\t\tthis.threshold = new Param({\n\t\t\tminValue: this._compressor.threshold.minValue,\n\t\t\tmaxValue: this._compressor.threshold.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tconvert: false,\n\t\t\tparam: this._compressor.threshold,\n\t\t\tunits: \"decibels\",\n\t\t\tvalue: options.threshold,\n\t\t});\n\n\t\tthis.attack = new Param({\n\t\t\tminValue: this._compressor.attack.minValue,\n\t\t\tmaxValue: this._compressor.attack.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tparam: this._compressor.attack,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.attack,\n\t\t});\n\n\t\tthis.release = new Param({\n\t\t\tminValue: this._compressor.release.minValue,\n\t\t\tmaxValue: this._compressor.release.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tparam: this._compressor.release,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.release,\n\t\t});\n\n\t\tthis.knee = new Param({\n\t\t\tminValue: this._compressor.knee.minValue,\n\t\t\tmaxValue: this._compressor.knee.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tconvert: false,\n\t\t\tparam: this._compressor.knee,\n\t\t\tunits: \"decibels\",\n\t\t\tvalue: options.knee,\n\t\t});\n\n\t\tthis.ratio = new Param({\n\t\t\tminValue: this._compressor.ratio.minValue,\n\t\t\tmaxValue: this._compressor.ratio.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tconvert: false,\n\t\t\tparam: this._compressor.ratio,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.ratio,\n\t\t});\n\n\t\t// set the defaults\n\t\treadOnly(this, [\"knee\", \"release\", \"attack\", \"ratio\", \"threshold\"]);\n\t}\n\n\tstatic getDefaults(): CompressorOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tattack: 0.003,\n\t\t\tknee: 30,\n\t\t\tratio: 12,\n\t\t\trelease: 0.25,\n\t\t\tthreshold: -24,\n\t\t});\n\t}\n\n\t/**\n\t * A read-only decibel value for metering purposes, representing the current amount of gain\n\t * reduction that the compressor is applying to the signal. If fed no signal the value will be 0 (no gain reduction).\n\t */\n\tget reduction(): Decibels {\n\t\treturn this._compressor.reduction;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._compressor.disconnect();\n\t\tthis.attack.dispose();\n\t\tthis.release.dispose();\n\t\tthis.threshold.dispose();\n\t\tthis.ratio.dispose();\n\t\tthis.knee.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Decibels, Time } from \"../../core/type/Units\";\nimport { GreaterThan } from \"../../signal/GreaterThan\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { Follower } from \"../analysis/Follower\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { dbToGain, gainToDb } from \"../../core/type/Conversions\";\n\nexport interface GateOptions extends ToneAudioNodeOptions {\n\tthreshold: Decibels;\n\tsmoothing: Time;\n}\n\n/**\n * Gate only passes a signal through when the incoming\n * signal exceeds a specified threshold. It uses [[Follower]] to follow the ampltiude\n * of the incoming signal and compares it to the [[threshold]] value using [[GreaterThan]].\n *\n * @example\n * const gate = new Tone.Gate(-30, 0.2).toDestination();\n * const mic = new Tone.UserMedia().connect(gate);\n * // the gate will only pass through the incoming\n * // signal when it's louder than -30db\n */\nexport class Gate extends ToneAudioNode<GateOptions> {\n\n\treadonly name: string = \"Gate\";\n\n\treadonly input: ToneAudioNode;\n\treadonly output: ToneAudioNode;\n\n\t/**\n\t * Follow the incoming signal\n\t */\n\tprivate _follower: Follower;\n\n\t/**\n\t * Test if it's greater than the threshold\n\t */\n\tprivate _gt: GreaterThan;\n\n\t/**\n\t * Gate the incoming signal when it does not exceed the threshold\n\t */\n\tprivate _gate: Gain;\n\n\t/**\n\t * @param threshold The threshold above which the gate will open.\n\t * @param smoothing The follower's smoothing time\n\t */\n\tconstructor(threshold?: Decibels, smoothing?: Time);\n\tconstructor(options?: Partial<GateOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Gate.getDefaults(), arguments, [\"threshold\", \"smoothing\"])));\n\t\tconst options = optionsFromArguments(Gate.getDefaults(), arguments, [\"threshold\", \"smoothing\"]);\n\n\t\tthis._follower = new Follower({\n\t\t\tcontext: this.context,\n\t\t\tsmoothing: options.smoothing,\n\t\t});\n\t\tthis._gt = new GreaterThan({\n\t\t\tcontext: this.context,\n\t\t\tvalue: dbToGain(options.threshold),\n\t\t});\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis._gate = this.output = new Gain({ context: this.context });\n\n\t\t// connections\n\t\tthis.input.connect(this._gate);\n\t\t// the control signal\n\t\tthis.input.chain(this._follower, this._gt, this._gate.gain);\n\t}\n\n\tstatic getDefaults(): GateOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsmoothing: 0.1,\n\t\t\tthreshold: -40\n\t\t});\n\t}\n\n\t/**\n\t * The threshold of the gate in decibels\n\t */\n\tget threshold(): Decibels {\n\t\treturn gainToDb(this._gt.value);\n\t}\n\tset threshold(thresh) {\n\t\tthis._gt.value = dbToGain(thresh);\n\t}\n\n\t/**\n\t * The attack/decay speed of the gate. See [[Follower.smoothing]]\n\t */\n\tget smoothing(): Time {\n\t\treturn this._follower.smoothing;\n\t}\n\tset smoothing(smoothingTime) {\n\t\tthis._follower.smoothing = smoothingTime;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis._follower.dispose();\n\t\tthis._gt.dispose();\n\t\tthis._gate.dispose();\n\t\treturn this;\n\t}\n}\n","import { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Decibels } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Compressor } from \"./Compressor\";\nimport { Param } from \"../../core/context/Param\";\nimport { readOnly } from \"../../core/util/Interface\";\n\nexport interface LimiterOptions extends ToneAudioNodeOptions {\n\tthreshold: Decibels;\n};\n\n/**\n * Limiter will limit the loudness of an incoming signal.\n * It is composed of a [[Compressor]] with a fast attack\n * and release and max ratio. Limiters are commonly used to safeguard against\n * signal clipping. Unlike a compressor, limiters do not provide\n * smooth gain reduction and almost completely prevent\n * additional gain above the threshold.\n *\n * @example\n * const limiter = new Tone.Limiter(-20).toDestination();\n * const oscillator = new Tone.Oscillator().connect(limiter);\n * oscillator.start();\n */\nexport class Limiter extends ToneAudioNode<LimiterOptions> {\n\n\treadonly name: string = \"Limiter\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The compressor which does the limiting\n\t */\n\tprivate _compressor: Compressor;\n\n\treadonly threshold: Param<\"decibels\">\n\n\t/**\n\t * @param threshold The threshold above which the gain reduction is applied.\n\t */\n\tconstructor(threshold?: Decibels);\n\tconstructor(options?: Partial<LimiterOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Limiter.getDefaults(), arguments, [\"threshold\"])));\n\t\tconst options = optionsFromArguments(Limiter.getDefaults(), arguments, [\"threshold\"]);\n\n\t\tthis._compressor = this.input = this.output = new Compressor({\n\t\t\tcontext: this.context,\n\t\t\tratio: 20,\n\t\t\tattack: 0,\n\t\t\trelease: 0,\n\t\t\tthreshold: options.threshold\n\t\t});\n\n\t\tthis.threshold = this._compressor.threshold;\n\t\treadOnly(this, \"threshold\");\n\t}\n\n\tstatic getDefaults(): LimiterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tthreshold: -12\n\t\t});\n\t}\n\n\t/**\n\t * A read-only decibel value for metering purposes, representing the current amount of gain\n\t * reduction that the compressor is applying to the signal. \n\t */\n\tget reduction(): Decibels {\n\t\treturn this._compressor.reduction;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._compressor.dispose();\n\t\tthis.threshold.dispose();\n\t\treturn this;\n\t}\n}\n","import { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Compressor, CompressorOptions } from \"./Compressor\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MidSideSplit } from \"../channel/MidSideSplit\";\nimport { MidSideMerge } from \"../channel/MidSideMerge\";\nimport { readOnly, RecursivePartial } from \"../../core/util/Interface\";\n\nexport interface MidSideCompressorOptions extends ToneAudioNodeOptions {\n\tmid: Omit<CompressorOptions, keyof ToneAudioNodeOptions>;\n\tside: Omit<CompressorOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * MidSideCompressor applies two different compressors to the [[mid]]\n * and [[side]] signal components of the input. See [[MidSideSplit]] and [[MidSideMerge]].\n */\nexport class MidSideCompressor extends ToneAudioNode<MidSideCompressorOptions> {\n\n\treadonly name: string = \"MidSideCompressor\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * Split the incoming signal into Mid/Side\n\t */\n\tprivate _midSideSplit: MidSideSplit;\n\n\t/**\n\t * Merge the compressed signal back into a single stream\n\t */\n\tprivate _midSideMerge: MidSideMerge;\n\n\t/**\n\t * The compression applied to the mid signal\n\t */\n\treadonly mid: Compressor;\n\n\t/**\n\t * The compression applied to the side signal\n\t */\n\treadonly side: Compressor;\n\n\tconstructor(options?: RecursivePartial<MidSideCompressorOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(MidSideCompressor.getDefaults(), arguments)));\n\t\tconst options = optionsFromArguments(MidSideCompressor.getDefaults(), arguments);\n\n\t\tthis._midSideSplit = this.input = new MidSideSplit({ context: this.context });\n\t\tthis._midSideMerge = this.output = new MidSideMerge({ context: this.context });\n\t\tthis.mid = new Compressor(Object.assign(options.mid, { context: this.context }));\n\t\tthis.side = new Compressor(Object.assign(options.side, { context: this.context }));\n\n\t\tthis._midSideSplit.mid.chain(this.mid, this._midSideMerge.mid);\n\t\tthis._midSideSplit.side.chain(this.side, this._midSideMerge.side);\n\t\treadOnly(this, [\"mid\", \"side\"]);\n\t}\n\n\tstatic getDefaults(): MidSideCompressorOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmid: {\n\t\t\t\tratio: 3,\n\t\t\t\tthreshold: -24,\n\t\t\t\trelease: 0.03,\n\t\t\t\tattack: 0.02,\n\t\t\t\tknee: 16\n\t\t\t},\n\t\t\tside: {\n\t\t\t\tratio: 6,\n\t\t\t\tthreshold: -30,\n\t\t\t\trelease: 0.25,\n\t\t\t\tattack: 0.03,\n\t\t\t\tknee: 10\n\t\t\t}\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.side.dispose();\n\t\tthis._midSideSplit.dispose();\n\t\tthis._midSideMerge.dispose();\n\t\treturn this;\n\t}\n}\n","import { InputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Compressor, CompressorOptions } from \"./Compressor\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, RecursivePartial } from \"../../core/util/Interface\";\nimport { Frequency } from \"../../core/type/Units\";\nimport { MultibandSplit } from \"../channel/MultibandSplit\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Gain } from \"../../core/context/Gain\";\n\nexport interface MultibandCompressorOptions extends ToneAudioNodeOptions {\n\tmid: Omit<CompressorOptions, keyof ToneAudioNodeOptions>;\n\tlow: Omit<CompressorOptions, keyof ToneAudioNodeOptions>;\n\thigh: Omit<CompressorOptions, keyof ToneAudioNodeOptions>;\n\tlowFrequency: Frequency;\n\thighFrequency: Frequency;\n}\n\n/**\n * A compressor with separate controls over low/mid/high dynamics. See [[Compressor]] and [[MultibandSplit]]\n *\n * @example\n * const multiband = new Tone.MultibandCompressor({\n * \tlowFrequency: 200,\n * \thighFrequency: 1300,\n * \tlow: {\n * \t\tthreshold: -12\n * \t}\n * });\n */\nexport class MultibandCompressor extends ToneAudioNode<MultibandCompressorOptions> {\n\n\treadonly name: string = \"MultibandCompressor\";\n\n\treadonly input: InputNode;\n\treadonly output: ToneAudioNode;\n\n\t/**\n\t * Split the incoming signal into high/mid/low\n\t */\n\tprivate _splitter: MultibandSplit;\n\n\t/**\n\t * low/mid crossover frequency.\n\t */\n\treadonly lowFrequency: Signal<\"frequency\">;\n\n\t/**\n\t * mid/high crossover frequency.\n\t */\n\treadonly highFrequency: Signal<\"frequency\">;\n\n\t/**\n\t * The compressor applied to the low frequencies\n\t */\n\treadonly low: Compressor;\n\n\t/**\n\t * The compressor applied to the mid frequencies\n\t */\n\treadonly mid: Compressor;\n\n\t/**\n\t * The compressor applied to the high frequencies\n\t */\n\treadonly high: Compressor;\n\n\tconstructor(options?: RecursivePartial<MultibandCompressorOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(MultibandCompressor.getDefaults(), arguments)));\n\t\tconst options = optionsFromArguments(MultibandCompressor.getDefaults(), arguments);\n\n\t\tthis._splitter = this.input = new MultibandSplit({\n\t\t\tcontext: this.context,\n\t\t\tlowFrequency: options.lowFrequency,\n\t\t\thighFrequency: options.highFrequency\n\t\t});\n\t\tthis.lowFrequency = this._splitter.lowFrequency;\n\t\tthis.highFrequency = this._splitter.highFrequency;\n\t\tthis.output = new Gain({ context: this.context });\n\t\tthis.low = new Compressor(Object.assign(options.low, { context: this.context }));\n\t\tthis.mid = new Compressor(Object.assign(options.mid, { context: this.context }));\n\t\tthis.high = new Compressor(Object.assign(options.high, { context: this.context }));\n\n\t\t// connect the compressor\n\t\tthis._splitter.low.chain(this.low, this.output);\n\t\tthis._splitter.mid.chain(this.mid, this.output);\n\t\tthis._splitter.high.chain(this.high, this.output);\n\n\t\treadOnly(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n\t}\n\n\tstatic getDefaults(): MultibandCompressorOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tlowFrequency: 250,\n\t\t\thighFrequency: 2000,\n\t\t\tlow: {\n\t\t\t\tratio: 6,\n\t\t\t\tthreshold: -30,\n\t\t\t\trelease: 0.25,\n\t\t\t\tattack: 0.03,\n\t\t\t\tknee: 10\n\t\t\t},\n\t\t\tmid: {\n\t\t\t\tratio: 3,\n\t\t\t\tthreshold: -24,\n\t\t\t\trelease: 0.03,\n\t\t\t\tattack: 0.02,\n\t\t\t\tknee: 16\n\t\t\t},\n\t\t\thigh: {\n\t\t\t\tratio: 3,\n\t\t\t\tthreshold: -24,\n\t\t\t\trelease: 0.03,\n\t\t\t\tattack: 0.02,\n\t\t\t\tknee: 16\n\t\t\t},\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._splitter.dispose();\n\t\tthis.low.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.high.dispose();\n\t\tthis.output.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Decibels, Frequency } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { MultibandSplit } from \"../channel/MultibandSplit\";\n\ninterface EQ3Options extends ToneAudioNodeOptions {\n\tlow: Decibels;\n\tmid: Decibels;\n\thigh: Decibels;\n\tlowFrequency: Frequency;\n\thighFrequency: Frequency;\n}\n\n/**\n * EQ3 provides 3 equalizer bins: Low/Mid/High. \n * @category Component\n */\nexport class EQ3 extends ToneAudioNode<EQ3Options> {\n\n\treadonly name: string = \"EQ3\";\n\n\t/**\n\t * the input\n\t */\n\treadonly input: MultibandSplit;\n\n\t/**\n\t * the output\n\t */\n\treadonly output = new Gain({ context: this.context });\n\n\t/**\n\t * Splits the input into three outputs\n\t */\n\tprivate _multibandSplit: MultibandSplit;\n\n\t/**\n\t * The gain for the lower signals\n\t */\n\tprivate _lowGain: Gain<\"decibels\">;\n\n\t/**\n\t * The gain for the mid signals\n\t */\n\tprivate _midGain: Gain<\"decibels\">;\n\n\t/**\n\t * The gain for the high signals\n\t */\n\tprivate _highGain: Gain<\"decibels\">;\n\n\t/**\n\t * The gain in decibels of the low part\n\t */\n\treadonly low: Param<\"decibels\">;\n\n\t/**\n\t * The gain in decibels of the mid part\n\t */\n\treadonly mid: Param<\"decibels\">;\n\n\t/**\n\t * The gain in decibels of the high part\n\t */\n\treadonly high: Param<\"decibels\">;\n\n\t/**\n\t * The Q value for all of the filters.\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * The low/mid crossover frequency.\n\t */\n\treadonly lowFrequency: Signal<\"frequency\">;\n\n\t/**\n\t * The mid/high crossover frequency.\n\t */\n\treadonly highFrequency: Signal<\"frequency\">;\n\n\tprotected _internalChannels: ToneAudioNode[] = [];\n\n\tconstructor(lowLevel?: Decibels, midLevel?: Decibels, highLevel?: Decibels);\n\tconstructor(options: Partial<EQ3Options>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(EQ3.getDefaults(), arguments, [\"low\", \"mid\", \"high\"]));\n\t\tconst options = optionsFromArguments(EQ3.getDefaults(), arguments, [\"low\", \"mid\", \"high\"]);\n\n\t\tthis.input = this._multibandSplit = new MultibandSplit({\n\t\t\tcontext: this.context,\n\t\t\thighFrequency: options.highFrequency,\n\t\t\tlowFrequency: options.lowFrequency,\n\t\t});\n\n\t\tthis._lowGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.low,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis._midGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.mid,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis._highGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.high,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis.low = this._lowGain.gain;\n\t\tthis.mid = this._midGain.gain;\n\t\tthis.high = this._highGain.gain;\n\t\tthis.Q = this._multibandSplit.Q;\n\t\tthis.lowFrequency = this._multibandSplit.lowFrequency;\n\t\tthis.highFrequency\t= this._multibandSplit.highFrequency;\n\n\t\t// the frequency bands\n\t\tthis._multibandSplit.low.chain(this._lowGain, this.output);\n\t\tthis._multibandSplit.mid.chain(this._midGain, this.output);\n\t\tthis._multibandSplit.high.chain(this._highGain, this.output);\n\n\t\treadOnly(this, [\"low\", \"mid\", \"high\", \"lowFrequency\", \"highFrequency\"]);\n\t\tthis._internalChannels = [this._multibandSplit];\n\t}\n\n\tstatic getDefaults(): EQ3Options {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\thigh: 0,\n\t\t\thighFrequency: 2500,\n\t\t\tlow: 0,\n\t\t\tlowFrequency: 400,\n\t\t\tmid: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\twritable(this, [\"low\", \"mid\", \"high\", \"lowFrequency\", \"highFrequency\"]);\n\t\tthis._multibandSplit.dispose();\n\t\tthis.lowFrequency.dispose();\n\t\tthis.highFrequency.dispose();\n\t\tthis._lowGain.dispose();\n\t\tthis._midGain.dispose();\n\t\tthis._highGain.dispose();\n\t\tthis.low.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.high.dispose();\n\t\tthis.Q.dispose();\n\t\treturn this;\n\t}\n\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { noOp } from \"../../core/util/Interface\";\n\nexport interface ConvolverOptions extends ToneAudioNodeOptions {\n\tonload: () => void;\n\tnormalize: boolean;\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n}\n\n/**\n * Convolver is a wrapper around the Native Web Audio\n * [ConvolverNode](http://webaudio.github.io/web-audio-api/#the-convolvernode-interface).\n * Convolution is useful for reverb and filter emulation. Read more about convolution reverb on\n * [Wikipedia](https://en.wikipedia.org/wiki/Convolution_reverb).\n *\n * @example\n * // initializing the convolver with an impulse response\n * const convolver = new Tone.Convolver(\"./path/to/ir.wav\").toDestination();\n * @category Component\n */\nexport class Convolver extends ToneAudioNode<ConvolverOptions> {\n\n\treadonly name: string = \"Convolver\";\n\n\t/**\n\t * The native ConvolverNode\n\t */\n\tprivate _convolver: ConvolverNode = this.context.createConvolver();\n\n\t/**\n\t * The Buffer belonging to the convolver\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\t/**\n\t * @param url The URL of the impulse response or the ToneAudioBuffer containing the impulse response.\n\t * @param onload The callback to invoke when the url is loaded.\n\t */\n\tconstructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);\n\tconstructor(options?: Partial<ConvolverOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Convolver.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(Convolver.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tthis._buffer = new ToneAudioBuffer(options.url, buffer => {\n\t\t\tthis.buffer = buffer;\n\t\t\toptions.onload();\n\t\t});\n\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis.output = new Gain({ context: this.context });\n\n\t\t// set if it's already loaded, set it immediately\n\t\tif (this._buffer.loaded) {\n\t\t\tthis.buffer = this._buffer;\n\t\t}\n\n\t\t// initially set normalization\n\t\tthis.normalize = options.normalize;\n\n\t\t// connect it up\n\t\tthis.input.chain(this._convolver, this.output);\n\t}\n\n\tstatic getDefaults(): ConvolverOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tnormalize: true,\n\t\t\tonload: noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Load an impulse response url as an audio buffer.\n\t * Decodes the audio asynchronously and invokes\n\t * the callback once the audio buffer loads.\n\t * @param url The url of the buffer to load. filetype support depends on the browser.\n\t */\n\tasync load(url: string): Promise<void> {\n\t\tthis.buffer = await this._buffer.load(url);\n\t}\n\n\t/**\n\t * The convolver's buffer\n\t */\n\tget buffer(): ToneAudioBuffer | null {\n\t\tif (this._buffer.length) {\n\t\t\treturn this._buffer;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\tset buffer(buffer) {\n\t\tif (buffer) {\n\t\t\tthis._buffer.set(buffer);\n\t\t}\n\t\t// if it's already got a buffer, create a new one\n\t\tif (this._convolver.buffer) {\n\t\t\t// disconnect the old one\n\t\t\tthis.input.disconnect();\n\t\t\tthis._convolver.disconnect();\n\t\t\t// create and connect a new one\n\t\t\tthis._convolver = this.context.createConvolver();\n\t\t\tthis.input.chain(this._convolver, this.output);\n\t\t}\n\t\tconst buff = this._buffer.get();\n\t\tthis._convolver.buffer = buff ? buff : null;\n\t}\n\n\t/**\n\t * The normalize property of the ConvolverNode interface is a boolean that\n\t * controls whether the impulse response from the buffer will be scaled by\n\t * an equal-power normalization when the buffer attribute is set, or not.\n\t */\n\tget normalize(): boolean {\n\t\treturn this._convolver.normalize;\n\t}\n\tset normalize(norm) {\n\t\tthis._convolver.normalize = norm;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffer.dispose();\n\t\tthis._convolver.disconnect();\n\t\treturn this;\n\t}\n}\n","export { getContext, setContext } from \"./core/Global\";\nexport * from \"./classes\";\nexport * from \"./version\";\nimport { getContext } from \"./core/Global\";\nimport { ToneAudioBuffer } from \"./core/context/ToneAudioBuffer\";\nexport { start } from \"./core/Global\";\nimport { Seconds } from \"./core/type/Units\";\nexport { supported } from \"./core/context/AudioContext\";\n\n/**\n * The current audio context time of the global [[Context]]. \n * See [[Context.now]]\n * @category Core\n */\nexport function now(): Seconds {\n\treturn getContext().now();\n}\n\n/**\n * The current audio context time of the global [[Context]] without the [[Context.lookAhead]]\n * See [[Context.immediate]]\n * @category Core\n */\nexport function immediate(): Seconds {\n\treturn getContext().immediate();\n}\n\n/**\n * The Transport object belonging to the global Tone.js Context.\n * See [[Transport]]\n * @category Core\n */\nexport const Transport = getContext().transport;\n\n/**\n * The Transport object belonging to the global Tone.js Context.\n * See [[Transport]]\n * @category Core\n */\nexport function getTransport(): import(\"./core/clock/Transport\").Transport {\n\treturn getContext().transport;\n}\n\n/**\n * The Destination (output) belonging to the global Tone.js Context.\n * See [[Destination]]\n * @category Core\n */\nexport const Destination = getContext().destination;\n\n/**\n * @deprecated Use [[Destination]]\n */\nexport const Master = getContext().destination;\n\n/**\n * The Destination (output) belonging to the global Tone.js Context.\n * See [[Destination]]\n * @category Core\n */\nexport function getDestination(): import(\"./core/context/Destination\").Destination {\n\treturn getContext().destination;\n}\n\n/**\n * The [[Listener]] belonging to the global Tone.js Context.\n * @category Core\n */\nexport const Listener = getContext().listener;\n\n/**\n * The [[Listener]] belonging to the global Tone.js Context.\n * @category Core\n */\nexport function getListener(): import(\"./core/context/Listener\").Listener {\n\treturn getContext().listener;\n}\n\n/**\n * Draw is used to synchronize the draw frame with the Transport's callbacks. \n * See [[Draw]]\n * @category Core\n */\nexport const Draw = getContext().draw;\n\n/**\n * Get the singleton attached to the global context. \n * Draw is used to synchronize the draw frame with the Transport's callbacks. \n * See [[Draw]]\n * @category Core\n */\nexport function getDraw(): import(\"./core/util/Draw\").Draw {\n\treturn getContext().draw;\n}\n\n/**\n * A reference to the global context\n * See [[Context]]\n */\nexport const context = getContext();\n\n/**\n * Promise which resolves when all of the loading promises are resolved. \n * Alias for static [[ToneAudioBuffer.loaded]] method.\n * @category Core\n */\nexport function loaded() {\n\treturn ToneAudioBuffer.loaded();\n}\n\n// this fills in name changes from 13.x to 14.x\nimport { ToneAudioBuffers } from \"./core/context/ToneAudioBuffers\";\nimport { ToneBufferSource } from \"./source/buffer/ToneBufferSource\";\nexport const Buffer: typeof ToneAudioBuffer = ToneAudioBuffer;\nexport const Buffers: typeof ToneAudioBuffers = ToneAudioBuffers;\nexport const BufferSource: typeof ToneBufferSource = ToneBufferSource;\n"],"sourceRoot":""}